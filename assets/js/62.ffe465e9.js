(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{379:function(s,t,v){"use strict";v.r(t);var _=v(7),a=Object(_.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"数据结构-栈的抽象数据类型-顺序栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-栈的抽象数据类型-顺序栈"}},[s._v("#")]),s._v(" 数据结构——栈的抽象数据类型+ 顺序栈")]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936772527.png",alt:"1685936772527"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936779613.png",alt:"1685936779613"}})]),s._v(" "),t("p",[s._v("由于栈本身就是线性表，于是栈也有"),t("strong",[s._v("顺序栈")]),s._v("和"),t("strong",[s._v("链栈")]),s._v("两种实现方式")]),s._v(" "),t("p",[s._v("栈的顺序存储——顺序栈")]),s._v(" "),t("p",[s._v("栈的链式存储——链栈")]),s._v(" "),t("blockquote",[t("p",[s._v("栈的顺序表示")])]),s._v(" "),t("p",[s._v("存储方式：同一般的线性表的顺序存储结构完全相同，利用(数组)一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，栈底一般在低地址端")]),s._v(" "),t("p",[s._v("附设top指针，指示栈顶元素在顺序栈的位置")]),s._v(" "),t("p",[s._v("另设base指针，指示栈底元素在顺序栈的位置")]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936785851.png",alt:"1685936785851"}})]),s._v(" "),t("p",[s._v("但是为了方便操作通常==top指针指向栈顶元素之上的下标地址，指向线性表中的an+1==")]),s._v(" "),t("p",[s._v("另外用stacksize表示栈可使用的最大容量(栈最多可以存放的元素个数)C语言中下标不能越界否则就有语法错误")]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936792460.png",alt:"1685936792460"}})]),s._v(" "),t("p",[s._v("栈满了如果再插入元素就溢出了(上溢)")]),s._v(" "),t("p",[s._v("栈满如果还想插入元素的处理方法：")]),s._v(" "),t("p",[s._v("将原栈内容移入新栈比较费时尤其是数据量大的时候[不到万不得已不会这样操作]")]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936834086.png",alt:"1685936834086"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936844233.png",alt:"1685936844233"}})]),s._v(" "),t("p",[s._v("栈里没有元素仍要出栈(下溢)")]),s._v(" "),t("p",[s._v("使用数组作为顺序栈的存储方式的特点：")]),s._v(" "),t("p",[s._v("简单、方便、易产生溢出(数组大小固定)")]),s._v(" "),t("p",[s._v("上溢(overflow)：栈已满又要压入元素")]),s._v(" "),t("p",[s._v("下溢(underflow)：栈已空，还要弹出元素")]),s._v(" "),t("p",[s._v("注：上溢是一种错误，使问题是处理无法进行，而下溢一般认为是一种结束条件，即问题处理结束")]),s._v(" "),t("blockquote",[t("p",[s._v("顺序栈的表示")])]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936850902.png",alt:"1685936850902"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936855888.png",alt:"1685936855888"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936860972.png",alt:"1685936860972"}})]),s._v(" "),t("blockquote",[t("p",[s._v("复习线性表动态分配【对比】")])]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936866296.png",alt:"1685936866296"}})]),s._v(" "),t("p",[s._v("这是栈是限定了插入和删除的位置附设top")]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936909208.png",alt:"1685936909208"}})]),s._v(" "),t("p",[s._v("top和base可以定义为整型存储数组的下标/定义为指针(==指针相减的前提是两指针指向同一数组==)")]),s._v(" "),t("p",[t("strong",[s._v("顺序栈的初始化")]),s._v("(开辟指定大小的空栈)[maxsize太大可能分配不成功报错加上这样一个判断就可以了]")]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936916911.png",alt:"1685936916911"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936921212.png",alt:"1685936921212"}})]),s._v(" "),t("blockquote",[t("p",[s._v("【算法补充】：判断顺序栈是否为空")])]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936925644.png",alt:"1685936925644"}})]),s._v(" "),t("blockquote",[t("p",[s._v("【算法补充】：求顺序栈的长度")])]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936933013.png",alt:"1685936933013"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936938521.png",alt:"1685936938521"}})]),s._v(" "),t("blockquote",[t("p",[s._v("顺序栈的入栈")])]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936945091.png",alt:"1685936945091"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936949824.png",alt:"1685936949824"}})]),s._v(" "),t("p",[s._v("前++先用后加")]),s._v(" "),t("blockquote",[t("p",[s._v("【算法3.3】顺序栈的出栈")])]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685938579599.png",alt:"1685938579599"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685938584099.png",alt:"1685938584099"}})])])}),[],!1,null,null,null);t.default=a.exports}}]);