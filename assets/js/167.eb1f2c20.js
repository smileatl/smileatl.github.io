(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{482:function(t,s,_){"use strict";_.r(s);var r=_(7),v=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_5、简述乐观锁以及悲观锁的区别以及使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、简述乐观锁以及悲观锁的区别以及使用场景"}},[t._v("#")]),t._v(" 5、简述乐观锁以及悲观锁的区别以及使用场景")]),t._v(" "),s("ul",[s("li",[t._v("乐观锁总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现\n"),s("ul",[s("li",[t._v("工作方式：全程没有加锁（"),s("strong",[t._v("无锁编程")]),t._v("），先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作")]),t._v(" "),s("li",[t._v("应用场景：比较适合"),s("strong",[t._v("读取操作比较频繁")]),t._v("的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。")])])]),t._v(" "),s("li",[t._v("悲观锁总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起\n"),s("ul",[s("li",[t._v("工作方式：可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁")]),t._v(" "),s("li",[t._v("应用场景：比较适合"),s("strong",[t._v("写入操作比较频繁")]),t._v("的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。")])])])]),t._v(" "),s("h2",{attrs:{id:"_7、redis-优点、场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、redis-优点、场景"}},[t._v("#")]),t._v(" 7、redis 优点、场景")]),t._v(" "),s("p",[t._v("redis 优点快。\n"),s("strong",[t._v("Redis 是⼀种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度⾮常快，适⽤于")]),t._v(" "),s("strong",[t._v("服务器与数据库间的缓存")]),t._v("，还可以⽤来做分布式锁、秒杀、消息队列。")])])}),[],!1,null,null,null);s.default=v.exports}}]);