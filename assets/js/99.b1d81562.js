(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{416:function(t,a,v){"use strict";v.r(a);var s=v(7),_=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[t._v("#")]),t._v(" 进程")]),t._v(" "),a("h2",{attrs:{id:"进程相关概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程相关概念"}},[t._v("#")]),t._v(" 进程相关概念")]),t._v(" "),a("h3",{attrs:{id:"多道程序设计模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多道程序设计模型"}},[t._v("#")]),t._v(" 多道程序设计模型")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/1684222311445.png",alt:"1684222311445"}})]),t._v(" "),a("p",[t._v("并不是同时在运行这么多程序，而是以时钟中断为基础")]),t._v(" "),a("h3",{attrs:{id:"cpu"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu"}},[t._v("#")]),t._v(" cpu")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/1685194753601.png",alt:"1685194753601"}})]),t._v(" "),a("h3",{attrs:{id:"mmu"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mmu"}},[t._v("#")]),t._v(" mmu")]),t._v(" "),a("h4",{attrs:{id:"mmu-内存管理单元"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mmu-内存管理单元"}},[t._v("#")]),t._v(" mmu：内存管理单元")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/1685194835020.png",alt:"1685194835020"}})]),t._v(" "),a("p",[t._v("虚拟地址：可用的地址空间有4G")]),t._v(" "),a("p",[t._v("​\t0x804a4000\tint a = 10;")]),t._v(" "),a("p",[t._v("物理地址：1000")]),t._v(" "),a("p",[a("strong",[t._v("作用")]),t._v("：")]),t._v(" "),a("ol",[a("li",[t._v("虚拟内存与物理内存的映射，以page 4k为单位来进行映射；不同进程内核只有一块，共用同一块内存空间。")]),t._v(" "),a("li",[t._v("设置修改内存访问级别，用户空间3级，内核空间0级")])]),t._v(" "),a("blockquote",[a("p",[t._v("PCB是位于内存空间当中，但是两个进程的PCB不一样，但是他们位于同一块物理内存里")])]),t._v(" "),a("h3",{attrs:{id:"进程控制块pcb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程控制块pcb"}},[t._v("#")]),t._v(" 进程控制块PCB")]),t._v(" "),a("p",[t._v("每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。")]),t._v(" "),a("h3",{attrs:{id:"进程控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程控制"}},[t._v("#")]),t._v(" 进程控制")]),t._v(" "),a("h4",{attrs:{id:"fork函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fork函数"}},[t._v("#")]),t._v(" fork函数")]),t._v(" "),a("p",[t._v("​\t返回值有2个： 1个进程——》2个进程——》各自对fork做返回")]),t._v(" "),a("p",[t._v("​\t\t1.==父进程==的fork返回子进程的pid（非负整数）")]),t._v(" "),a("p",[t._v("​\t\t2.==子进程==返回0（表示创建成功）")]),t._v(" "),a("p",[t._v("​")]),t._v(" "),a("h3",{attrs:{id:"exec函数族"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exec函数族"}},[t._v("#")]),t._v(" exec函数族")]),t._v(" "),a("p",[t._v("exelp\t——p\t——path 系统可执行程序")]),t._v(" "),a("p",[t._v("execl\tl\t——list 用户自定义可执行程序")]),t._v(" "),a("p",[t._v("execv\tv\t——argv[]")]),t._v(" "),a("p",[t._v("execvp")]),t._v(" "),a("p",[t._v("execve \te\tenvironment")]),t._v(" "),a("p",[t._v("只有失败返回值，-1")]),t._v(" "),a("h3",{attrs:{id:"wait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wait"}},[t._v("#")]),t._v(" wait")]),t._v(" "),a("p",[t._v("僵尸进程：")]),t._v(" "),a("p",[t._v("孤儿进程：init\t——")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("pid_t wait(int *status); \t成功：清理掉的子进程ID；失败：-1 (没有子进程)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("wait(status)：返回：成功pid，失败-1")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\tstatus：传出参数")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\t1.阻塞等待子进程")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\t2.回收子进程资源")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\t3.获取子进程结束状态")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\t\t1）WIFEXITED()\t真")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\t\t\t\tWEXITSTATU()\t获取子进程退出状态")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\t\t2）WIFSIGNALED()\t真")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\t\t\t\tWTERMSIG()\t获取导致子进程终止的信号的编号")]),t._v(" "),a("h3",{attrs:{id:"waitpid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#waitpid"}},[t._v("#")]),t._v(" waitpid")]),t._v(" "),a("p",[t._v("参1：pid>0 \t指定进程id回收")]),t._v(" "),a("p",[t._v("​\t\t\tpid=-1\t回收任意子进程（wait）")]),t._v(" "),a("p",[t._v("​\t\t\tpid=0\t回收本组任意子进程")]),t._v(" "),a("p",[t._v("​\t\t\tpid<-1\t回收该进程组的任意子进程")]),t._v(" "),a("p",[t._v("参2：")]),t._v(" "),a("p",[t._v("​\tstatus")]),t._v(" "),a("p",[t._v("参3：")]),t._v(" "),a("p",[t._v("​\t0：(wait) 阻塞回收")]),t._v(" "),a("p",[t._v("​\tWNOHANG：非阻塞回收（轮询）")]),t._v(" "),a("p",[t._v("返回值：")]),t._v(" "),a("p",[t._v("​\t成功：pid")]),t._v(" "),a("p",[t._v("​\t失败：-1")]),t._v(" "),a("p",[t._v("​\t返回0值：参3传WNOHANG，并且子进程尚未结束")]),t._v(" "),a("h3",{attrs:{id:"dup2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dup2"}},[t._v("#")]),t._v(" dup2")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/1684242861349.png",alt:"1684242861349"}})]),t._v(" "),a("h2",{attrs:{id:"进程间通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信"}},[t._v("#")]),t._v(" 进程间通信")]),t._v(" "),a("p",[t._v("IPC：InterProcess Communication 进程间通信")]),t._v(" "),a("p",[t._v("文件")]),t._v(" "),a("ul",[a("li",[t._v("d 目录")]),t._v(" "),a("li",[t._v("l 符号链接  ## 以上占用磁盘存储")])]),t._v(" "),a("p",[t._v("伪文件")]),t._v(" "),a("ul",[a("li",[t._v("s 套接字")]),t._v(" "),a("li",[t._v("b 块设备")]),t._v(" "),a("li",[t._v("c 字符设备")]),t._v(" "),a("li",[t._v("p 管道            ## 不占用磁盘存储")])]),t._v(" "),a("h3",{attrs:{id:"pipe管道-简单"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pipe管道-简单"}},[t._v("#")]),t._v(" pipe管道:  (简单)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("pipe(fd[2])  fd[0] -- read;  fd[1] --- write\n\n\tfork()\n    管道一般读写行为\n\n\t\t读:  数据   字节数\n\n\t\t    无数据\n\t\t\t\n\t\t\t写端全部关闭  read -- 0  (读到结尾)\n\t\t\t\n\t\t\t仍有写端打开  阻塞等待\n\n\t\t写:  读端全闭关\t   程序异常终止(SIGPIPE)\n\n\t\t     读端仍有打开\n\n\t\t\t管道写满: 阻塞等待\n\n\t\t\t未满:  返回实际写入的字节数.  \n")])])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#include<unistd.h>\nint pipe(int filedes[2]);\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("描述：")]),t._v(" "),a("p",[t._v("pipe()会建立管道, 并将文件描述词由参数filedes数组返回。filedes[0]为管道里的读取端, filedes[1]则为管道的写入端。")]),t._v(" "),a("p",[t._v("返回值：")]),t._v(" "),a("p",[t._v("若成功则返回零, 否则返回-1, 错误原因存于errno中。")]),t._v(" "),a("h3",{attrs:{id:"fifo-命名管道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fifo-命名管道"}},[t._v("#")]),t._v(" FIFO：命名管道")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("fifo: (有名管道)  应用于非血缘关系进程间(不能反复读取)\n\t用于非血缘关系进程间通信\n\t命令: mkfifo  \n")])])]),a("h3",{attrs:{id:"共享内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[t._v("#")]),t._v(" 共享内存")]),t._v(" "),a("p",[t._v("1、mmap函数：参数：")]),t._v(" "),a("p",[t._v("​\t\t\t\t\t\t返回值：")]),t._v(" "),a("p",[t._v("2、借助共享内存放磁盘文件")]),t._v(" "),a("p",[t._v("​\t\t借助指针访问磁盘文件")]),t._v(" "),a("p",[t._v("3、父子进程、血缘关系进程\t通信")]),t._v(" "),a("p",[t._v("4、匿名映射区")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("共享内存:应用于非血缘关系进程间(能反复读取)\n\tmmap\n\t函数的参数使用注意事项.\n\t用于非血缘关系进程间通信\n套接字\t稳定\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("h4",{attrs:{id:"mmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mmap"}},[t._v("#")]),t._v(" mmap")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("void *mmap(void *addr, size_t length, int prot, int flags,\n                  int fd, off_t offset);\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("描述：")]),t._v(" "),a("p",[t._v("​\t\t创建映射区，使一个磁盘文件与存储空间中的一个缓冲区相映射")]),t._v(" "),a("p",[t._v("参数：")]),t._v(" "),a("p",[t._v("​         addr:       建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL")]),t._v(" "),a("p",[t._v("​         length： 欲创建映射区的大小")]),t._v(" "),a("p",[t._v("​         prot：      映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE")]),t._v(" "),a("p",[t._v("​         flags：     标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)")]),t._v(" "),a("p",[t._v("​                        MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上。")]),t._v(" "),a("p",[t._v("​                        MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。")]),t._v(" "),a("p",[t._v("​         fd：         用来建立映射区的文件描述符")]),t._v(" "),a("p",[t._v("​         offset：  映射文件的偏移(4k的整数倍)")]),t._v(" "),a("p",[t._v("返回：")]),t._v(" "),a("ul",[a("li",[t._v("成功：返回创建的映射区首地址；")]),t._v(" "),a("li",[a("strong",[t._v("失败：")]),t._v(" "),a("strong",[t._v("MAP_FAILED宏")])])]),t._v(" "),a("p",[t._v("其他：")]),t._v(" "),a("p",[t._v("同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。")]),t._v(" "),a("h4",{attrs:{id:"munmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#munmap"}},[t._v("#")]),t._v(" munmap")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("int munmap(void *start, size_t length);  成功：0； 失败：-1\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("描述：")]),t._v(" "),a("ul",[a("li",[t._v("munmap()用来取消参数start所指的映射内存起始地址, 参数length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时, 映射内存会自动解除, 但关闭对应的文件描述词时不会解除映射。")])]),t._v(" "),a("p",[t._v("返回值：")]),t._v(" "),a("ul",[a("li",[t._v("如果解除映射成功则返回0, 否则返回－1, 错误原因存于errno中错误代码EINVAL")])])])}),[],!1,null,null,null);a.default=_.exports}}]);