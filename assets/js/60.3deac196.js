(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{375:function(p,t,a){"use strict";a.r(t);var s=a(7),v=Object(s.a)({},(function(){var p=this,t=p._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":p.$parent.slotKey}},[t("h1",{attrs:{id:"数据结构-线性表的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-线性表的应用"}},[p._v("#")]),p._v(" 数据结构——线性表的应用")]),p._v(" "),t("blockquote",[t("p",[t("strong",[p._v("线性表的合并")])])]),p._v(" "),t("p",[t("strong",[p._v("问题描述")]),p._v("：假设利用两个线性表La和Lb分别表示两个集合A,B，现要求一个新的集合A=A∪B")]),p._v(" "),t("p",[p._v("La=(7,5,3,11)  Lb=(2,6,3)  A=(7,5,3,11,2,6)")]),p._v(" "),t("p",[t("strong",[p._v("算法步骤：")]),p._v("(A既是参数又是操作的结果)")]),p._v(" "),t("ul",[t("li",[t("p",[p._v("依次(需要循环)取出Lb中的每个元素")])]),p._v(" "),t("li",[t("p",[p._v("在La中查找该元素如果没有插入到La表尾")])])]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936440829.png",alt:"1685936440829"}})]),p._v(" "),t("p",[p._v("这里的算法是通用的与La Lb的具体存储方式无关(不关心他们是用顺序表还是链表)")]),p._v(" "),t("p",[t("strong",[p._v("算法复杂度是两线性表表长的乘积")])]),p._v(" "),t("blockquote",[t("p",[t("strong",[p._v("有序表的合并")])])]),p._v(" "),t("p",[t("strong",[p._v("问题描述")]),p._v("：已知线性表La和Lb中的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc且Lc中的数据元素按值非递减有序排列(不一定是严格递增的可能出现相等的元素)")]),p._v(" "),t("p",[p._v("La=(1,7,8)Lb=(2,4,6,8,10,11)A=(1,2,4,6,7,8,8,10,11)")]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936449161.png",alt:"1685936449161"}})]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936454499.png",alt:"1685936454499"}})]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936460269.png",alt:"1685936460269"}})]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936466324.png",alt:"1685936466324"}})]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936472724.png",alt:"1685936472724"}})]),p._v(" "),t("p",[p._v("循环比较-小的值放入Lc-移动小的元素所在数组的指针和Lc指针")]),p._v(" "),t("p",[t("strong",[p._v("[复习]")]),p._v(" 数组名即数组的首地址是常量")]),p._v(" "),t("p",[p._v("int a[10];")]),p._v(" "),t("p",[p._v("int *p=a;/*int *p;p=a而p=a与p=&a[0]等价*/")]),p._v(" "),t("p",[p._v("如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素如果p的初值为&a[0],则：p+i和a+i 就是 a[i]的地址,*(p+i)即为a[i]")]),p._v(" "),t("p",[p._v("引用一个数组元素可以用：")]),p._v(" "),t("ol",[t("li",[t("p",[p._v("下标法，即用 a[i]形式访问数组元素。在前面介绍数组时都是采用这种方法。")])]),p._v(" "),t("li",[t("p",[p._v("指针法，即采用(a+i)或(p+i)形式，用间接访问的方法来访问数组元素")])])]),p._v(" "),t("p",[p._v("自增运算++在后先用后加=>*pc=*pa;pa++;pc++")]),p._v(" "),t("p",[p._v("指针到达尾指针达到表尾指针<尾指针未到表尾而有一个到达表尾就停止判断")]),p._v(" "),t("p",[p._v("算法时间复杂度两表表长之和")]),p._v(" "),t("p",[p._v("算法的空间复杂度两表表长之和")]),p._v(" "),t("p",[p._v("下标/索引")]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936483702.png",alt:"1685936483702"}})]),p._v(" "),t("p",[p._v("2.链表实现")]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936513672.png",alt:"1685936513672"}})]),p._v(" "),t("p",[p._v("Lc仍是带表头结点的单链表在La和Lb的表头结点中任选一个(这里我们选La的头结点作为Lc的头结点Lc=La)")]),p._v(" "),t("p",[p._v("当然像La和Lb一样Lc同样需要一个pc")]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936519374.png",alt:"1685936519374"}})]),p._v(" "),t("p",[p._v("（比较大小）1<2即pa->data < pb->data=>pa指向的结点插入到pc后(pc->next=pa)(而pc指向当前表尾(pc=pa;)且移动pa(pa=pa->next;)小的元素插入到pc后移动pc指向当前表尾移动小元素所在链表的指针)直到一个链表中所有元素都插入到Lc中")]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936563622.png",alt:"1685936563622"}})]),p._v(" "),t("p",[p._v("（pa？pc->next=pb:pc->next=pa;）")]),p._v(" "),t("p",[t("img",{attrs:{src:"/assets/1685936589065.png",alt:"1685936589065"}})])])}),[],!1,null,null,null);t.default=v.exports}}]);