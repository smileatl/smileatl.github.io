(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{376:function(t,s,v){"use strict";v.r(s);var _=v(7),p=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"数据结构-双向链表、循环链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-双向链表、循环链表"}},[t._v("#")]),t._v(" 数据结构——双向链表、循环链表")]),t._v(" "),s("blockquote",[s("p",[t._v("循环链表")])]),t._v(" "),s("p",[t._v("循环链表是头尾相接的链表(即表中最后一个结点的指针域指向头结点，整个链表形成一个"),s("strong",[t._v("环")]),t._v(")(circular linked list)")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936324277.png",alt:"1685936324277"}})]),t._v(" "),s("p",[t._v("**优点：**从表中任一结点出发均可访问全部结点")]),t._v(" "),s("p",[t._v("循环链表与单链表的主要"),s("strong",[t._v("差异")]),t._v("当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL或p->next!=NULL,而循环单链表的判别条件为p!=L或p->next!=L。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936333571.png",alt:"1685936333571"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936341314.png",alt:"1685936341314"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936349787.png",alt:"1685936349787"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936355723.png",alt:""}})]),t._v(" "),s("p",[t._v("算法的复杂度O(1)（常数阶）")]),t._v(" "),s("blockquote",[s("p",[t._v("双向链表")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936364955.png",alt:"1685936364955"}})]),t._v(" "),s("p",[t._v("为了克服单链表的这一缺点，老科学家们设计了双向链表(double linked list)是在单链表的每个结点中再设计一个指向其前驱结点的指针域。所以在双向链表中的结点有两个指针域，一个指向直接后继，另一个指向直接前驱。这样链表中有两个不同方向的链。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936371052.png",alt:"1685936371052"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://i0.hdslb.com/bfs/article/d3dbb3ddb571440fae80da52b3bdfb09a1f689d6.png",alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936376104.png",alt:"1685936376104"}})]),t._v(" "),s("p",[t._v('与单循环链表类似双向链表也可以有循环表(首尾相接形成"环"[2个])'),s("br"),t._v("\n让头结点的前驱指针指向链表的最后一个结点"),s("br"),t._v("\n最后一个结点的后继指针指向头结点")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936382462.png",alt:"1685936382462"}})]),t._v(" "),s("p",[t._v("双向链表结构有"),s("strong",[t._v("对称性")]),t._v("(设指针p指向某一个结点)"),s("br"),t._v(" "),s("strong",[t._v("p->prior->next=p=p->next->prior")]),t._v("(前进一步后退一步相当于原地踏步)")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936387865.png",alt:"1685936387865"}})]),t._v(" "),s("p",[t._v("在双向链表中有些操作(ListLength,GetElemment等因为只涉及一个方向的指针他们的算法与线性表的相同)但在插入和删除需要修改两个方向上的指针两者的算法复杂度均为O(n)")]),t._v(" "),s("blockquote",[s("p",[t._v("[算法2.13]双向链表的插入")])]),t._v(" "),s("p",[t._v("带头结点的双向链表L中第i个位置之前(b)插入前插入一个新结点")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936395518.png",alt:"1685936395518"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936400635.png",alt:"1685936400635"}})]),t._v(" "),s("p",[t._v("单链表只需修改两个指针，而双向链表修改四个指针")]),t._v(" "),s("p",[t._v("算法复杂度O(n)")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936405058.png",alt:"1685936405058"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936409720.png",alt:"1685936409720"}})]),t._v(" "),s("p",[t._v("算法复杂度O(n)")]),t._v(" "),s("blockquote",[s("p",[t._v("小结")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936415021.png",alt:"1685936415021"}})]),t._v(" "),s("blockquote",[s("p",[t._v("链式存储结构的优点：")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("结点空间可以动态申请和释放；")])]),t._v(" "),s("li",[s("p",[t._v("数据元素的逻辑次序靠结点的指针来指示，插入和删除不需要移动元素。")])]),t._v(" "),s("li",[s("p",[t._v("链式存储结构的缺点：")])]),t._v(" "),s("li",[s("p",[t._v("存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占的字节数不多时，指针域所占的存储空间的比重显得很大。")])]),t._v(" "),s("li",[s("p",[t._v("存储密度是指结点"),s("strong",[t._v("数据本身占用")]),t._v("的空间**/结点占用的空间总量**")])])]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936423756.png",alt:"1685936423756"}})]),t._v(" "),s("p",[t._v("链式存储结构是"),s("strong",[t._v("非随机存取")]),t._v("结构。对任一结点的操作都要从头指针依指针链查找到该结点，这增加了算法的复杂度。(对某个结点操作一般要先找到该结点)")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1685936431270.png",alt:"1685936431270"}})])])}),[],!1,null,null,null);s.default=p.exports}}]);