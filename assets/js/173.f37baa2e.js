(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{490:function(t,s,n){"use strict";n.r(s);var a=n(7),e=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1、vector扩容-什么情况1-5倍-什么情况2倍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、vector扩容-什么情况1-5倍-什么情况2倍"}},[t._v("#")]),t._v(" 1、Vector扩容，什么情况1.5倍，什么情况2倍？")]),t._v(" "),s("p",[t._v("vector 在插入新的元素时，但是之前的内存已经满的时候需要扩容，在VS下是1.5倍，在GCC 下是2 倍。")]),t._v(" "),s("h2",{attrs:{id:"_2、vector的resize和reserve有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、vector的resize和reserve有什么区别"}},[t._v("#")]),t._v(" 2、Vector的resize和reserve有什么区别？")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("resize")]),t._v(": "),s("code",[t._v("resize(n)")]),t._v("会改变vector的大小，使其包含n个元素。如果n大于当前的大小，那么新的元素会被添加到vector的末尾，如果n小于当前的大小，那么末尾的元素会被删除。"),s("code",[t._v("resize")]),t._v("会改变vector的"),s("code",[t._v("size()")]),t._v("。")]),t._v(" "),s("li",[s("strong",[t._v("reserve")]),t._v(": "),s("code",[t._v("reserve(n)")]),t._v("不会改变vector的大小，它只是预先分配足够的内存，以便在未来可以容纳n个元素。"),s("code",[t._v("reserve")]),t._v("不会改变vector的"),s("code",[t._v("size()")]),t._v("，但可能会改变"),s("code",[t._v("capacity()")]),t._v("。"),s("code",[t._v("reserve")]),t._v("的主要目的是为了优化性能，避免在添加元素时频繁进行内存分配。")])]),t._v(" "),s("p",[t._v("简单来说，"),s("code",[t._v("resize")]),t._v("改变的是vector中元素的数量，而"),s("code",[t._v("reserve")]),t._v("改变的是vector的内存容量。")]),t._v(" "),s("h2",{attrs:{id:"_3、vector中push-back和emplace-back的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、vector中push-back和emplace-back的区别"}},[t._v("#")]),t._v(" 3、vector中push_back和emplace_back的区别？")]),t._v(" "),s("p",[t._v("emplace_back通常在性能上优于push_back，因为它可以避免不必要的复制或移动操作。")]),t._v(" "),s("ul",[s("li",[t._v("push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）")]),t._v(" "),s("li",[t._v("而emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。")])]),t._v(" "),s("h2",{attrs:{id:"_4、map-set-unordered-map-unordered-set-底层是用了什么数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、map-set-unordered-map-unordered-set-底层是用了什么数据结构"}},[t._v("#")]),t._v(" 4、Map，set，unordered_map，unordered_set，底层是用了什么数据结构？")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("Map")]),t._v(": 底层实现通常是红黑树，这是一种自平衡的二叉查找树。它可以保证插入、删除和查找的时间复杂度都是O(log n)。")]),t._v(" "),s("li",[s("strong",[t._v("Set")]),t._v(": 与Map类似，Set的底层实现通常也是红黑树。Set是一种特殊的Map，只有键没有值。")]),t._v(" "),s("li",[s("strong",[t._v("Unordered_map")]),t._v(": 底层实现通常是哈希表。哈希表可以提供平均时间复杂度为O(1)的查找。")]),t._v(" "),s("li",[s("strong",[t._v("Unordered_set")]),t._v(": 与Unordered_map类似，Unordered_set的底层实现通常也是哈希表。Unordered_set是一种特殊的Unordered_map，只有键没有值。")])]),t._v(" "),s("h2",{attrs:{id:"_5、hash-map和map区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、hash-map和map区别"}},[t._v("#")]),t._v(" 5、hash_map和map区别")]),t._v(" "),s("ul",[s("li",[t._v("构造函数："),s("strong",[t._v("hash_map需要hash函数，等于函数")]),t._v("；map只需要比较函数(小于函数)")]),t._v(" "),s("li",[t._v("存储结构："),s("strong",[t._v("hash_map采用hash表存储")]),t._v("，map一般采用红黑树(RB Tree)实现。因此其memory数据结构是不一样的")])]),t._v(" "),s("h2",{attrs:{id:"_8、请说说-stl-的基本组成部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8、请说说-stl-的基本组成部分"}},[t._v("#")]),t._v(" 8、请说说 STL 的基本组成部分")]),t._v(" "),s("p",[t._v("标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的\n集合。")]),t._v(" "),s("p",[s("strong",[t._v("广义上讲")]),t._v("，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算\n法通过迭代器可以进行无缝地连接。")]),t._v(" "),s("p",[s("strong",[t._v("详细的说")]),t._v("，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数\n（Function object）、适配器（Adaptor）、空间配置器（Allocator）。")]),t._v(" "),s("p",[t._v("标准模板库STL主要由6大组成部分：")]),t._v(" "),s("ol",[s("li",[t._v("容器(Container)\n"),s("strong",[t._v("是一种数据结构")]),t._v("， 如list, vector, 和deques，"),s("strong",[t._v("以模板类的方法提供")]),t._v("。为了访问容器中的数据，可\n以使用由容器类输出的迭代器。")]),t._v(" "),s("li",[t._v("算法（Algorithm）\n"),s("strong",[t._v("是用来操作容器中的数据的模板函数")]),t._v("。例如，STL用sort()来对一 个vector中的数据进行排序，\n用ﬁnd()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以\n用于从简单数组到高度复杂容器的任何数据结构上。")]),t._v(" "),s("li",[t._v("迭代器（Iterator）\n"),s("strong",[t._v("提供了访问容器中对象的方法")]),t._v("。例如，可以使用一对迭代器指定list或vector中的一定范围的对\n象。 迭代器"),s("strong",[t._v("就如同一个指针")]),t._v("。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些\n定义了operator*()以及其他类似于指针的操作符方法的类对象;")]),t._v(" "),s("li",[t._v("仿函数（Function object）\n仿函数又称之为函数对象， 其实就是"),s("strong",[t._v("重载了操作符的struct")]),t._v(",没有什么特别的地方。")]),t._v(" "),s("li",[t._v("适配器（Adaptor）\n简单的说就是一种"),s("strong",[t._v("接口类")]),t._v("，专门用来"),s("strong",[t._v("修改现有类的接口")]),t._v("，提供一中新的接口；或调用现有的函\n数来实现所需要的功能。主要包括3中适配器"),s("strong",[t._v("Container Adaptor、Iterator Adaptor、Function")]),t._v(" "),s("strong",[t._v("Adaptor")]),t._v("。")]),t._v(" "),s("li",[t._v("空间配制器（Allocator）\n为STL提供空间配置的系统。其中主要工作包括两部分：\n（1）"),s("strong",[t._v("对象的创建与销毁")]),t._v("；\n（2）"),s("strong",[t._v("内存的获取与释放")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"_11、请说说-stl-中常见的容器-并介绍一下实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11、请说说-stl-中常见的容器-并介绍一下实现原理"}},[t._v("#")]),t._v(" 11、请说说 STL 中常见的容器，并介绍一下实现原理")]),t._v(" "),s("p",[t._v("容器可以用于"),s("strong",[t._v("存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类")]),t._v("，分为顺序\n容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：")]),t._v(" "),s("ol",[s("li",[t._v("顺序容器")])]),t._v(" "),s("p",[s("strong",[t._v("容器并非排序的，元素的插入位置同元素的值无关")]),t._v("。包含vector、deque、list，具体实现原理\n如下：\n（1）vector 头文件\n动态数组。"),s("strong",[t._v("元素在内存连续存放")]),t._v("。随机存取任何元素都能在常数时间完成。在尾端增删元\n素具有较佳的性能。\n（2）deque 头文件\n双向队列。"),s("strong",[t._v("元素在内存连续存放")]),t._v("。随机存取任何元素都能在常数时间完成（仅次于vector）。在\n两端增删元素具有较佳的性能（大部分情况下是常数时间）。\n（3）list 头文件\n双向链表。元素在内存"),s("strong",[t._v("不连续")]),t._v("存放。在任何位置增删元素都能在常数时间完成。不支持随机\n存取。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("关联式容器\n元素是排序的；"),s("strong",[t._v("插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性")]),t._v(" "),s("strong",[t._v("能")]),t._v("；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：\n（1）set/multiset 头文件\nset 即集合。set中不允许相同元素，multiset中允许存在相同元素。\n（2）map/multimap 头文件\nmap与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为ﬁrst,另一个名为\nsecond, "),s("strong",[t._v("map根据ﬁrst值对元素从小到大排序，并可快速地根据ﬁrst来检索元素")]),t._v("。\n注意：map同multimap的不同在于是否允许相同ﬁrst值的元素。")])]),t._v(" "),s("li",[s("p",[t._v("容器适配器"),s("br"),t._v(" "),s("strong",[t._v("封装了一些基本的容器，使之具备了新的函数功能")]),t._v("，比如把deque封装一下变为一个具有stack\n功能的数据结构。这新得到的数据结构就叫适配器。包含"),s("strong",[t._v("stack,queue,priority_queue")]),t._v("，具体实现\n原理如下：\n（1）stack 头文件\n栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶\n的项）。后进先出。\n（2）queue 头文件\n队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。\n（3）priority_queue 头文件\n优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元\n素总是第一个出列。")])])]),t._v(" "),s("h2",{attrs:{id:"_14、map-hashtable-deque-list-的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14、map-hashtable-deque-list-的实现原理"}},[t._v("#")]),t._v(" 14、map hashtable deque list 的实现原理")]),t._v(" "),s("p",[t._v("map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特\n性分别如下：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("map实现原理\nmap内部实现了一个"),s("strong",[t._v("红黑树")]),t._v("（"),s("strong",[t._v("红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索")]),t._v(" "),s("strong",[t._v("树")]),t._v("），红黑树有自动排序的功能，因此"),s("strong",[t._v("map内部所有元素都是有序的")]),t._v("，红黑树的每一个节点都代\n表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红\n黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就\n是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使\n用"),s("strong",[t._v("中序遍历可将键值按照从小到大遍历出来")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("hashtable（也称散列表，直译作哈希表）实现原理\nhashtable采用了"),s("strong",[t._v("函数映射的思想，记录的存储位置与记录的关键字关联起来")]),t._v("，从而能够很快速地\n进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的\n区别，它"),s("strong",[t._v("能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查")]),t._v(" "),s("strong",[t._v("找")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("deque实现原理\ndeque内部 现的是一个双向队列。元素在内存连续存放。"),s("strong",[t._v("随机存取任何元素都在常数时间完成")]),t._v("\n（仅次于vector）。所有适用于vector的操作都适用于deque。"),s("strong",[t._v("在两端增删元素具有较佳的性能")]),t._v("\n（大部分情况下是常数时间）。")])]),t._v(" "),s("li",[s("p",[t._v("list实现原理\nlist内部实现的是一个双向链表。元素在内存不连续存放。在"),s("strong",[t._v("任何位置增删元素都能在常数时间")]),t._v(" "),s("strong",[t._v("完成")]),t._v("。"),s("strong",[t._v("不支持随机存取")]),t._v("。无成员函数，给定一个下标i，访问第i个元素的内容，"),s("strong",[t._v("只能从头部挨个遍")]),t._v(" "),s("strong",[t._v("历到第i个元素")]),t._v("。")])])]),t._v(" "),s("h2",{attrs:{id:"_16、请你来介绍一下-stl-的空间配置器-allocator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16、请你来介绍一下-stl-的空间配置器-allocator"}},[t._v("#")]),t._v(" 16、请你来介绍一下 STL 的空间配置器（allocator）")]),t._v(" "),s("p",[t._v("一般情况下,"),s("strong",[t._v("一个程序包括数据结构和相应的算法")]),t._v("，而"),s("strong",[t._v("数据结构作为存储数据的组织形式，与内存空间")]),t._v(" "),s("strong",[t._v("有着密切的联系")]),t._v("。在C++ STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)\n分配的工具，他与容器联系紧密，"),s("strong",[t._v("每一种容器的空间分配都是通过空间分配器allocator实现的")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("答案解析")])]),t._v(" "),s("ol",[s("li",[t._v("两种C++类对象实例化方式的异同\n在c++中，创建类对象一般分为两种方式：一种是"),s("strong",[t._v("直接利用构造函数")]),t._v(",直接构造类对象，如 Test\ntest()；另一种是"),s("strong",[t._v("通过new来实例化")]),t._v("一个类对象，如 Test *pTest = new Test；那么，这两种方式有\n什么异同点呢？\n我们知道，内存分配主要有三种方式：\n（1） 静态存储区分配：内存在"),s("strong",[t._v("程序编译的时候已经分配好，这块内存在程序的整个运行空间内都")]),t._v(" "),s("strong",[t._v("存在。如全局变量,静态变量等")]),t._v("。\n（2） 栈空间分配：程序在运行期间，"),s("strong",[t._v("函数内的局部变量通过栈空间来分配存储")]),t._v("（函数调用栈），\n当函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。\n（3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创\n建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()\n函数对堆空间进行释放，否则会造成内存溢出。")])]),t._v(" "),s("p",[t._v("那么，从"),s("strong",[t._v("内存空间分配的角度")]),t._v("来对这两种方式的区别，就比较容易区分:\n（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例\n化对象是一个局部变量，则其是在"),s("strong",[t._v("栈空间")]),t._v("分配相应的存储空间。\n（2）对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,\n其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内\n容；同样，使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调\n用delete释放"),s("strong",[t._v("堆")]),t._v("空间。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("C++ STL空间配置器实现")]),t._v(" "),s("p",[t._v("很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的\n空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而\n是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所\n以，在SGI STL中，"),s("strong",[t._v("将对象的构造切分开来，分成空间配置和对象构造两部分")]),t._v("。\n"),s("strong",[t._v("内存配置操作: 通过alloc::allocate()实现")]),t._v(" "),s("strong",[t._v("内存释放操作: 通过alloc::deallocate()实现")]),t._v(" "),s("strong",[t._v("对象构造操作: 通过::construct()实现")]),t._v(" "),s("strong",[t._v("对象释放操作: 通过::destroy()实现")]),t._v("\n关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑"),s("strong",[t._v("大块")]),t._v("内存空\n间，利用"),s("strong",[t._v("malloc和free")]),t._v("实现；二级配置器主要是考虑"),s("strong",[t._v("小块内存")]),t._v("空间而设计的（"),s("strong",[t._v("为了最大化解决内存")]),t._v(" "),s("strong",[t._v("碎片问题，进而提升效率")]),t._v("），采用"),s("strong",[t._v("链表free_list来维护内存池")]),t._v("（memory pool），free_list通过\nunion结构实现，"),s("strong",[t._v("空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维")]),t._v(" "),s("strong",[t._v("护")]),t._v("。")])])]),t._v(" "),s("h2",{attrs:{id:"_18、stl-容器用过哪些-查找的时间复杂度是多少-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18、stl-容器用过哪些-查找的时间复杂度是多少-为什么"}},[t._v("#")]),t._v(" 18、STL 容器用过哪些，查找的时间复杂度是多少，为什么？")]),t._v(" "),s("p",[t._v("参考回答\nSTL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、\nunordered_set等。容器底层实现方式及时间复杂度分别如下：")]),t._v(" "),s("ol",[s("li",[t._v("vector\n采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：\n插入: O(N)\n查看: O(1)\n删除: O(N)")]),t._v(" "),s("li",[t._v("deque\n采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：\n插入: O(N)\n查看: O(1)\n删除: O(N)")]),t._v(" "),s("li",[t._v("list\n采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：\n插入: O(1)\n查看: O(N)\n删除: O(1)")]),t._v(" "),s("li",[t._v("map、set、multimap、multiset\n上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:\n插入: O(logN)\n查看: O(logN)\n删除: O(logN)")]),t._v(" "),s("li",[t._v("unordered_map、unordered_set、unordered_multimap、 unordered_multiset\n上述四种容器采用哈希表实现，不同操作的时间复杂度为：\n插入: O(1)，最坏情况O(N)\n查看: O(1)，最坏情况O(N)\n删除: O(1)，最坏情况O(N)")])]),t._v(" "),s("p",[t._v("注意：容器的时间复杂度取决于其底层实现方式。")]),t._v(" "),s("h2",{attrs:{id:"_21、迭代器用过吗-什么时候会失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21、迭代器用过吗-什么时候会失效"}},[t._v("#")]),t._v(" 21、迭代器用过吗？什么时候会失效？")]),t._v(" "),s("p",[t._v("用过，常用容器迭代器失效情形如下。")]),t._v(" "),s("ol",[s("li",[t._v("对于序列容器vector，deque来说，"),s("strong",[t._v("使用erase后，后边的每个元素的迭代器都会失效，后边每个")]),t._v(" "),s("strong",[t._v("元素都往前移动一位，erase返回下一个有效的迭代器")]),t._v("。")]),t._v(" "),s("li",[t._v("对于关联容器map，set来说，使"),s("strong",[t._v("用了erase后，当前元素的迭代器失效")]),t._v("，但是其结构是红黑树，\n"),s("strong",[t._v("删除当前元素，不会影响下一个元素的迭代器")]),t._v("，所以在调用erase之前，"),s("strong",[t._v("记录下一个元素的迭代器")]),t._v(" "),s("strong",[t._v("即可")]),t._v("。")]),t._v(" "),s("li",[t._v("对于list来说，它"),s("strong",[t._v("使用了不连续分配的内存")]),t._v("，"),s("strong",[t._v("并且它的erase方法也会返回下一个有效的迭代器")]),t._v("，因\n此上面两种方法都可以使用。")])]),t._v(" "),s("h2",{attrs:{id:"_24、说一下stl中迭代器的作用-有指针为何还要迭代器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_24、说一下stl中迭代器的作用-有指针为何还要迭代器"}},[t._v("#")]),t._v(" 24、说一下STL中迭代器的作用，有指针为何还要迭代器？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("迭代器的作用\n（1）用于指向顺序容器和关联容器中的元素\n（2）通过迭代器可以读取它指向的元素\n（3）通过非const迭代器还可以修改其指向的元素")])]),t._v(" "),s("li",[s("p",[t._v("迭代器和指针的区别\n"),s("strong",[t._v("迭代器不是指针，是类模板，表现的像指针")]),t._v("。他只是模拟了指针的一些功能，重载了指针的一\n些操作符，--\x3e、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard Template\nLibrary）容器内全部或部分元素”的对象，"),s("strong",[t._v("本质是封装了原生指针")]),t._v("，是指针概念的一种提升，提供\n了"),s("strong",[t._v("比指针更高级")]),t._v("的行为，"),s("strong",[t._v("相当于一种智能指针")]),t._v("，他可以根据不同类型的数据结构来实现不同的\n++，--等操作。\n"),s("strong",[t._v("迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直")]),t._v(" "),s("strong",[t._v("接输出其自身")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("迭代器产生的原因\nIterator类的访问方式就是"),s("strong",[t._v("把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而")]),t._v(" "),s("strong",[t._v("达到循环遍历集合的效果")]),t._v("。")])])]),t._v(" "),s("p",[s("strong",[t._v("答案解析")])]),t._v(" "),s("ol",[s("li",[t._v("迭代器\nIterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法顺序访问一个聚合对象中\n各个元素, 而又不需暴露该对象的内部表示。 或者这样说可能更容易理解：Iterator模式是运用于\n聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定\n顺序（由iterator提供的方法）访问聚合对象中的各个元素。 "),s("strong",[t._v("由于Iterator模式的以上特性：与聚")]),t._v(" "),s("strong",[t._v("合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、")]),t._v(" "),s("strong",[t._v("vector、stack等容器类及ostream_iterator等扩展Iterator")]),t._v("。")])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<vector>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("using")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//一个存放int元素的数组，一开始里面没有元素")]),t._v("\n    v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("const_iterator i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//常量迭代器")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("end")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//v.begin()表示v第一个元素迭代器指针，++i")]),t._v("\n指向下一个元素\n        cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('","')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//*i表示迭代器指向的元素")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("reverse_iterator r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//反向迭代器")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("r "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rbegin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" r "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rend")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" r"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("r "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('","')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("iterator j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//非常量迭代器")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("end")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("end")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('","')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*    \n    运行结果：\n    1,2,3,4,\n    4,3,2,1,\n    100,100,100,100,\n*/")]),t._v("         \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br"),s("span",{staticClass:"line-number"},[t._v("34")]),s("br")])]),s("h2",{attrs:{id:"_27、说说-stl-迭代器是怎么删除元素的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_27、说说-stl-迭代器是怎么删除元素的"}},[t._v("#")]),t._v(" 27、说说 STL 迭代器是怎么删除元素的")]),t._v(" "),s("p",[t._v("参考回答\n这是主要考察迭代器失效的问题。")]),t._v(" "),s("ol",[s("li",[t._v("对于序列容器vector，deque来说，"),s("strong",[t._v("使用erase后，后边的每个元素的迭代器都会失效，后边每个")]),t._v(" "),s("strong",[t._v("元素都往前移动一位，erase返回下一个有效的迭代器")]),t._v("；")]),t._v(" "),s("li",[t._v("对于关联容器map，set来说，"),s("strong",[t._v("使用了erase后，当前元素的迭代器失效")]),t._v("，但是其结构是红黑树，\n"),s("strong",[t._v("删除当前元素，不会影响下一个元素的迭代器")]),t._v("，所以在"),s("strong",[t._v("调用erase之前，记录下一个元素的迭代器")]),t._v(" "),s("strong",[t._v("即可")]),t._v("；")]),t._v(" "),s("li",[t._v("对于list来说，它"),s("strong",[t._v("使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器")]),t._v("，因\n此上面两种方法都可以使用。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/1694058156778.png",alt:"1694058156778"}})]),t._v(" "),s("h2",{attrs:{id:"_30、-说说-stl-中-resize-和-reserve-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_30、-说说-stl-中-resize-和-reserve-的区别"}},[t._v("#")]),t._v(" 30、 说说 STL 中 resize 和 reserve 的区别")]),t._v(" "),s("ol",[s("li",[t._v("首先必须弄清楚两个概念：\n（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通\n过下标等访问，因为此时容器中还没有创建任何对象。\n（2）size：指的是此时容器中"),s("strong",[t._v("实际")]),t._v("的元素个数。可以通过下标访问0-(size-1)范围内的对象。")]),t._v(" "),s("li",[t._v("resize和reserve区别主要有以下几点：\n（1）"),s("strong",[t._v("resize既分配了空间，也创建了对象")]),t._v("；"),s("strong",[t._v("reserve表示容器预留空间，但并不是真正的创建对")]),t._v(" "),s("strong",[t._v("象，需要通过insert（）或push_back（）等创建对象")]),t._v("。\n（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大\n小。\n（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为\n0）；reserve只带一个参数，表示容器预留的大小。")])]),t._v(" "),s("p",[s("strong",[t._v("答案解析")])]),t._v(" "),s("p",[t._v("resize 和 reserve 既有差别，也有共同点。两个接口的"),s("strong",[t._v("共同点")]),t._v("是它们都保证了"),s("strong",[t._v("vector的空间大小")]),t._v(" "),s("strong",[t._v("(capacity)最少达到它的参数所指定的大小")]),t._v("。下面就他们的细节进行分析。")]),t._v(" "),s("p",[t._v("为实现resize的语义，resize接口做了两个保证：\n（1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[index]是合法\n的；\n（2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[index]是非法\n的。\nreserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围\n内，"),s("strong",[t._v("如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而")]),t._v(" "),s("strong",[t._v("定")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_type new_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_type new_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new_size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("erase")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" new_size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("end")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// erase区间范围以外的数据，确保区间以外的数")]),t._v("\n据无效\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("end")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" new_size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 填补区间范围内空缺的数据，确保区间内的")]),t._v("\n数据有效\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<vector>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("using")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"initial capacity:"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("capacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"initial size:"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*resize改变capacity和size*/")]),t._v("\n    a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"resize capacity:"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("capacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"resize size:"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    vector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*reserve改变capacity,不改变resize*/")]),t._v("\n    b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reserve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"reserve capacity:"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("capacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"reserve size:"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*    \n    运行结果：\n    initial capacity:0\n    initial size:0\n    resize capacity:20\n    resize size:20\n    reserve capacity:100\n    reserve size:0\n*/")]),t._v("  \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br"),s("span",{staticClass:"line-number"},[t._v("34")]),s("br"),s("span",{staticClass:"line-number"},[t._v("35")]),s("br"),s("span",{staticClass:"line-number"},[t._v("36")]),s("br"),s("span",{staticClass:"line-number"},[t._v("37")]),s("br"),s("span",{staticClass:"line-number"},[t._v("38")]),s("br"),s("span",{staticClass:"line-number"},[t._v("39")]),s("br"),s("span",{staticClass:"line-number"},[t._v("40")]),s("br"),s("span",{staticClass:"line-number"},[t._v("41")]),s("br"),s("span",{staticClass:"line-number"},[t._v("42")]),s("br"),s("span",{staticClass:"line-number"},[t._v("43")]),s("br"),s("span",{staticClass:"line-number"},[t._v("44")]),s("br"),s("span",{staticClass:"line-number"},[t._v("45")]),s("br")])]),s("p",[s("strong",[t._v("注意")]),t._v("：如果n大于当前的vector的容量(是容量，并非vector的size)，将会引起自动内存分配。所以现\n有的pointer,references,iterators将会失效。而内存的重新配置会很耗时间。")]),t._v(" "),s("h2",{attrs:{id:"_32、说说-stl-容器动态链接可能产生的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_32、说说-stl-容器动态链接可能产生的问题"}},[t._v("#")]),t._v(" 32、说说 STL 容器动态链接可能产生的问题？")]),t._v(" "),s("p",[t._v("参考回答")]),t._v(" "),s("ol",[s("li",[t._v("可能产生 的问题\n"),s("strong",[t._v("容器是一种动态分配内存空间的一个变量集合类型变量")]),t._v("。在一般的程序函数里，局部容器，参\n数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数\n内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的\n问题。")]),t._v(" "),s("li",[t._v("产生问题的原因\n"),s("strong",[t._v("容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，")]),t._v(" "),s("strong",[t._v("并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问")]),t._v(" "),s("strong",[t._v("题")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"_34、说说-map-和-unordered-map-的区别-底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_34、说说-map-和-unordered-map-的区别-底层实现"}},[t._v("#")]),t._v(" 34、说说 map 和 unordered_map 的区别？底层实现")]),t._v(" "),s("p",[t._v("map和unordered_map的区别在于他们的实现基理不同。")]),t._v(" "),s("ol",[s("li",[t._v("map实现机理\nmap内部实现了一个"),s("strong",[t._v("红黑树")]),t._v("（红黑树是"),s("strong",[t._v("非严格平衡的二叉搜索树")]),t._v("，而"),s("strong",[t._v("AVL是严格平衡二叉搜索")]),t._v(" "),s("strong",[t._v("树")]),t._v("），红黑树有自动排序的功能，因此map内部所有元素都是"),s("strong",[t._v("有序")]),t._v("的，红黑树的每一个节点都代\n表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红\n黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就\n是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使\n用中序遍历可将键值按照从小到大遍历出来。")]),t._v(" "),s("li",[t._v("unordered_map实现机理\nunordered_map内部实现了一个哈希表（也叫散列表），通过"),s("strong",[t._v("把关键码值映射到Hash表中一个位")]),t._v(" "),s("strong",[t._v("置来访问记录")]),t._v("，"),s("strong",[t._v("查找时间复杂度可达O（1）")]),t._v(" ，其中在海量数据处理中有着广泛应用。因此，元素\n的排列顺序是无序的。")])]),t._v(" "),s("h2",{attrs:{id:"_38、说说-vector-和-list-的区别-分别适用于什么场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_38、说说-vector-和-list-的区别-分别适用于什么场景"}},[t._v("#")]),t._v(" 38、说说 vector 和 list 的区别，分别适用于什么场景？")]),t._v(" "),s("p",[t._v("vector和list区别在于底层实现机理不同，因而特性和适用场景也有所不同。")]),t._v(" "),s("p",[s("strong",[t._v("vector：一维数组")]),t._v("\n特点：元素在内存"),s("strong",[t._v("连续存放")]),t._v("，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。\n优点：和数组类似开辟一段连续的空间，并且"),s("strong",[t._v("支持随机访问")]),t._v("，所以它的"),s("strong",[t._v("查找效率高其时间复杂度O(1)")]),t._v(" 。\n缺点：由于开辟一段连续的空间，所以"),s("strong",[t._v("插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n）")]),t._v(" ，另外当空间不足时还需要进行扩容。")]),t._v(" "),s("p",[s("strong",[t._v("list：双向链表")]),t._v("\n特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是"),s("strong",[t._v("不连续的")]),t._v("，通过指针\n来进行数据的访问。\n优点：底层实现是循环双链表，当对"),s("strong",[t._v("大量数据进行插入删除时，其时间复杂度O(1)")]),t._v(" 。\n缺点：底层没有连续的空间，只能通过指针来访问，所以"),s("strong",[t._v("查找数据需要遍历其时间复杂度O（n）")]),t._v(" ，\n"),s("strong",[t._v("没有提供[]操作符的重载")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("应用场景")]),t._v("\nvector拥有一段连续的内存空间，因此支持随机访问，"),s("strong",[t._v("如果需要高效的随即访问，而不在乎插入和删")]),t._v(" "),s("strong",[t._v("除的效率，使用vector")]),t._v("。\nlist拥有一段不连续的内存空间，如"),s("strong",[t._v("果需要高效的插入和删除，而不关心随机访问，则应使用list")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"_41、简述-vector-的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_41、简述-vector-的实现原理"}},[t._v("#")]),t._v(" 41、简述 vector 的实现原理")]),t._v(" "),s("p",[t._v("vector底层实现原理为"),s("strong",[t._v("一维数组")]),t._v("（元素在空间连续存放）。")]),t._v(" "),s("ol",[s("li",[t._v("新增元素\nVector通过一个连续的数组存放元素，如果"),s("strong",[t._v("集合已满")]),t._v("，在新增数据的时候，就要"),s("strong",[t._v("分配一块更大")]),t._v(" "),s("strong",[t._v("的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素")]),t._v("。插入新的数据分在最后插\n入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过"),s("strong",[t._v("迭代器与第一个元")]),t._v(" "),s("strong",[t._v("素的距离知道要插入的位置，即int index=iter-begin()")]),t._v(" 。这个元素后面的所有元素都向后移动一个\n位置，在空出来的位置上存入新增的元素。K")])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//新增元素 ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("const_iterator iter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("iter"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("size_"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("capacity_"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" capa"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("calculateCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("newCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("capa"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("memmove")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n        buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        size_"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("删除元素\n删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素\nerase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index=iter-begin();"),s("strong",[t._v("这个位置后")]),t._v(" "),s("strong",[t._v("面的每个元素都向前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值")]),t._v("。")]),t._v(" "),s("p",[t._v("删除全部元素clear：只是循环调用了erase，"),s("strong",[t._v("所以删除全部元素的时候，不释放内存。内存是在")]),t._v(" "),s("strong",[t._v("析构函数中释放的")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//删除元素 ")]),t._v("\niterator "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("erase")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("const_iterator iter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("iter"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("size_ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" size_"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("memmove")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("index "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n        buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("size_"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("iterator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("iter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("迭代器iteraotr\n迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个\n集合都写了一个迭代器, "),s("strong",[t._v("迭代器其实是对一个指针的包装,实现一些常用的方法,如++,--,!=,==,*,->等,")]),t._v(" "),s("strong",[t._v("通过这些方法可以找到当前元素或是别的元素")]),t._v(". vector是STL集合中比较特殊的一个,"),s("strong",[t._v("因为vector中")]),t._v(" "),s("strong",[t._v("的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//迭代器的实现")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("_Category")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("_Ty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("_Diff")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ptrdiff_t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("_Pointer")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" \n_Ty "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("_Reference")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _Ty"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("iterator")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// base type for all iterator classes")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" _Category iterator_category"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" _Ty value_type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" _Diff difference_type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" _Diff distance_type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// retained")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" _Pointer pointer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" _Reference reference"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])])])]),t._v(" "),s("h2",{attrs:{id:"_43、简述-stl-中的-map-的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_43、简述-stl-中的-map-的实现原理"}},[t._v("#")]),t._v(" 43、简述 STL 中的 map 的实现原理")]),t._v(" "),s("p",[t._v("map是关联式容器，它们的底层容器都是"),s("strong",[t._v("红黑树")]),t._v("。map 的所有元素都是 pair，同时拥有实值\n（value）和键值（key）。"),s("strong",[t._v("pair 的第一元素被视为键值，第二元素被视为实值")]),t._v("。所有元素都会根据元素\n的"),s("strong",[t._v("键值自动被排序")]),t._v("。不允许键值重复。")]),t._v(" "),s("ol",[s("li",[t._v("map的特性如下\n（1）map以RBTree作为底层容器；\n（2）所有元素都是键+值存在；\n（3）不允许键重复；\n（4）所有元素是通过键进行自动排序的；\n（5）"),s("strong",[t._v("map的键是不能修改的，但是其键对应的值是可以修改的")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"_46、c-的-vector-和-list中-如果删除末尾的元素-其指针和迭代器如何变化-若删除的是中间的元素呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_46、c-的-vector-和-list中-如果删除末尾的元素-其指针和迭代器如何变化-若删除的是中间的元素呢"}},[t._v("#")]),t._v(" 46、C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("迭代器和指针之间的区别\n"),s("strong",[t._v("迭代器不是指针，是类模板，表现的像指针")]),t._v("。他只是"),s("strong",[t._v("模拟")]),t._v("了指针的一些"),s("strong",[t._v("功能")]),t._v("，"),s("strong",[t._v("重载")]),t._v("了指针的一\n些"),s("strong",[t._v("操作符")]),t._v("，--\x3e、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard Template\nLibrary）容器内全部或部分元素”的对象，"),s("strong",[t._v("本质是封装了原生指针")]),t._v("，是指针概念的一种提升，提供\n了比指针更高级的行为，相当于一种智能指针，他"),s("strong",[t._v("可以根据不同类型的数据结构来实现不同的")]),t._v(" "),s("strong",[t._v("++，--等操作")]),t._v("。\n"),s("strong",[t._v("迭代器返回的是对象引用而不是对象的值")]),t._v("，所以cout只能输出迭代器使用取值后的值而不能直\n接输出其自身。")])]),t._v(" "),s("li",[s("p",[t._v("vector和list特性\nvector特性 "),s("strong",[t._v("动态数组")]),t._v("。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增\n删元素具有较大的性能（大部分情况下是常数时间）。\nlist特性 "),s("strong",[t._v("双向链表")]),t._v("。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持\n随机存取。")])]),t._v(" "),s("li",[s("p",[t._v("vector增删元素\n对于vector而言，"),s("strong",[t._v("删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都")]),t._v(" "),s("strong",[t._v("往前移动一位，erase返回下一个有效的迭代器")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("list增删元素\n对于list而言，"),s("strong",[t._v("删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影")]),t._v(" "),s("strong",[t._v("响")]),t._v("。")])])]),t._v(" "),s("h2",{attrs:{id:"_49、请你来说一下-map-和-set-有什么区别-分别又是怎么实现的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_49、请你来说一下-map-和-set-有什么区别-分别又是怎么实现的"}},[t._v("#")]),t._v(" 49、请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？")]),t._v(" "),s("ol",[s("li",[t._v("set是一种关联式容器，其特性如下：\n（1）set以RBTree作为底层容器\n（2）所得元素的只有key没有value，value就是key\n（3）不允许出现键值重复\n（4）所有的元素都会被自动排序\n（5）不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的")]),t._v(" "),s("li",[t._v("map和set一样是关联式容器，其特性如下：\n（1）map以RBTree作为底层容器\n（2）所有元素都是键+值存在\n（3）不允许键重复\n（4）所有元素是通过键进行自动排序的\n（5）map的键是不能修改的，但是其键对应的值是可以修改的\n综上所述，map和set底层实现都是红黑树；map和set的区别在于map的值不作为键，键和值是\n分开的。")])]),t._v(" "),s("h2",{attrs:{id:"_52、stl-中-vector-与-list-具体是怎么实现的-常见操作的时间复杂度是多少"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_52、stl-中-vector-与-list-具体是怎么实现的-常见操作的时间复杂度是多少"}},[t._v("#")]),t._v(" 52、STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？")]),t._v(" "),s("p",[t._v("参考回答")]),t._v(" "),s("ol",[s("li",[t._v("vector  一维数组（元素在内存连续存放）\n"),s("strong",[t._v("是动态数组，在堆中分配内存，元素连续存放")]),t._v("，有保留内存，"),s("strong",[t._v("如果减少大小后，内存也不会释")]),t._v(" "),s("strong",[t._v("放；如果新增大小大于当前大小时才会重新分配内存")]),t._v("。\n扩容方式： a. 倍放开辟三倍的内存\nb. 旧的数据开辟到新的内存\nc. 释放旧的内存\nd. 指向新内存")]),t._v(" "),s("li",[t._v("list  双向链表（元素存放在堆中）\n"),s("strong",[t._v("元素存放在堆中")]),t._v("，每个元素都是放在一块内存中，它的内存空间可以是"),s("strong",[t._v("不连续的")]),t._v("，通过指针来\n进行数据的访问，这个特点，使得它"),s("strong",[t._v("的随机存取变得非常没有效率，因此它没有提供[ ]操作符的重")]),t._v(" "),s("strong",[t._v("载。但是由于链表的特点，它可以很有效的支持任意地方的删除和插入操作")]),t._v("。\n特点：a. 随机访问不方便\nb. 删除插入操作方便")]),t._v(" "),s("li",[t._v("常见时间复杂度\n（1）vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)；\n（2）list插入、查找、删除时间复杂度分别为：O(1)、O(n)、O(1)。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);