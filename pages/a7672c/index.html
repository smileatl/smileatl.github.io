<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>mynetlib题目 | SAL Repo</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/website_icon.png">
    <meta name="description" content="smileatl个人知识库，用于工作、学习、生活的总结。">
    <meta name="keywords" content="smileatl个人知识库，用于工作、学习、生活的总结。">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.27efc831.css" as="style"><link rel="preload" href="/assets/js/app.4813674f.js" as="script"><link rel="preload" href="/assets/js/3.cf27d530.js" as="script"><link rel="preload" href="/assets/js/189.45442618.js" as="script"><link rel="prefetch" href="/assets/js/10.57c72187.js"><link rel="prefetch" href="/assets/js/100.76551019.js"><link rel="prefetch" href="/assets/js/101.909b1f6a.js"><link rel="prefetch" href="/assets/js/102.b4df429c.js"><link rel="prefetch" href="/assets/js/103.36718b70.js"><link rel="prefetch" href="/assets/js/104.8247d5e5.js"><link rel="prefetch" href="/assets/js/105.ae996141.js"><link rel="prefetch" href="/assets/js/106.664e0ec8.js"><link rel="prefetch" href="/assets/js/107.34387111.js"><link rel="prefetch" href="/assets/js/108.24bd216e.js"><link rel="prefetch" href="/assets/js/109.0ce14ec5.js"><link rel="prefetch" href="/assets/js/11.a6b1ea70.js"><link rel="prefetch" href="/assets/js/110.225cb77d.js"><link rel="prefetch" href="/assets/js/111.987f1649.js"><link rel="prefetch" href="/assets/js/112.804919d1.js"><link rel="prefetch" href="/assets/js/113.61edc8e7.js"><link rel="prefetch" href="/assets/js/114.a2199a4f.js"><link rel="prefetch" href="/assets/js/115.919528ee.js"><link rel="prefetch" href="/assets/js/116.1e165300.js"><link rel="prefetch" href="/assets/js/117.b62cd913.js"><link rel="prefetch" href="/assets/js/118.157a5849.js"><link rel="prefetch" href="/assets/js/119.335bb0f4.js"><link rel="prefetch" href="/assets/js/12.f97190ac.js"><link rel="prefetch" href="/assets/js/120.8ca841a0.js"><link rel="prefetch" href="/assets/js/121.09ef443a.js"><link rel="prefetch" href="/assets/js/122.133de093.js"><link rel="prefetch" href="/assets/js/123.8b5fcdde.js"><link rel="prefetch" href="/assets/js/124.8aef67d0.js"><link rel="prefetch" href="/assets/js/125.07949d7c.js"><link rel="prefetch" href="/assets/js/126.6557ef27.js"><link rel="prefetch" href="/assets/js/127.e2c838f8.js"><link rel="prefetch" href="/assets/js/128.e876bdf8.js"><link rel="prefetch" href="/assets/js/129.0e7d15bb.js"><link rel="prefetch" href="/assets/js/13.ae62b090.js"><link rel="prefetch" href="/assets/js/130.8caf4288.js"><link rel="prefetch" href="/assets/js/131.d091a5f7.js"><link rel="prefetch" href="/assets/js/132.3af86ba2.js"><link rel="prefetch" href="/assets/js/133.9b473677.js"><link rel="prefetch" href="/assets/js/134.d09f520d.js"><link rel="prefetch" href="/assets/js/135.5094d6c6.js"><link rel="prefetch" href="/assets/js/136.f554265c.js"><link rel="prefetch" href="/assets/js/137.db8ad307.js"><link rel="prefetch" href="/assets/js/138.97a9f7dc.js"><link rel="prefetch" href="/assets/js/139.28a187da.js"><link rel="prefetch" href="/assets/js/14.7c89dfed.js"><link rel="prefetch" href="/assets/js/140.58f327a0.js"><link rel="prefetch" href="/assets/js/141.dac9c32e.js"><link rel="prefetch" href="/assets/js/142.15e4cd8a.js"><link rel="prefetch" href="/assets/js/143.29bcf51a.js"><link rel="prefetch" href="/assets/js/144.93e792a5.js"><link rel="prefetch" href="/assets/js/145.1e479d7f.js"><link rel="prefetch" href="/assets/js/146.fef6b20d.js"><link rel="prefetch" href="/assets/js/147.a8939180.js"><link rel="prefetch" href="/assets/js/148.73ab52d1.js"><link rel="prefetch" href="/assets/js/149.de7d77b9.js"><link rel="prefetch" href="/assets/js/15.4266d5a5.js"><link rel="prefetch" href="/assets/js/150.14cd4f5b.js"><link rel="prefetch" href="/assets/js/151.ae320b72.js"><link rel="prefetch" href="/assets/js/152.9f70308b.js"><link rel="prefetch" href="/assets/js/153.8bb08923.js"><link rel="prefetch" href="/assets/js/154.bef6a0fb.js"><link rel="prefetch" href="/assets/js/155.e0e21ff7.js"><link rel="prefetch" href="/assets/js/156.e212e95d.js"><link rel="prefetch" href="/assets/js/157.9af3323d.js"><link rel="prefetch" href="/assets/js/158.a6990b68.js"><link rel="prefetch" href="/assets/js/159.9921842e.js"><link rel="prefetch" href="/assets/js/16.4d11e9b4.js"><link rel="prefetch" href="/assets/js/160.cb690287.js"><link rel="prefetch" href="/assets/js/161.10ec68a7.js"><link rel="prefetch" href="/assets/js/162.5e2e8da5.js"><link rel="prefetch" href="/assets/js/163.7ad3dc89.js"><link rel="prefetch" href="/assets/js/164.0677e91f.js"><link rel="prefetch" href="/assets/js/165.eabba413.js"><link rel="prefetch" href="/assets/js/166.de181132.js"><link rel="prefetch" href="/assets/js/167.eb1f2c20.js"><link rel="prefetch" href="/assets/js/168.33870baa.js"><link rel="prefetch" href="/assets/js/169.0eb4e75c.js"><link rel="prefetch" href="/assets/js/17.2f17b760.js"><link rel="prefetch" href="/assets/js/170.6a8f837b.js"><link rel="prefetch" href="/assets/js/171.33c99890.js"><link rel="prefetch" href="/assets/js/172.e2ac6d6c.js"><link rel="prefetch" href="/assets/js/173.f37baa2e.js"><link rel="prefetch" href="/assets/js/174.3f1765d5.js"><link rel="prefetch" href="/assets/js/175.ee3e624a.js"><link rel="prefetch" href="/assets/js/176.b7c3d2ba.js"><link rel="prefetch" href="/assets/js/177.538dbd98.js"><link rel="prefetch" href="/assets/js/178.688b2ab3.js"><link rel="prefetch" href="/assets/js/179.7605eb3a.js"><link rel="prefetch" href="/assets/js/18.46454e6b.js"><link rel="prefetch" href="/assets/js/180.f734c479.js"><link rel="prefetch" href="/assets/js/181.f009bfc4.js"><link rel="prefetch" href="/assets/js/182.51a8e6fc.js"><link rel="prefetch" href="/assets/js/183.0f688ed3.js"><link rel="prefetch" href="/assets/js/184.e20ab6d5.js"><link rel="prefetch" href="/assets/js/185.336035f1.js"><link rel="prefetch" href="/assets/js/186.e7f18b72.js"><link rel="prefetch" href="/assets/js/187.20bae185.js"><link rel="prefetch" href="/assets/js/188.4d746641.js"><link rel="prefetch" href="/assets/js/19.07e2632b.js"><link rel="prefetch" href="/assets/js/190.6f6c4889.js"><link rel="prefetch" href="/assets/js/191.b73399a8.js"><link rel="prefetch" href="/assets/js/192.657f63ce.js"><link rel="prefetch" href="/assets/js/193.348754cf.js"><link rel="prefetch" href="/assets/js/194.7ea4e875.js"><link rel="prefetch" href="/assets/js/195.011c9aaa.js"><link rel="prefetch" href="/assets/js/196.30ca323d.js"><link rel="prefetch" href="/assets/js/197.b404290d.js"><link rel="prefetch" href="/assets/js/198.19eeb699.js"><link rel="prefetch" href="/assets/js/199.578524cd.js"><link rel="prefetch" href="/assets/js/20.e8632e9e.js"><link rel="prefetch" href="/assets/js/200.2483c16f.js"><link rel="prefetch" href="/assets/js/201.80be911a.js"><link rel="prefetch" href="/assets/js/202.6292d716.js"><link rel="prefetch" href="/assets/js/203.0423f992.js"><link rel="prefetch" href="/assets/js/204.220cf5d5.js"><link rel="prefetch" href="/assets/js/205.cf88ea69.js"><link rel="prefetch" href="/assets/js/206.7837a407.js"><link rel="prefetch" href="/assets/js/207.15eb7f61.js"><link rel="prefetch" href="/assets/js/208.c92b54ae.js"><link rel="prefetch" href="/assets/js/209.d6858997.js"><link rel="prefetch" href="/assets/js/21.9d97eca0.js"><link rel="prefetch" href="/assets/js/210.3a916b1e.js"><link rel="prefetch" href="/assets/js/211.99ca202d.js"><link rel="prefetch" href="/assets/js/212.18a13454.js"><link rel="prefetch" href="/assets/js/213.7eb5f7fd.js"><link rel="prefetch" href="/assets/js/214.178507b3.js"><link rel="prefetch" href="/assets/js/215.e9eac7bd.js"><link rel="prefetch" href="/assets/js/216.bdd656c6.js"><link rel="prefetch" href="/assets/js/217.487e6997.js"><link rel="prefetch" href="/assets/js/218.eb54add1.js"><link rel="prefetch" href="/assets/js/219.43da1c82.js"><link rel="prefetch" href="/assets/js/22.ed6e719f.js"><link rel="prefetch" href="/assets/js/220.757359d6.js"><link rel="prefetch" href="/assets/js/221.d58f156a.js"><link rel="prefetch" href="/assets/js/222.99dc1661.js"><link rel="prefetch" href="/assets/js/223.22a61d2b.js"><link rel="prefetch" href="/assets/js/224.514138b9.js"><link rel="prefetch" href="/assets/js/225.fc56b049.js"><link rel="prefetch" href="/assets/js/226.59d64fed.js"><link rel="prefetch" href="/assets/js/227.8841cf23.js"><link rel="prefetch" href="/assets/js/228.f37358c2.js"><link rel="prefetch" href="/assets/js/229.97cb9c4e.js"><link rel="prefetch" href="/assets/js/23.5eccc486.js"><link rel="prefetch" href="/assets/js/230.a16ada6a.js"><link rel="prefetch" href="/assets/js/231.5f761bf3.js"><link rel="prefetch" href="/assets/js/232.76d78495.js"><link rel="prefetch" href="/assets/js/233.162bba41.js"><link rel="prefetch" href="/assets/js/234.a845dfca.js"><link rel="prefetch" href="/assets/js/235.169ff72d.js"><link rel="prefetch" href="/assets/js/236.c50d9ecf.js"><link rel="prefetch" href="/assets/js/237.594eecee.js"><link rel="prefetch" href="/assets/js/238.b599dae8.js"><link rel="prefetch" href="/assets/js/239.7be81ebe.js"><link rel="prefetch" href="/assets/js/24.c81753d3.js"><link rel="prefetch" href="/assets/js/240.b9f18f9e.js"><link rel="prefetch" href="/assets/js/241.77d17f60.js"><link rel="prefetch" href="/assets/js/242.0894cddd.js"><link rel="prefetch" href="/assets/js/243.4c71e0af.js"><link rel="prefetch" href="/assets/js/244.47579b9c.js"><link rel="prefetch" href="/assets/js/245.29344e11.js"><link rel="prefetch" href="/assets/js/246.410a1027.js"><link rel="prefetch" href="/assets/js/247.b22fa817.js"><link rel="prefetch" href="/assets/js/25.f3141c92.js"><link rel="prefetch" href="/assets/js/26.573fd0de.js"><link rel="prefetch" href="/assets/js/27.9a72220d.js"><link rel="prefetch" href="/assets/js/28.e161668a.js"><link rel="prefetch" href="/assets/js/29.6d2ef014.js"><link rel="prefetch" href="/assets/js/30.0dd2ba52.js"><link rel="prefetch" href="/assets/js/31.e8c4ee1d.js"><link rel="prefetch" href="/assets/js/32.c57cfa4e.js"><link rel="prefetch" href="/assets/js/33.7c1ec4ff.js"><link rel="prefetch" href="/assets/js/34.110d90ae.js"><link rel="prefetch" href="/assets/js/35.c5fbf1bd.js"><link rel="prefetch" href="/assets/js/36.58d307d9.js"><link rel="prefetch" href="/assets/js/37.6e68d82d.js"><link rel="prefetch" href="/assets/js/38.0a2bfb96.js"><link rel="prefetch" href="/assets/js/39.79a25586.js"><link rel="prefetch" href="/assets/js/4.10092391.js"><link rel="prefetch" href="/assets/js/40.1b3fb2c7.js"><link rel="prefetch" href="/assets/js/41.2cd990a4.js"><link rel="prefetch" href="/assets/js/42.3803a3ba.js"><link rel="prefetch" href="/assets/js/43.56cde0b8.js"><link rel="prefetch" href="/assets/js/44.98f12e35.js"><link rel="prefetch" href="/assets/js/45.bbed8377.js"><link rel="prefetch" href="/assets/js/46.80af516b.js"><link rel="prefetch" href="/assets/js/47.bfe18f20.js"><link rel="prefetch" href="/assets/js/48.e4bead99.js"><link rel="prefetch" href="/assets/js/49.da1a7c67.js"><link rel="prefetch" href="/assets/js/5.0b5a1289.js"><link rel="prefetch" href="/assets/js/50.b6011d95.js"><link rel="prefetch" href="/assets/js/51.81adcdd5.js"><link rel="prefetch" href="/assets/js/52.b650e175.js"><link rel="prefetch" href="/assets/js/53.22c44460.js"><link rel="prefetch" href="/assets/js/54.3c9964c8.js"><link rel="prefetch" href="/assets/js/55.80bec639.js"><link rel="prefetch" href="/assets/js/56.2066f85f.js"><link rel="prefetch" href="/assets/js/57.ab6dbc19.js"><link rel="prefetch" href="/assets/js/58.6236e7f0.js"><link rel="prefetch" href="/assets/js/59.618e25d3.js"><link rel="prefetch" href="/assets/js/6.a1e90b5b.js"><link rel="prefetch" href="/assets/js/60.3deac196.js"><link rel="prefetch" href="/assets/js/61.890283e9.js"><link rel="prefetch" href="/assets/js/62.ffe465e9.js"><link rel="prefetch" href="/assets/js/63.cc9a42cc.js"><link rel="prefetch" href="/assets/js/64.c66e6c4f.js"><link rel="prefetch" href="/assets/js/65.95e3ddfd.js"><link rel="prefetch" href="/assets/js/66.256b023f.js"><link rel="prefetch" href="/assets/js/67.436df8a0.js"><link rel="prefetch" href="/assets/js/68.d532ffa8.js"><link rel="prefetch" href="/assets/js/69.963c3596.js"><link rel="prefetch" href="/assets/js/7.74944cf6.js"><link rel="prefetch" href="/assets/js/70.6dfd1704.js"><link rel="prefetch" href="/assets/js/71.53af90e0.js"><link rel="prefetch" href="/assets/js/72.580797e8.js"><link rel="prefetch" href="/assets/js/73.5c14d158.js"><link rel="prefetch" href="/assets/js/74.70cf381f.js"><link rel="prefetch" href="/assets/js/75.01dbab82.js"><link rel="prefetch" href="/assets/js/76.18b48db2.js"><link rel="prefetch" href="/assets/js/77.0fa8965d.js"><link rel="prefetch" href="/assets/js/78.bede6ca6.js"><link rel="prefetch" href="/assets/js/79.1c7c8167.js"><link rel="prefetch" href="/assets/js/8.fbc0181a.js"><link rel="prefetch" href="/assets/js/80.688d4c3b.js"><link rel="prefetch" href="/assets/js/81.4eaaee90.js"><link rel="prefetch" href="/assets/js/82.53bf5bf4.js"><link rel="prefetch" href="/assets/js/83.53cdee38.js"><link rel="prefetch" href="/assets/js/84.848d09d8.js"><link rel="prefetch" href="/assets/js/85.4ef416fa.js"><link rel="prefetch" href="/assets/js/86.559b9784.js"><link rel="prefetch" href="/assets/js/87.1317f521.js"><link rel="prefetch" href="/assets/js/88.61e1f1fa.js"><link rel="prefetch" href="/assets/js/89.c37979bc.js"><link rel="prefetch" href="/assets/js/9.acdf956e.js"><link rel="prefetch" href="/assets/js/90.329e7956.js"><link rel="prefetch" href="/assets/js/91.e9246182.js"><link rel="prefetch" href="/assets/js/92.41e1ecaf.js"><link rel="prefetch" href="/assets/js/93.6cbe0205.js"><link rel="prefetch" href="/assets/js/94.922231b5.js"><link rel="prefetch" href="/assets/js/95.23cfae7c.js"><link rel="prefetch" href="/assets/js/96.790a39b9.js"><link rel="prefetch" href="/assets/js/97.8ce2cb69.js"><link rel="prefetch" href="/assets/js/98.f016d83e.js"><link rel="prefetch" href="/assets/js/99.b1d81562.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.96cada6e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.27efc831.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/website_icon.png" alt="SAL Repo" class="logo"> <span class="site-name can-hide">SAL Repo</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工作" class="dropdown-title"><a href="/work/" class="link-title">工作</a> <span class="title" style="display:none;">工作</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>编程语言</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/C/" class="nav-link">C</a></li><li class="dropdown-subitem"><a href="/work/C++/" class="nav-link">C++</a></li><li class="dropdown-subitem"><a href="/work/Script_Language/" class="nav-link">Script_Language</a></li></ul></li><li class="dropdown-item"><h4>计算机知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Linux/" class="nav-link">Linux</a></li><li class="dropdown-subitem"><a href="/work/dataStruct/" class="nav-link">数据机构与算法</a></li><li class="dropdown-subitem"><a href="/work/OS/" class="nav-link">操作系统</a></li><li class="dropdown-subitem"><a href="/work/network/" class="nav-link">计算机网络</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/MySQL/" class="nav-link">MySQL</a></li><li class="dropdown-subitem"><a href="/work/Redis/" class="nav-link">Redis</a></li></ul></li><li class="dropdown-item"><h4>工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Git/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/work/VM/" class="nav-link">虚拟机</a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/leetcode/" class="nav-link">刷题</a></li><li class="dropdown-subitem"><a href="/work/bg/" class="nav-link">interview</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/project/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/mynetlib/" class="nav-link">mynetlib</a></li><li class="dropdown-item"><!----> <a href="/project/mymprpc/" class="nav-link">mymprpc</a></li><li class="dropdown-item"><!----> <a href="/project/mytinystl/" class="nav-link">mytinystl</a></li><li class="dropdown-item"><!----> <a href="/project/DML/" class="nav-link">DML</a></li><li class="dropdown-item"><!----> <a href="/project/FL/" class="nav-link">FL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学习" class="dropdown-title"><a href="/study/" class="link-title">学习</a> <span class="title" style="display:none;">学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>研究生</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/publications/" class="nav-link">publications</a></li><li class="dropdown-subitem"><a href="/study/ML/" class="nav-link">机器学习</a></li></ul></li><li class="dropdown-item"><h4>阅读</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/read/" class="nav-link">个人摘抄</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="生活" class="dropdown-title"><a href="/life/" class="link-title">生活</a> <span class="title" style="display:none;">生活</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/71024e/" class="nav-link">生活</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/collection/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>总览</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/collection/favorites/" class="nav-link">个人收藏夹</a></li><li class="dropdown-subitem"><a href="/collection/download/" class="nav-link">资源下载</a></li></ul></li><li class="dropdown-item"><h4>快速链接</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://sci-hub.wf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SCI-HUB
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/collection/favorites/#文件转换、解密工具" class="nav-link">文件转换、解密工具</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>索引</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-subitem"><a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-subitem"><a href="/archives/" class="nav-link">归档</a></li></ul></li><li class="dropdown-item"><h4>友链</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/friends/" class="nav-link">友情链接</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <a href="https://github.com/smileatl/smileatlRepository_source" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatar.jpg"> <div class="blogger-info"><h3>smileatl</h3> <span>smileatl, Songlei Lin</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工作" class="dropdown-title"><a href="/work/" class="link-title">工作</a> <span class="title" style="display:none;">工作</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>编程语言</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/C/" class="nav-link">C</a></li><li class="dropdown-subitem"><a href="/work/C++/" class="nav-link">C++</a></li><li class="dropdown-subitem"><a href="/work/Script_Language/" class="nav-link">Script_Language</a></li></ul></li><li class="dropdown-item"><h4>计算机知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Linux/" class="nav-link">Linux</a></li><li class="dropdown-subitem"><a href="/work/dataStruct/" class="nav-link">数据机构与算法</a></li><li class="dropdown-subitem"><a href="/work/OS/" class="nav-link">操作系统</a></li><li class="dropdown-subitem"><a href="/work/network/" class="nav-link">计算机网络</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/MySQL/" class="nav-link">MySQL</a></li><li class="dropdown-subitem"><a href="/work/Redis/" class="nav-link">Redis</a></li></ul></li><li class="dropdown-item"><h4>工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Git/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/work/VM/" class="nav-link">虚拟机</a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/leetcode/" class="nav-link">刷题</a></li><li class="dropdown-subitem"><a href="/work/bg/" class="nav-link">interview</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/project/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/mynetlib/" class="nav-link">mynetlib</a></li><li class="dropdown-item"><!----> <a href="/project/mymprpc/" class="nav-link">mymprpc</a></li><li class="dropdown-item"><!----> <a href="/project/mytinystl/" class="nav-link">mytinystl</a></li><li class="dropdown-item"><!----> <a href="/project/DML/" class="nav-link">DML</a></li><li class="dropdown-item"><!----> <a href="/project/FL/" class="nav-link">FL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学习" class="dropdown-title"><a href="/study/" class="link-title">学习</a> <span class="title" style="display:none;">学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>研究生</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/publications/" class="nav-link">publications</a></li><li class="dropdown-subitem"><a href="/study/ML/" class="nav-link">机器学习</a></li></ul></li><li class="dropdown-item"><h4>阅读</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/read/" class="nav-link">个人摘抄</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="生活" class="dropdown-title"><a href="/life/" class="link-title">生活</a> <span class="title" style="display:none;">生活</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/71024e/" class="nav-link">生活</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/collection/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>总览</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/collection/favorites/" class="nav-link">个人收藏夹</a></li><li class="dropdown-subitem"><a href="/collection/download/" class="nav-link">资源下载</a></li></ul></li><li class="dropdown-item"><h4>快速链接</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://sci-hub.wf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SCI-HUB
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/collection/favorites/#文件转换、解密工具" class="nav-link">文件转换、解密工具</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>索引</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-subitem"><a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-subitem"><a href="/archives/" class="nav-link">归档</a></li></ul></li><li class="dropdown-item"><h4>友链</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/friends/" class="nav-link">友情链接</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <a href="https://github.com/smileatl/smileatlRepository_source" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>mynetlib</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/94ba88/" class="sidebar-link">README</a></li><li><a href="/pages/d2e3a8/" class="sidebar-link">Channel类</a></li><li><a href="/pages/064d23/" class="sidebar-link">Poller和EPollPoller类</a></li><li><a href="/pages/7a822f/" class="sidebar-link">获取线程tid方法</a></li><li><a href="/pages/adc7a8/" class="sidebar-link">EventLoop类</a></li><li><a href="/pages/f81573/" class="sidebar-link">Thread相关类</a></li><li><a href="/pages/fa1244/" class="sidebar-link">Socket类和Acceptor类</a></li><li><a href="/pages/14992c/" class="sidebar-link">缓冲区Buffer类</a></li><li><a href="/pages/e8fcfc/" class="sidebar-link">TcpServer类</a></li><li><a href="/pages/1cc317/" class="sidebar-link">TcpConnection类</a></li><li><a href="/pages/8bce7b/" class="sidebar-link">定时器相关类</a></li><li><a href="/pages/b39f8b/" class="sidebar-link">MySQL数据库连接池</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>面经</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a7672c/" aria-current="page" class="active sidebar-link">mynetlib题目</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_1、介绍一下你的项目" class="sidebar-link">1、介绍一下你的项目</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_2、个人收获" class="sidebar-link">2、个人收获</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_2、你从这个项目里学到了哪些c-的特性" class="sidebar-link">2、你从这个项目里学到了哪些C++的特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#智能指针" class="sidebar-link">智能指针</a></li><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#原子变量" class="sidebar-link">原子变量</a></li><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#bind函数" class="sidebar-link">bind函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/a7672c/#针对第2种情况" class="sidebar-link">针对第2种情况</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_3、应用技术与主要工作" class="sidebar-link">3、应用技术与主要工作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#主要工作" class="sidebar-link">主要工作</a></li><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#遇到问题" class="sidebar-link">遇到问题</a></li><li class="sidebar-sub-header level4"><a href="/pages/a7672c/#原子变量未初始化" class="sidebar-link">原子变量未初始化</a></li><li class="sidebar-sub-header level4"><a href="/pages/a7672c/#accept问题" class="sidebar-link">accept问题</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_3、项目核心逻辑介绍" class="sidebar-link">3、项目核心逻辑介绍</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_4、muduo库-connfd-采用触发模式是lt-这样优点是" class="sidebar-link">4、muduo库 connfd 采用触发模式是LT，这样优点是</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_4、定时器是怎么实现的-还有什么实现方式" class="sidebar-link">4、定时器是怎么实现的？还有什么实现方式？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#muduo的定时器是如何设计的" class="sidebar-link">muduo的定时器是如何设计的？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_7、网络库的io模型是怎么样的-为什么这个io模型是高性能的" class="sidebar-link">7、网络库的io模型是怎么样的，为什么这个io模型是高性能的？</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_10、muduo的主线程accept的fd如何分发给其他线程" class="sidebar-link">10、muduo的主线程accept的fd如何分发给其他线程？</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_13、muduo如何限制连接的数量" class="sidebar-link">13、muduo如何限制连接的数量？</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_16、muduo如何设计buffer" class="sidebar-link">16、muduo如何设计buffer？</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_21、如何安全的关闭tcp连接-能不能直接close-如何直接close会发生什么" class="sidebar-link">21、如何安全的关闭tcp连接，能不能直接close，如何直接close会发生什么？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#什么是优雅关闭连接-就是read-到0-要透明的传递这个行为而不是直接暴力close" class="sidebar-link">什么是优雅关闭连接？(就是read()到0，要透明的传递这个行为而不是直接暴力close())</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_22、muduo是如何-线程安全的对-对象的生命周期进行管理" class="sidebar-link">22、muduo是如何 线程安全的对 对象的生命周期进行管理？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#chatgpt" class="sidebar-link">chatgpt</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_23、eventfd是什么-有什么好处" class="sidebar-link">23、eventfd是什么？有什么好处？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#_24、双缓冲区异步日志是什么-为什么要这样做-对这个日志系统有没有进行压力测试" class="sidebar-link">24、双缓冲区异步日志是什么？为什么要这样做？对这个日志系统有没有进行压力测试？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_25、epoll的边沿触发和水平触发有什么区别-epoll的源码并不长-从源码的角度回答比较好" class="sidebar-link">25、epoll的边沿触发和水平触发有什么区别？(epoll的源码并不长，从源码的角度回答比较好)</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_26、epoll为什么高效-相比select和poll" class="sidebar-link">26、epoll为什么高效，相比select和poll</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_27、假如服务器要升级-又不想让用户感觉到服务器升级了-该怎么做-其实就是不间断的提供服务-参考nginx的平滑升级" class="sidebar-link">27、假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_32、怎么检查内存泄漏的" class="sidebar-link">32、怎么检查内存泄漏的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#_34、用到了哪些智能指针和raii机制-几种锁的区别是什么" class="sidebar-link">34、用到了哪些智能指针和RAII机制，几种锁的区别是什么</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_27-任务队列是怎么实现的-除了加锁还有什么方式" class="sidebar-link">27.任务队列是怎么实现的，除了加锁还有什么方式？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#eventloop重要成员变量" class="sidebar-link">EventLoop重要成员变量</a></li><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#eventloop-是如何保证线程安全的" class="sidebar-link">EventLoop 是如何保证线程安全的</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_28-如何解决死锁" class="sidebar-link">28.如何解决死锁？</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_29-怎么进行压测的" class="sidebar-link">29.怎么进行压测的？</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_30-为什么要用非阻塞io" class="sidebar-link">30.为什么要用非阻塞io？</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_36、日志宏定义" class="sidebar-link">36、日志宏定义</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_38、shared-from-this" class="sidebar-link">38、sharedfromthis()</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_40、std-search" class="sidebar-link">40、std::search</a></li><li class="sidebar-sub-header level2"><a href="/pages/a7672c/#_42、findcrlf一直为null-针对数独的例子" class="sidebar-link">42、findcrlf一直为null，针对数独的例子</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#问题" class="sidebar-link">问题</a></li><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#原因1" class="sidebar-link">原因1</a></li><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#原因2" class="sidebar-link">原因2</a></li><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#原因3" class="sidebar-link">原因3</a></li><li class="sidebar-sub-header level3"><a href="/pages/a7672c/#最后解决办法" class="sidebar-link">最后解决办法</a></li></ul></li></ul></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>mymprpc</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>mytinystl</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>DML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>FL</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/project/#项目" data-v-06225672>项目</a></li><li data-v-06225672><a href="/project/#mynetlib" data-v-06225672>mynetlib</a></li><li data-v-06225672><a href="/project/#面经" data-v-06225672>面经</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/smileatl" target="_blank" title="作者" class="beLink" data-v-06225672>smileatl</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-12-04</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">mynetlib题目<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="_1、介绍一下你的项目"><a href="#_1、介绍一下你的项目" class="header-anchor">#</a> 1、介绍一下你的项目</h2> <p>本项目是一个基于多Reactor 模型的多线程网络库。项目的主体是参考muduo网络库实现，使用 C++ 的标准特性来进行了重构，去除掉了网络库对 boost 的依赖。</p> <p>这个网络库采用一个事件循环一个线程的线程模型，并采用EPOLL和非阻塞IO实现了一个多Reactor模型。</p> <p>在muduo中，每一个线程都可以看作是一个Reactor，主线程（主Reactor）只负责监听接收新连接，并将接收的连接对应的fd分发到子Reactor中，子线程（子Reactor）就负责处理主线程分发给自己的fd上的事件，比如fd上发生的可读、可写、错误等事件，另外从fd上读取数据后，要进行的业务逻辑也是由子线程负责的。基本框架如下图所示：</p> <p><img src="/assets/1694258828440.png" alt="1694258828440"></p> <p>项目已经实现了Channel模块、Poller模块、事件循环模块、缓冲区、异步日志、定时器、数据库连接池。</p> <p>内部实现了一个小型的 HTTP 服务器，可支持 GET 请求和静态资源的访问，且附有异步日志监控服务端情况。还有sudoku服务器、echo服务器。</p> <h2 id="_2、个人收获"><a href="#_2、个人收获" class="header-anchor">#</a> 2、个人收获</h2> <p>能更加熟练地运用<strong>C++11新特性</strong>，如bind、智能指针和原子变量等语法，同时我对于<strong>one loop per thread + nonblocking IO</strong>网络模型的理解得到了提升。</p> <p>此外，在编码中对类的封装和设计的实践，让我对设计模式、<strong>基于事件驱动的编程方法以及事件回调</strong>有了更具体的认识。</p> <h2 id="_2、你从这个项目里学到了哪些c-的特性"><a href="#_2、你从这个项目里学到了哪些c-的特性" class="header-anchor">#</a> 2、你从这个项目里学到了哪些C++的特性</h2> <h3 id="智能指针"><a href="#智能指针" class="header-anchor">#</a> 智能指针</h3> <h3 id="原子变量"><a href="#原子变量" class="header-anchor">#</a> 原子变量</h3> <p><code>std::atomic_int</code> 是 C++ 标准库中的一个原子整型类型，用于<strong>支持原子操作。它提供了一种线程安全的方式来对整数进行操作，确保多个线程可以同时访问和修改这个整数值而不会发生数据竞争</strong>。</p> <p>原子操作是不可中断的，即使在多线程环境下也能保证操作的完整性。<code>std::atomic_int</code> 类型通过<strong>使用硬件原子指令或锁机制来实现原子性</strong>，以确保所有操作都是原子的，无论是否存在其他线程同时访问该变量。</p> <p>以下是 <code>std::atomic_int</code> 的一些重要特性和使用方法：</p> <ul><li>支持原子操作：<code>std::atomic_int</code> 支持一系列的原子操作，如加载（load）、存储（store）、交换（exchange）、比较交换（compare_exchange_weak、compare_exchange_strong）等。这些操作可以确保并发访问时的正确性。</li> <li>线程安全：<code>std::atomic_int</code> 提供了<strong>线程安全的操作，无需额外的同步手段（例如互斥锁）。多个线程可以同时读取和写入 <code>std::atomic_int</code> 对象，而不会导致数据竞争</strong>。</li> <li>原子性：<code>std::atomic_int</code> 操作的结果要么完全被一个线程看到，要么完全不被任何线程看到。这意味着所有操作都是原子的，不会发生部分修改或数据错误。</li> <li>内存顺序（Memory Order）：<code>std::atomic_int</code> 操作提供了内存顺序的控制，以确保对多个原子操作之间的顺序进行指定。可以使用不同的内存顺序参数来平衡性能和一致性需求。</li></ul> <p>下面是一个简单的示例，展示如何使用 <code>std::atomic_int</code>：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic_int <span class="token function">atomicValue</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    atomicValue<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 存储新值</span>

    <span class="token keyword">int</span> loadedValue <span class="token operator">=</span> atomicValue<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 加载当前值</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Loaded value: &quot;</span> <span class="token operator">&lt;&lt;</span> loadedValue <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">bool</span> exchanged <span class="token operator">=</span> atomicValue<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>exchanged<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Value exchanged successfully.&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Failed to exchange value.&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在上述示例中，我们首先使用 <code>store</code> 操作将值存储为 42，然后使用 <code>load</code> 操作加载该值并打印出来。接下来，我们使用 <code>compare_exchange_weak</code> 尝试将值从 42 更改为 13，并根据返回值确定是否成功交换。</p> <h3 id="bind函数"><a href="#bind函数" class="header-anchor">#</a> bind函数</h3> <p><code>std::bind</code>函数是C++11标准库中的一个函数模板，用于<strong>绑定参数到函数对象，并返回一个新的可调用对象</strong>。它可以<strong>实现对函数的参数进行预先绑定、重排和占位，以实现更灵活的函数调用</strong>。</p> <p><code>std::bind</code>函数的基本语法为：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>Function<span class="token punctuation">,</span> Arg1<span class="token punctuation">,</span> Arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>其中，<code>Function</code>表示要绑定的函数或成员函数指针，<code>Arg1</code>、<code>Arg2</code>等表示要绑定到函数的参数</strong>。</p> <p>以下是<code>std::bind</code>函数的一些重要特性和使用方法：</p> <ol><li>参数绑定：可以<strong>通过<code>_1</code>、<code>_2</code>、<code>_3</code>等占位符来指定参数的位置</strong>。当实际调用绑定函数时，这些占位符会被具体的参数值替换。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>Function<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="2"><li><strong>成员函数绑定：可以将成员函数与对象进行绑定，使得在调用时自动传递对应的对象指针作为第一个参数</strong>。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Class<span class="token double-colon punctuation">::</span>MemberFunction<span class="token punctuation">,</span> <span class="token operator">&amp;</span>object<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="3"><li>函数适配器：可以使用<code>std::bind</code>函数来创建函数适配器，改变函数的行为。比如创建一个只接受一个参数的函数对象。
以下代码创建了一个新的函数对象，该对象只接受一个参数。这个函数对象<strong>将在调用时用绑定的值<code>value</code>替换掉原本的<code>Function</code>中的第一个参数，并将调用时传入的第一个参数替换占位符<code>_1</code>。</strong></li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>Function<span class="token punctuation">,</span> value<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="4"><li>绑定到函数对象：可以将<code>bind</code>的结果绑定到另一个函数对象，从而实现更复杂的组合操作。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> boundFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>Function<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>总之，<code>std::bind</code>函数是C++11中引入的一个强大工具，可以在编程中实现更灵活的函数调用方式。它可以帮助简化代码，提高开发效率，并且与其他C++标准库中的函数对象（如<code>std::function</code>）结合使用，可以实现更加可复用和通用的代码。</p> <h4 id="针对第2种情况"><a href="#针对第2种情况" class="header-anchor">#</a> 针对第2种情况</h4> <p>当需要在函数适配器中传递<code>this</code>指针时，可以使用成员函数的绑定。通过将成员函数与对象的指针绑定，可以创建一个函数对象，该函数对象在调用时会自动传递正确的对象指针作为第一个参数。</p> <p>以下是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Message: &quot;</span> <span class="token operator">&lt;&lt;</span> message <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyClass obj<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> boundFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>MyClass<span class="token double-colon punctuation">::</span>printMessage<span class="token punctuation">,</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">boundFunc</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用boundFunc(&quot;Hello&quot;)，相当于调用obj.printMessage(&quot;Hello&quot;)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 输出: Message: Hello</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在上面的示例中，我们定义了一个名为<code>MyClass</code>的类，并在其中定义了一个成员函数<code>printMessage</code>。然后，在<code>main</code>函数中创建了一个<code>MyClass</code>的对象<code>obj</code>。接下来，使用<code>std::bind</code>将<code>printMessage</code>函数与对象指针<code>&amp;obj</code>进行绑定，并将占位符<code>std::placeholders::_1</code>用于表示将来调用时传入的参数。</p> <p>通过这种绑定，我们创建了一个函数对象<code>boundFunc</code>，它在调用时会自动将正确的对象指针作为第一个参数，并传递给<code>printMessage</code>函数。最后，我们通过调用<code>boundFunc(&quot;Hello&quot;)</code>来间接调用了<code>obj.printMessage(&quot;Hello&quot;)</code>，输出了&quot;Message: Hello&quot;。</p> <p>这样，我们就可以使用<code>std::bind</code>在函数适配器中传递<code>this</code>指针，实现对成员函数的适配，并调用正确的对象。</p> <h2 id="_3、应用技术与主要工作"><a href="#_3、应用技术与主要工作" class="header-anchor">#</a> 3、应用技术与主要工作</h2> <h3 id="主要工作"><a href="#主要工作" class="header-anchor">#</a> 主要工作</h3> <ul><li>采用 <strong>multi-Reactors</strong> 和 <strong>one loop per thread + nonblocking IO</strong>的网络模型实现IO处理和业务处理的分离；</li> <li>对C++11线程类进行封装实现 <strong>one loop per thread</strong>的一对一绑定关系；</li> <li>使用C++11特性<strong>取代boost库在muduo中的使用，如shared_ptr、bind、atomic</strong>等</li> <li><strong>使用<code>eventfd()</code>来实现 <code>mainLoop</code> 对 <code>subLoop</code>的线程间通知操作，相比于使用任务队列需要加锁降低了开销</strong></li></ul> <h3 id="遇到问题"><a href="#遇到问题" class="header-anchor">#</a> 遇到问题</h3> <h4 id="原子变量未初始化"><a href="#原子变量未初始化" class="header-anchor">#</a> 原子变量未初始化</h4> <p>服务器没有启动监听<code>Acceptor::listen</code>，排查后发现</p> <p><code>TcpServer::start()</code> 中 执行该函数的判断变量没有初始化，导致判断条件不成立，无法执行<code>Acceptor::listen</code></p> <p>即控制TcpServer::start()只执行一次的原子变量<strong>started_</strong> 未初始化，数值为65538</p> <h4 id="accept问题"><a href="#accept问题" class="header-anchor">#</a> accept问题</h4> <p>调用<code>accept</code>处出错，错误码为 <code>errno = 22</code></p> <p>通过<code>perror</code>查询发现是<code>invalid argument</code>,查阅资料后发现具体是因为</p> <ol><li>accept函数参数不合法</li> <li>对返回的<code>connfd</code>没设置非阻塞，因为本项目是Reactor模型 <code>one loop per thread</code> + <code>non-blocking IO</code></li></ol> <p>为了方便起见，不想再多写fcntl，于是采用<code>accept4</code>替代 accept</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>sockaddr_in addr<span class="token punctuation">;</span>
socklen_t len <span class="token operator">=</span> <span class="token keyword">sizeof</span> addr<span class="token punctuation">;</span>
<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// sockfd是listen用</span>
<span class="token keyword">int</span> connfd <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">accept4</span><span class="token punctuation">(</span>sockfd_<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">,</span> SOCK_CLOEXEC <span class="token operator">|</span> SOCK_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_3、项目核心逻辑介绍"><a href="#_3、项目核心逻辑介绍" class="header-anchor">#</a> 3、项目核心逻辑介绍</h2> <p>我自己对Muduo库网络部分核心做了一个总结</p> <p>Muduo库采用<code>one loop per thread</code> + <code>nonblocking IO</code>网络模型，<strong>在mainLoop中 关注listenfd的读事件</strong>，并且将该listenfd封装成一个特殊的 <code>TcpConnection</code> 类即 <code>Acceptor</code> ，因为其读事件的处理是调用 <code>accept</code> 建立连接，并且将连接发送到一个subLoop上，选择subLoop的方法采用<strong>轮询</strong>的方法。</p> <p><strong>EventLoop模块</strong></p> <p>首先是最重要的<code>Reactor</code>模块，在Muduo库中也就是<code>EventLoop</code> 类的，其中<strong>主要的功能负责调度和分发网络事件</strong>即调用 <code>epoll_wait</code> 监视fd感兴趣的事件，并执行对应的<strong>回调函数</strong>。在Muduo中将这一个逻辑流程进行面向对象的拆解，将<code>epoll_wait</code> 封装到 <code>EPollPoller</code>中，将fd以及其感兴趣的事件和对应回调封装到Channel中。<strong>EventLoop 负责 Channel 和 Poller的通信</strong>，<code>EventLoop::loop()</code> 调用 <code>Poller</code>进行检测事件，当有事件到来，再通过<code>EventLoop</code>调用 <code>Channel</code>中由<code>TcpConnection</code>和 用户设置的相应事件回调。</p> <p><strong>eventfd()</strong></p> <p>注意到这里每一个Loop 与 其构造时的线程一一对应，在subLoop初始化时，会自动创建一个 <code>eventfd()</code>来供mainLoop唤醒它本身，这样就<strong>不需要使用生产者消费者队列来管理任务，从而避免subLoop争抢任务而要将队列加锁</strong>带来的开销。</p> <p><strong>缓冲区Buffer</strong></p> <p><strong>非阻塞</strong>网络编程中应用层<code>buffer</code>是必须的：非阻塞IO的核心思想是<strong>避免阻塞</strong>在read()或write()或其他I/O系统调用上，这样可以最大限度复用thread-of-control，让一个线程能服务于多个socket连接。
I/O线程只能阻塞在<code>IO-multiplexing</code>函数上，如<code>select()/poll()/epoll_wait()</code>。这样一来，应用层的缓冲是必须的，每个TCP socket都要有<code>inputBuffer</code>和<code>outputBuffer</code>。</p> <p><code>TcpConnection</code>必须有<code>output buffer</code>：使程序在<code>write()</code>操作上不会产生阻塞，当write()操作后，操作系统一次性没有发送完时，网络库把剩余数据则放入<code>outputBuffer</code>中，然后注册<code>POLLOUT</code>事件，一旦socket变得可写，则立刻调用write()进行写入数据。即将应用层buffer数据拷贝到操作系统buffer。</p> <p><code>TcpConnection</code>必须有<code>input buffer</code>：当发送方send数据后，接收方收到数据不一定是整个的数据，网络库在处理socket可读事件的时候，<strong>必须一次性把socket里的数据读完（加一个栈空间的数组用readv分散读），否则会反复触发POLLIN事件</strong>，造成busy-loop。所以muduo库为了应对数据不完整的情况，收到的数据先放到inputBuffer里——操作系统buffer到应用层buffer。</p> <h2 id="_4、muduo库-connfd-采用触发模式是lt-这样优点是"><a href="#_4、muduo库-connfd-采用触发模式是lt-这样优点是" class="header-anchor">#</a> 4、muduo库 connfd 采用<strong>触发模式是LT</strong>，这样优点是</h2> <ul><li><p><strong>不会丢失数据</strong>或者消息<br>
应用没有读取完数据，内核是会不断上报的</p></li> <li><p><strong>低延迟</strong>处理<br>
每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</p></li> <li><p><strong>跨平台</strong>处理</p> <p>像select一样可以跨平台使用</p></li></ul> <p>Muduo几大网络组件的抽象如下</p> <p><img src="/assets/1693323274641.png" alt="1693323274641"></p> <p>项目多处使用C++11特性如<strong>原子变量</strong>实现<strong>无锁编程</strong>，以及<strong>智能指针对资源进行安全管理</strong>。</p> <h2 id="_4、定时器是怎么实现的-还有什么实现方式"><a href="#_4、定时器是怎么实现的-还有什么实现方式" class="header-anchor">#</a> 4、定时器是怎么实现的？还有什么实现方式？</h2> <blockquote><blockquote><p>答：</p> <ul><li>理解定时器： 很多场景会使用到定时器，例如
1.使用TCP长连接时，客户端需要定时向服务端发送心跳请求。
2.财务系统每个月的月末定时生成对账单。
3.双11的0点，定时开启秒杀开关。</li> <li>一般定时任务的形式表现为：经过固定时间后触发、按固定频率周期性触发、在某个时刻触发。
定时器可以理解为这样一个数据结构：存储一系列的任务集合，并且Deadline越接近的任务， 拥有越高的执行优先级，
在用户视角支持以下几种操作：NewTask:将新任务加入任务集合， Cancel：取消某个任务，在任务调度视角还要支持：Run:<strong>执行一个到期的定时任务，判断一个 任务是否到期，基本会采用轮询的方式进行过，每隔一个时间片去检查最近的任务是否到期</strong>，并且在 NewTask和Cancel的行为发生后，任务调度策略也会出现调整。</li> <li>数据结构的选择包括：1. 双向有序链表，2. 堆， 3. 时间轮， 4.层级时间轮。</li> <li>常见的实现</li></ul> <ol><li>TimerId非常简单，它被设计用来取消Timer的，它的结构很简单，只有一个Timer指针和其序列号。TimerQueue为其友元，可以操作其私有数据。</li> <li>Timer封装了定时器的一些参数，例如超时回调函数、超时时间、定时器是否重复、重复间隔时间、定时器的序列号。其函数大都是设置这些参数，<strong>run()用来调用回调函数，restart()用来重启定时器</strong>（如果设置为重复）。</li> <li>TimerQueue其实现是基于Set的。TimerQueue的封装是为了让未到期的时间Timer有序的排列起来，这样，能够根据当前时间找到已经到期的Timer也能高效的添加和删除Timer。
内部有channel，和timerfd关联。
添加新的Timer后，<strong>在超时后，timerfd可读，会处理channel事件，之后调用Timer的回调函数</strong>；在timerfd的事件处理后，还有检查一遍超时定时器，如果其属性为重复还有再次添加到定时器集合中。</li></ol></blockquote></blockquote> <h3 id="muduo的定时器是如何设计的"><a href="#muduo的定时器是如何设计的" class="header-anchor">#</a> <a href="http://www.cppblog.com/Solstice/archive/2014/08/21/139769.html" target="_blank" rel="noopener noreferrer">muduo的定时器是如何设计的？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <blockquote><blockquote><p>答:</p> <ul><li>muduo的定时器功能由三个class实现，<code>TimerId</code>、<code>Timer</code>、<code>TimerQueue</code>，用户只能看到第一个class，另外两个都是内部实现细节。其中<code>TimerQueue</code>最重要的接口包括<code>addTimer()</code>添加定时任务和<code>cancel()</code>取消定时任务。</li></ul></blockquote></blockquote> <blockquote><blockquote><ul><li>muduo把定时器交给内核管理，利用linux内核提供的<code>timerfd_create</code>接口创建定时器。</li></ul></blockquote></blockquote> <blockquote><blockquote><ul><li>muduo中定义了<code>TimerQueue</code>类作为定时器的封装。初始化时候，通过linux的API创建<code>timerfd</code>。定义一个timers来存储timer,这个timers的存储结构是std::Set，元素是std::pair&lt;Timerstamp, Timer*&gt;，添加定时器则往timers添加，muduo使用的是set存储定时器，set是默认排序的，最早超时的会在最前面，即set.begin()为最早超时的定时器。</li></ul></blockquote></blockquote> <blockquote><blockquote><ul><li>获取超时任务是通过<code>getExpired()</code>函数实现的，其具体实现是根据传入的参数设置一个哨兵值，然后调用set::lower_bound()返回第一个未到期的Timer的迭代器， 之后在timers_中删除到期的任务，并返回到期的任务。muduo使用linux的API创建定时触发可读的timerfd_, <strong>fd触发时调用handleRead函数， 该函数调用getExpired获取超时定时器，并逐一执行</strong>。</li></ul></blockquote></blockquote> <blockquote><blockquote><ul><li>cancel()通过（给每个Timer对象添加一个全局递增序列号，区分地址相同的先后两个Timer对象）。增加activeTimers_成员变量，保存的是目前有效的Timer指针，并满足<code>timers_.size() == activeTimers_.size()</code>，元素是pair&lt;Timer*, int64_t&gt;。并且利用<code>callingExpiredTimers_</code>和<code>cancelingTimers_</code>防止“自注销”现象，即定时器回调中注销当前定时器。</li></ul></blockquote></blockquote> <h2 id="_7、网络库的io模型是怎么样的-为什么这个io模型是高性能的"><a href="#_7、网络库的io模型是怎么样的-为什么这个io模型是高性能的" class="header-anchor">#</a> 7、网络库的io模型是怎么样的，为什么这个io模型是高性能的？</h2> <blockquote><blockquote><p>UNP中总结的IO模型有5种之多：<code>阻塞IO，非阻塞IO，IO复用，信号驱动IO，异步IO</code>。前四种都属于同步IO。阻塞IO不必说了。非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由<strong>内核来负责本来是请求进程该做的轮询操作</strong>。看似比非阻塞IO还多了一个系统调用开销，不过<strong>因为可以支持多路IO，才算提高了效率</strong>。信号驱动IO，<strong>调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间</strong>，这一步是阻塞的。 异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程。</p></blockquote></blockquote> <blockquote><blockquote><p><code>Reactor[one loop per thread: non-blocking + IO multiplexing]</code>模型。muduo采用的是Reactors in thread有一个main Reactor负责accept(2)连接，然后把连接挂在某个sub Reactor中(muduo中采用的是round-robin的方式来选择sub Reactor)，这样该连接的所有操作都在那个sub Reactor所处的线程中完成。多个连接可能被分到多个线程中，以充分利用CPU。</p></blockquote></blockquote> <blockquote><blockquote><p>muduo采用的是固定大小的Reactor pool，池子的大小通常根据CPU数目确定。也就是说线程数固定，这样程序的总体处理能力不会随连接数增加而下降。另外一个连接完全由一个线程管理，那么请求的顺序性有保证，突发请求也不会占满8个核(如果需要优化突发请求，可以考虑Reactors + thread pool)。这种方案把IO分派给多个线程，防止出现一个Reactor的处理能力饱和。</p></blockquote></blockquote> <p><img src="/assets/0_1280551552NVgW.jpg" alt="各种IO模型的比较"></p> <blockquote><blockquote><p><a href="https://www.cnblogs.com/findumars/p/6361627.html" target="_blank" rel="noopener noreferrer">5种网络IO模型（有图，很清楚）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://blog.csdn.net/WuLex/article/details/80615699" target="_blank" rel="noopener noreferrer">五种网络io模型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://blog.csdn.net/weixin_43819197/article/details/92828590" target="_blank" rel="noopener noreferrer">muduo网络库：Reactor模型的介绍<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote></blockquote> <h2 id="_10、muduo的主线程accept的fd如何分发给其他线程"><a href="#_10、muduo的主线程accept的fd如何分发给其他线程" class="header-anchor">#</a> 10、muduo的主线程accept的fd如何分发给其他线程？</h2> <p>TcpServer<strong>每次新建一个TcpConnection就会调用getNextLoop()来取得EventLoop</strong>，采用round-robin算法来选取pool中的EventLoop,<strong>不允许TcpConnection在运行中更换EventLoop</strong>。</p> <h2 id="_13、muduo如何限制连接的数量"><a href="#_13、muduo如何限制连接的数量" class="header-anchor">#</a> <a href="http://www.cppblog.com/Solstice/archive/2011/04/27/145102.html" target="_blank" rel="noopener noreferrer">13、muduo如何限制连接的数量？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <ul><li><p>解决文件描述符达到上限</p> <p>准备一个空闲文件描述符。遇到这种情况，先关闭空闲文件，获得一个文件描述符的名额，再accept拿到新的socket连接的描述符，随后立刻close它，这样就优雅的断开了客户端连接，最后重新打开一个空闲文件。</p></li> <li><p>增加一个 int 成员，表示当前的活动连接数。然后，在 EchoServer::onConnection() 中判断当前活动连接数，如果超过最大允许数，则踢掉连接。</p></li></ul> <h2 id="_16、muduo如何设计buffer"><a href="#_16、muduo如何设计buffer" class="header-anchor">#</a> 16、<a href="https://www.cnblogs.com/solstice/archive/2011/04/17/2018801.html" target="_blank" rel="noopener noreferrer">muduo如何设计buffer？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>Muduo Buffer 的设计要点：</p> <ul><li><em><em>对外表现为一块连续的内存(char</em>, len)</em>* ，以方便客户代码的编写。</li> <li><strong>其 size() 可以自动增长</strong>，以适应不同大小的消息。它不是一个 fixed size array (即 char buf[8192])。</li> <li><strong>内部以 vector of char 来保存数据，并提供相应的访问函数</strong>。</li></ul> <p>Buffer 其实像是一个 queue，从末尾写入数据，从头部读出数据。</p> <p>TcpConnection 会有两个 Buffer 成员，input buffer 与 output buffer。</p> <ul><li>input buffer，TcpConnection 会从 socket 读取数据，然后写入 input buffer（其实这一步是用 Buffer::readFd() 完成的）；客户代码从 input buffer 读取数据。</li> <li>output buffer，客户代码会把数据写入 output buffer（其实这一步是用 TcpConnection::send() 完成的）；TcpConnection 从 output buffer 读取数据并写入 socket。</li></ul> <p>其实，input 和 output 是针对客户代码而言，客户代码从 input 读，往 output 写。TcpConnection 的读写正好相反。</p> <p>具体做法是，在栈上准备一个 65536 字节的 stackbuf，然后利用 readv() 来读取数据，iovec 有两块，第一块指向 muduo Buffer 中的 writable 字节，另一块指向栈上的 stackbuf。这样如果读入的数据不多，那么全部都读到 Buffer 中去了；如果长度超过 Buffer 的 writable 字节数，就会读到栈上的 stackbuf 里，然后程序再把 stackbuf 里的数据 append 到 Buffer 中。</p> <p><img src="/assets/68747470733a2f2f696d616765732e636e626c6f67732e636f6d2f7.png" alt="buffer0"></p> <p>两个 indices 把 vector 的内容分为三块：prependable、readable、writable，各块的大小是（<strong>公式一</strong>）：</p> <ul><li>prependable = readIndex</li> <li>readable = writeIndex - readIndex</li> <li>writable = size() - writeIndex（prependable 的作用留到后面讨论。）</li></ul> <p>readIndex 和 writeIndex 满足以下不变式(invariant):</p> <ul><li>0 ≤ readIndex ≤ writeIndex ≤ data.size()</li></ul> <h2 id="_21、如何安全的关闭tcp连接-能不能直接close-如何直接close会发生什么"><a href="#_21、如何安全的关闭tcp连接-能不能直接close-如何直接close会发生什么" class="header-anchor">#</a> 21、<a href="https://blog.csdn.net/Solstice/article/details/6208634" target="_blank" rel="noopener noreferrer">如何安全的关闭tcp连接，能不能直接close，如何直接close会发生什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>调用TcpConnection::shutdown主动关闭时，muduo 把“主动关闭连接”这件事情分成两步来做，如果要主动关闭连接，它会先关本地“写”端，等对方关闭之后，再关本地“读”端。</p> <p>“如果被动关闭连接，muduo 的行为如何？” 提示：muduo 在 read() 返回 0 的时候会回调 connection callback，这样客户代码就知道对方断开连接了。</p> <p>直接关闭会影响收发数据的完整性</p> <h3 id="什么是优雅关闭连接-就是read-到0-要透明的传递这个行为而不是直接暴力close"><a href="#什么是优雅关闭连接-就是read-到0-要透明的传递这个行为而不是直接暴力close" class="header-anchor">#</a> 什么是优雅关闭连接？(就是read()到0，要透明的传递这个行为而不是直接暴力close())</h3> <p>先在TcpServer中移除当前连接，然后在TcpConnection::connectionDestroyed()中调用connectionCallback_通知关闭，最后在loop_中移除当前channel_。</p> <h2 id="_22、muduo是如何-线程安全的对-对象的生命周期进行管理"><a href="#_22、muduo是如何-线程安全的对-对象的生命周期进行管理" class="header-anchor">#</a> 22、muduo是如何 线程安全的对 对象的生命周期进行管理？</h2> <h3 id="chatgpt"><a href="#chatgpt" class="header-anchor">#</a> chatgpt</h3> <p>muduo 是一个基于 C++ 的网络库，设计用来构建高性能的多线程服务器应用程序。在 muduo 中，对象的生命周期管理主要通过<strong>智能指针和对象的创建与销毁策略来实现线程安全</strong>。</p> <p>以下是 muduo 如何线程安全地对对象的生命周期进行管理的一些关键点：</p> <ol><li><p>智能指针：muduo 使用了 <code>shared_ptr</code> 和 <code>weak_ptr</code> 来管理对象的生命周期。<code>shared_ptr</code> 允许多个线程共享同一个对象，并在最后一个引用被销毁时自动释放对象资源。<code>weak_ptr</code> 则提供了一种非拥有（弱）引用的方式，可以检查对象是否已经被销毁。</p></li> <li><p>对象的创建与销毁策略：muduo 采用了对象池技术来管理对象的创建与销毁。对象池在初始化时会<strong>预先创建一定数量的对象，并将其保存在一个对象集合中</strong>。当需要对象时，可以<strong>从对象池中获取一个空闲对象</strong>，<strong>而不是每次都创建新的对象</strong>。当对象不再使用时，可以将其<strong>返回到对象池中以便重复利用</strong>，而不是立即销毁对象。这种方式减少了频繁的对象创建与销毁操作，提高了性能和效率。</p></li> <li><p>线程安全的访问控制：muduo 通过使用互斥锁（mutex）和条件变量（condition variable）等同步机制来保护对象的访问，<strong>确保多个线程之间对同一个对象的访问是安全的</strong>。通过<strong>加锁和解锁操作，控制了对共享对象的并发访问</strong>。</p></li></ol> <p>总体上说，muduo 通过智能指针、对象池和线程安全的访问控制等方法，实现了对对象生命周期的线程安全管理。这些机制确保了多线程环境下对象的正确创建、使用和销毁，并提高了性能和效率。</p> <h2 id="_23、eventfd是什么-有什么好处"><a href="#_23、eventfd是什么-有什么好处" class="header-anchor">#</a> 23、eventfd是什么？有什么好处？</h2> <ul><li>eventfd是linux的一个系统调用，<strong>为事件通知创建文件描述符</strong>，<strong>eventfd()创建一个“eventfd对象”</strong> ，这个对象能被<strong>用户空间应用用作一个事件等待/响应机制，靠内核去响应用户空间应用事件</strong>。</li> <li><strong>实现唤醒，让IO线程从IO multiplexing阻塞调用中返回，更高效地唤醒</strong>。</li></ul> <p><code>eventfd</code> 是 <strong>Linux 提供的一种事件文件描述符，用于在用户空间和内核之间进行事件通知</strong>。以下是对 <code>eventfd</code> 的详细解释：</p> <ol><li><p>创建 <code>eventfd</code>：使用 <code>eventfd</code> 系统调用可以创建一个新的 <code>eventfd</code> 文件描述符。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/eventfd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">eventfd</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> initval<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><code>initval</code> 是初始计数器值，指定了 <code>eventfd</code> 的初始状态。</li> <li><code>flags</code> 可以设置一些选项，常用的选项有 <code>EFD_NONBLOCK</code>（非阻塞模式）和 <code>EFD_SEMAPHORE</code>（信号量模式）。</li></ul></li></ol> <h3 id="_24、双缓冲区异步日志是什么-为什么要这样做-对这个日志系统有没有进行压力测试"><a href="#_24、双缓冲区异步日志是什么-为什么要这样做-对这个日志系统有没有进行压力测试" class="header-anchor">#</a> 24、<a href="https://blog.csdn.net/daaikuaichuan/article/details/86500108" target="_blank" rel="noopener noreferrer">双缓冲区异步日志是什么？为什么要这样做？对这个日志系统有没有进行压力测试？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <ul><li>日志库采用的是双缓冲技术，基本思路是准备两块缓冲：A与B，<strong>前端负责往buffer A中填数据（日志消息），后端负责将buffer B中的数据写入文件</strong>。当<strong>buffer A写满之后，交换A与B</strong>，<strong>让后端将buffer A中的数据写入文件，而前端负责往buffer B中填入新的日志文件</strong>。如此往复。用两个buffer的好处是<strong>在新建日志消息的时候不必等待磁盘文件操作，也避免每条消息都触发（唤醒）了后端日志线程</strong>。换言之，前端不是将一条条消息分别传送给后端，而是将多个日志消息拼成一个大的buffer传送给后端，相当于批处理，<strong>减少了线程唤醒的频率，降低了开销</strong>。另外，为了及时将消息写入文件，即使前端的buffer A未写满，<strong>日志库也会每三秒执行一次上述交换写入操作</strong>。
<img src="/assets/1692081412250.png" alt="1692081412250"></li> <li><strong>多个线程可以并发写日志，两个线程日志消息不会出现交织，并且满足高性能，不存在抢锁的现象。网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔可能会阻塞长达数秒。导致请求超时或者耽误发送心跳消息，引起误报死锁，或者引发自动faileover等</strong>。</li> <li><strong>什么时候切换写到另一个日志文件</strong>？前一个buffer已经写满了，则交换两个buffer（写满的buffer置空）。</li> <li><strong>日志串写入过多，日志线程来不及消费，怎么办</strong>？直接丢掉多余的日志buffer，腾出内存，防止引起程序故障。</li> <li><strong>什么时候唤醒日志线程从Buffer中取数据</strong>？其一是超时，其二是前端写满了一个或者多个buffer。</li></ul> <p>参考: <a href="https://www.twblogs.net/a/5b8dcefa2b7177188340bbb4/zh-cn" target="_blank" rel="noopener noreferrer">muduo的日志库分析四之AsyncLogging类<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_25、epoll的边沿触发和水平触发有什么区别-epoll的源码并不长-从源码的角度回答比较好"><a href="#_25、epoll的边沿触发和水平触发有什么区别-epoll的源码并不长-从源码的角度回答比较好" class="header-anchor">#</a> 25、<a href="https://www.cnblogs.com/charlesblc/p/6242479.html" target="_blank" rel="noopener noreferrer">epoll的边沿触发和水平触发有什么区别？(epoll的源码并不长，从源码的角度回答比较好)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p><strong>水平触发(level-trggered)</strong></p> <ul><li>只要<strong>文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知</strong>，</li> <li>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知</li></ul> <p><strong>LT模式支持阻塞和非阻塞两种方式。epoll默认的模式是LT。</strong></p> <p><strong>边缘触发(edge-triggered)</strong></p> <ul><li>当<strong>文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知</strong>，</li> <li>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知</li> <li>两者的区别在哪里呢？水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次。</li> <li>执行epoll_create时，创建了<strong>红黑树和就绪链表</strong>，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后<strong>向内核注册回调函数</strong>，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</li></ul> <h2 id="_26、epoll为什么高效-相比select和poll"><a href="#_26、epoll为什么高效-相比select和poll" class="header-anchor">#</a> 26、<a href="https://www.cnblogs.com/charlesblc/p/6242479.html" target="_blank" rel="noopener noreferrer">epoll为什么高效，相比select和poll<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <ul><li>这是由于我们在调用epoll_create时，内核除了帮我们<strong>在epoll文件系统里建了个file结点</strong>，<strong>在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket</strong>外，还会<strong>再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可</strong>。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</li></ul> <h2 id="_27、假如服务器要升级-又不想让用户感觉到服务器升级了-该怎么做-其实就是不间断的提供服务-参考nginx的平滑升级"><a href="#_27、假如服务器要升级-又不想让用户感觉到服务器升级了-该怎么做-其实就是不间断的提供服务-参考nginx的平滑升级" class="header-anchor">#</a> 27、假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)</h2> <p><strong>平滑升级的本质就是 listener fd 的迁移</strong></p> <p><strong>Nginx 的平滑升级是通过 <code>fork</code> + <code>execve</code> 这种经典的处理方式来实现的。</strong> 准备升级时，Old Master 进程收到信号<strong>然后 <code>fork</code> 出一个子进程，注意此时这个子进程运行的依然是老的镜像文件。紧接着这个子进程会通过 <code>execve</code> 调用执行新的二进制文件来替换掉自己，成为 New Master</strong>。</p> <p>Nginx 在 <code>execve</code> 的时候压根就没有重新 <code>bind</code> + <code>listen</code>，而是<strong>直接把 listener fd 添加到 <code>epoll</code> 的事件表</strong>。因为这个 New Master 本来就是从 Old Master 继承而来，自然就继承了 Old Master 的 listener fd。</p> <p><strong>环境变量</strong>。<code>execve</code> 在执行的时候可以传入环境变量。实际上 Old Master 在 <code>fork</code> 之前会将所有 listener fd 添加到 <code>NGINX</code> 环境变量：</p> <p>Nginx 在启动的时候，会解析 <code>NGINX</code> 环境变量，一旦检测到是继承而来的 socket，那就说明已经打开了，不会再继续 <code>bind</code> + <code>listen</code> 了：</p> <p>参考<a href="https://www.slideshare.net/joshzhu/nginx-internals" target="_blank" rel="noopener noreferrer">Nginx Internals<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_32、怎么检查内存泄漏的"><a href="#_32、怎么检查内存泄漏的" class="header-anchor">#</a> 32、<a href="https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html" target="_blank" rel="noopener noreferrer">怎么检查内存泄漏的？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p><strong>定义</strong>：内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。 <strong>内存泄漏并⾮指内存在物理上消失，⽽是应⽤程序分配某段内存后，由于设计错误，失去了对该段内存的控制</strong></p> <p><strong>如何检测内存泄漏</strong></p> <ul><li>⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀
两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。</li> <li>还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个
可能的解释就是有个进程出现了内存泄漏。</li> <li>当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的
检测。</li> <li>检查⽅法：在main函数最后⾯⼀⾏，加上⼀句_CrtDumpMemoryLeaks()。调试程序，⾃然关闭程序让其退出，查看输出：
输出这样的格式{453}normal block at 0x02432CA8,868 bytes long
被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地⽅有868⽐特内存没有释放。
定位代码位置
在main函数第⼀⾏加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调⽤堆栈。加上头⽂件<code>#include &lt;crtdbg.h&gt;</code></li></ul> <p><strong>避免</strong></p> <ul><li>动态内存的分配与释放必须配对</li> <li>智能指针</li></ul> <h3 id="_34、用到了哪些智能指针和raii机制-几种锁的区别是什么"><a href="#_34、用到了哪些智能指针和raii机制-几种锁的区别是什么" class="header-anchor">#</a> 34、用到了哪些智能指针和<a href="https://www.jianshu.com/p/b7ffe79498be" target="_blank" rel="noopener noreferrer">RAII机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，几种锁的区别是什么</h3> <ul><li><p>shared_ptr、unique_ptr、scope_ptr、weak_ptr</p> <ul><li><p>shared_ptr: TcpClient::Connector</p></li> <li><p>unique_ptr: AsyncLogging::BufferVector</p></li> <li><p>scope_ptr: EventLoop::poller TcpConnection::socket_, channel_</p> <ul><li><p>scope_ptr是一个很类似auto_ptr的智能指针，它包装了new操作符在堆上分配的动态对象，能够保证动态创建的对象在任何时候都可以被正确地删除。</p> <p>但scope_ptr的所有权更加严格，不能转让，一旦scope_ptr获得了对象的管理权，你就无法再从它那里取回来.</p></li></ul></li> <li><p>weak_ptr</p></li></ul></li></ul> <h2 id="_27-任务队列是怎么实现的-除了加锁还有什么方式"><a href="#_27-任务队列是怎么实现的-除了加锁还有什么方式" class="header-anchor">#</a> 27.任务队列是怎么实现的，除了加锁还有什么方式？</h2> <h3 id="eventloop重要成员变量"><a href="#eventloop重要成员变量" class="header-anchor">#</a> EventLoop重要成员变量</h3> <p><code>pendingFunctors_</code>：如果涉及跨线程调用函数时，会将函数储存到<code>pendingFunctors_</code>这个任务队列中。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 在I/O线程中调用某个函数，该函数可以跨线程调用</span>
<span class="token keyword">void</span> <span class="token class-name">EventLoop</span><span class="token double-colon punctuation">::</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isInLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 如果是在当前I/O线程中调用，就同步调用cb回调函数</span>
        <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 否则在其他线程中调用，就异步将cb添加到任务队列当中，</span>
        <span class="token comment">// 以便让EventLoop真实对应的I/O线程执行这个回调函数</span>
        <span class="token function">queueInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="eventloop-是如何保证线程安全的"><a href="#eventloop-是如何保证线程安全的" class="header-anchor">#</a> EventLoop 是如何保证线程安全的</h3> <p>还以上述的那个例子：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>EventLoop<span class="token operator">*</span> ioLoop <span class="token operator">=</span> threadPool_<span class="token operator">-&gt;</span><span class="token function">getNextLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ioLoop<span class="token operator">-&gt;</span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>connectEstablished<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里获取的 ioLoop 是从线程池中某个线程创建而来的，那么可以知道创建 ioLoop 的线程和目前运行的线程不是同一个线程，那么这个操作是线程不安全的。</p> <p>一般为了保证线程安全，我们可能会使用互斥锁之类的手段来保证线程同步。但是，互斥锁的粗粒度难以把握，如果锁的范围很大，各个线程频繁争抢锁执行任务会大大拖慢网络效率。</p> <p>而 muduo 的处理方法是，保证各个任务在其原有得线程中执行。如果跨线程执行，则将此任务加入到任务队列中，并唤醒应当执行此任务得线程。而原线程唤醒其他线程之后，就可以继续执行别的操作了。可以看到，这是一个异步得操作。 接下来继续探索<code>queueInLoop</code>的实现：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 将任务添加到队列当中，队就是成员pendingFunctors_数组容器</span>
<span class="token keyword">void</span> <span class="token class-name">EventLoop</span><span class="token double-colon punctuation">::</span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 操作任务队列需要保证互斥</span>
        MutexLockGuard <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pendingFunctors_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 调用此函数的线程不是这个EventLoop的创建线程
     * 或者正在处理PendingFunctors的情况则唤醒IO线程
     * 
     * 如果是当前的IO线程调用且并没有正处理PendgingFunctors
     * 则不必唤醒
     */</span>   
    
    <span class="token comment">// 唤醒相应的线程，需要执行上面回调操作的loop的线程了</span>
    <span class="token comment">// ||callingPendingFunctors_的意思是：当前loop正在执行回调，但是loop又有了新的回调，继续唤醒执行新的回调</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isInLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> callingPendingFunctors_<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p><code>queueInLoop</code>的实现也有很多细节，首先可以看到在局部区域生成一个互斥锁（支持<code>RALL</code>），然后再进行任务队列加入新任务的操作。 这是因为可能此<code>EventLoop</code>会被多个线程所操纵，假设多个线程调用<code>loop-&gt;queueInLoop(cb)</code>，都向此任务队列加入自己的回调函数，这势必会有线程间的竞争情况。需要在此处用一个互斥锁保证互斥，可以看到这个锁的粒度比较小。</p> <p><code>callingPendingFunctors_</code> 这个标志位在 <code>EventLoop::doPendingFunctors()</code> 函数中被标记为 true。 <strong>也就是说如果 EventLoop 正在处理当前的 PendingFunctors 函数时有新的回调函数加入，我们也要继续唤醒。</strong> 倘若不唤醒，那么新加入的函数就不会得到处理，会因为下一轮的 epoll_wait 而继续阻塞住，这显然会降低效率。这也是一个 muduo 的细节。 继续探索 <code>wakeup()</code> 函数，从其名字就很容易看出来，这是唤醒其他线程的操作。如何唤醒那个<code>EventLoop</code>的所在线程呢，其实只要往其 <code>wakeupFd_</code>写数据就行。</p> <p>每个<code>EventLoop</code>的<code>wakeupFd_</code>都被加入到<code>epoll</code>对象中，只要写了数据就会触发读事件，<code>epoll_wait</code>就会返回。因此<code>EventLoop::loop</code>中阻塞的情况被打断，<code>Reactor</code>又被事件「驱动」了起来。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">EventLoop</span><span class="token double-colon punctuation">::</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 可以看到写的数据很少，纯粹是为了通知有事件产生</span>
    <span class="token keyword">uint64_t</span> one <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    ssize_t n <span class="token operator">=</span> sockets<span class="token double-colon punctuation">::</span><span class="token function">write</span><span class="token punctuation">(</span>wakeupFd_<span class="token punctuation">,</span> <span class="token operator">&amp;</span>one<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> one<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token keyword">sizeof</span> one<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        LOG_ERROR <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;EventLoop::wakeup() writes &quot;</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; bytes instead of 8&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这里可以看另一个例子，<code>TcpServer</code>的销毁连接操作。会在<code>baseLoop</code>中获取需要销毁的连接所在的<code>ioLoop/</code>，然后让<code>ioLoop</code>执行销毁操作，细节可以看注释。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token class-name">TcpServer</span><span class="token double-colon punctuation">::</span><span class="token function">removeConnectionInLoop</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span> conn<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  loop_<span class="token operator">-&gt;</span><span class="token function">assertInLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  LOG_INFO <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;TcpServer::removeConnectionInLoop [&quot;</span> <span class="token operator">&lt;&lt;</span> name_
           <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;] - connection &quot;</span> <span class="token operator">&lt;&lt;</span> conn<span class="token operator">-&gt;</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 从map删除</span>
  size_t n <span class="token operator">=</span> connections_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>conn<span class="token operator">-&gt;</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 获取subLoop</span>
  EventLoop<span class="token operator">*</span> ioLoop <span class="token operator">=</span> conn<span class="token operator">-&gt;</span><span class="token function">getLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/**
   * subLoop调用TcpConnection::connectDestroyed
   * 因为是在baseLoop的线程里调用subLoop的函数，所以不能同步调用，需要放入队列
   * 在加锁的环境下将此回调哈函数保存到subLoop的pendingFunctors_中并唤醒
   * 那么这个唤醒就是在baseLoop的线程里调用subLoop::wakeup写数据给subLoop的wakeFd,subLoop的主事件循环被唤醒执行pendingFunctors_
   * 而baseLoop线程在wakeup写完数据之后就没有继续往下执行了，这就保证整个函数只被subloop线程执行
   * 保证了线程的安全
   */</span>
  ioLoop<span class="token operator">-&gt;</span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>
      std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>connectDestroyed<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="_28-如何解决死锁"><a href="#_28-如何解决死锁" class="header-anchor">#</a> 28.如何解决死锁？</h2> <ol><li>死锁: 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两
只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁。</li> <li>产生的条件：死锁发生有四个必要条件：
（1）互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到
进程使用完成后释放该资源；
（2）请求保持条件：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，
此时请求阻塞，而且该进程不会释放自己已经占有的资源；
（3）不可剥夺条件：进程已获得的资源，只能自己释放，不可剥夺；
（4）环路等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li> <li>如何解决：
（1）资源一次性分配，从而解决请求保持的问题
（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；
（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。</li></ol> <p>答案解析
举个例子，比如：如果此时有两个线程T1和T2，它们分别占有R1和R2资源
此时，T1请求R2资源的同时，T2请求R1资源。
这个时候T2说：你把R1给我，我就给你R2
T1说：不行，你要先给我R2，我才能给你R1
那么就这样，死锁产生了。如下图：</p> <p><img src="/assets/1692623209379.png" alt="1692623209379"></p> <h2 id="_29-怎么进行压测的"><a href="#_29-怎么进行压测的" class="header-anchor">#</a> 29.怎么进行压测的？</h2> <p>在example中使用mymuduo实现了http服务器（只是简单的通过/hello返回hello world），使用apache benchmark对此http服务器进行压力测试，可以测试网络库的并发处理能力 在本人笔记本上（CPU i5-6200U）使用ab进行测压（setThreadNums = 4）</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>ab <span class="token parameter variable">-n</span> <span class="token number">1000000</span> <span class="token parameter variable">-c</span> <span class="token number">1000</span> <span class="token parameter variable">-k</span> http://127.0.0.1:8000/hello
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这是用于 ApacheBench 工具（ab）的命令，用于评估 Web 服务器的性能，特别是针对 HTTP 和 HTTPS 协议。它通过向服务器发送指定数量的请求并测量响应时间来模拟同时访问网站的负载情况。</p> <p>让我们解析一下命令的组成部分：</p> <ul><li><code>-n 1000000</code>：此选项指定要发送的请求数量。在这种情况下，将发送一百万个请求。</li> <li><code>-c 1000</code>：此选项设置并发级别，指定同时发送多少个请求。在这里，会同时发送一千个请求。</li> <li><code>-k</code>：此选项启用 HTTP KeepAlive 功能，允许多个请求通过单个连接发送。</li> <li><code>http://127.0.0.1:8000/hello</code>：这是您要测试的服务器端点的 URL。在这种情况下，它被设置为 <code>http://127.0.0.1:8000/hello</code>。</li></ul> <p>因此，通过运行此命令，您将向指定的 URL 发送一百万个请求，并且并发级别为 1000。KeepAlive 功能将被启用，允许通过单个连接发送多个请求。</p> <h2 id="_30-为什么要用非阻塞io"><a href="#_30-为什么要用非阻塞io" class="header-anchor">#</a> 30.为什么要用非阻塞io？</h2> <p>muduo库使用非阻塞IO的优势在于，它可以提高应用程序的并发性能。</p> <p>当应用程序等待I/O操作完成时，非阻塞IO可以让应用程序继续处理其他任务，从而提高应用程序的吞吐量和响应速度  。</p> <h2 id="_36、日志宏定义"><a href="#_36、日志宏定义" class="header-anchor">#</a> 36、日志宏定义</h2> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">MYMUDUO_DEBUG</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG_DEBUG</span><span class="token expression"><span class="token punctuation">(</span>logmsgFormat<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
        <span class="token expression">Logger <span class="token operator">&amp;</span>logger <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token double-colon punctuation">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token expression">logger<span class="token punctuation">.</span><span class="token function">setLogLevel</span><span class="token punctuation">(</span>DEBUG<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> logmsgFormat<span class="token punctuation">,</span> </span><span class="token punctuation">##</span><span class="token expression">__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token expression">logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> </span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG_DEBUG</span><span class="token expression"><span class="token punctuation">(</span>logmsgFormat<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>代码段中使用了预处理指令来定义一个调试日志宏 <code>LOG_DEBUG</code>。这个宏的定义取决于是否定义了 <code>MYMUDUO_DEBUG</code> 符号。</p> <ul><li><p>如果 <code>MYMUDUO_DEBUG</code> 被定义（例如，在编译命令行中使用 <code>-DMYMUDUO_DEBUG</code> 或者在代码的某个地方使用 <code>#define MYMUDUO_DEBUG</code>），那么 <code>LOG_DEBUG</code> 宏将会被定义为一个包含实际日志代码的块。</p></li> <li><p>如果 <code>MYMUDUO_DEBUG</code> 没有被定义，那么 <code>LOG_DEBUG</code> 宏将被定义为空，这意味着在代码中调用 <code>LOG_DEBUG</code> 将不会产生任何效果。</p></li></ul> <p>简而言之，<code>ifdef</code> 里的内容能成立的条件是 <code>MYMUDUO_DEBUG</code> 被定义了。如果你想在调试构建中启用这些日志，你可以定义这个符号；如果你想在发布构建中禁用这些日志，你可以确保这个符号未被定义。</p> <h2 id="_38、shared-from-this"><a href="#_38、shared-from-this" class="header-anchor">#</a> 38、shared_from_this()</h2> <p><code>shared_from_this()</code> 是 C++ 中 <code>std::enable_shared_from_this</code> 类模板提供的一个成员函数，用于从一个类实例中获取一个 <code>std::shared_ptr</code>，以确保在共享所有权的情况下访问该实例。这通常在一个类的成员函数中使用，以避免通过裸指针来获取智能指针，从而更安全地管理对象的生命周期。</p> <p>以下是 <code>std::enable_shared_from_this</code> 的一些重要信息：</p> <ol><li><p><strong><code>std::enable_shared_from_this</code> 类模板</strong>：
<code>std::enable_shared_from_this</code> 是一个模板类，你需要将它作为你自己的类的基类。这样，你的类就会继承 <code>std::enable_shared_from_this</code> 提供的一些功能。</p></li> <li><p><strong><code>shared_from_this()</code> 成员函数</strong>：
在继承了 <code>std::enable_shared_from_this</code> 的类中，你可以调用 <code>shared_from_this()</code> 成员函数，该函数返回一个 <code>std::shared_ptr</code> 智能指针，指向当前实例。这样，你就可以在不担心对象生命周期管理的情况下使用智能指针，而不是使用裸指针。</p></li> <li><p><strong>注意事项</strong>：</p> <ul><li>使用 <code>shared_from_this()</code> 前提是，你必须已经通过 <code>std::shared_ptr</code> 创建了这个对象的共享指针，然后才能在对象的成员函数中使用 <code>shared_from_this()</code>。</li> <li>如果在对象的构造函数中尝试使用 <code>shared_from_this()</code>，会导致未定义行为，因为此时尚未构造出有效的 <code>shared_ptr</code>。</li></ul></li></ol> <p>以下是一个使用 <code>shared_from_this()</code> 的简单示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">MyClass</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">&gt;</span> sharedPtr <span class="token operator">=</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用 sharedPtr 进行操作，不需要担心对象的生命周期</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Doing something with MyClass&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">&gt;</span> obj <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj<span class="token operator">-&gt;</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在这个示例中，<code>MyClass</code> 继承了 <code>std::enable_shared_from_this&lt;MyClass&gt;</code>，然后在 <code>doSomething()</code> 中使用了 <code>shared_from_this()</code> 来获取一个智能指针，以确保在操作对象时对象的生命周期得到正确管理。</p> <h2 id="_40、std-search"><a href="#_40、std-search" class="header-anchor">#</a> 40、std::search</h2> <p>当使用 <code>std::search</code> 函数时，以下是有关头文件、函数描述、输入参数和输出的详细解释：</p> <p><strong>头文件</strong>：为了使用 <code>std::search</code> 函数，你需要包含 <code>&lt;algorithm&gt;</code> 头文件：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>函数描述</strong>：<code>std::search</code> 函数用于在一个序列中查找另一个序列的出现位置。它在主序列中查找子序列的第一个匹配位置。如果找到匹配的子序列，它返回一个指向主序列中匹配子序列的起始位置的迭代器；否则，返回主序列的 <code>last1</code> 迭代器。</p> <p><strong>输入参数</strong>：</p> <ul><li><code>first1</code> 和 <code>last1</code>：这两个参数定义了主序列的迭代器范围。<code>first1</code> 是主序列的起始迭代器，<code>last1</code> 是主序列的结束迭代器（不包含）。</li> <li><code>first2</code> 和 <code>last2</code>：这两个参数定义了子序列的迭代器范围。<code>first2</code> 是子序列的起始迭代器，<code>last2</code> 是子序列的结束迭代器（不包含）。</li></ul> <p><strong>输出</strong>：<code>std::search</code> 函数的返回值是一个迭代器，指向主序列中第一个匹配子序列的位置。如果找不到匹配，返回 <code>last1</code>。</p> <p>以下是使用 <code>std::search</code> 函数的示例，包括头文件、函数调用、输入参数和输出的解释：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> mainSequence <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> subSequence <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> result <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">search</span><span class="token punctuation">(</span>mainSequence<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mainSequence<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                              subSequence<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> subSequence<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> mainSequence<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Subsequence found at position: &quot;</span>
                  <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>mainSequence<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Subsequence not found.&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在这个示例中：</p> <ul><li><code>mainSequence</code> 是主序列，<code>subSequence</code> 是子序列。</li> <li><code>result</code> 是 <code>std::search</code> 函数的返回值，它是一个指向主序列中匹配子序列的起始位置的迭代器。</li> <li>如果找到匹配，使用 <code>std::distance</code> 计算迭代器之间的距离，得到匹配位置。</li> <li>如果找不到匹配，输出 &quot;Subsequence not found.&quot;。</li></ul> <p>这个示例演示了如何使用 <code>std::search</code> 函数查找子序列在主序列中的位置。</p> <h2 id="_42、findcrlf一直为null-针对数独的例子"><a href="#_42、findcrlf一直为null-针对数独的例子" class="header-anchor">#</a> 42、findcrlf一直为null，针对数独的例子</h2> <h3 id="问题"><a href="#问题" class="header-anchor">#</a> <strong>问题</strong></h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>p peek()
$16 = 0x55555559e208 &quot;1\\r\\n\n&quot;
p beginWrite()
$18 = 0x55555559e20e &quot;&quot;

p kCRLF
$20 = 0x55555557bc78 &lt;muduo::net::Buffer::kCRLF&gt; &quot;\r\n&quot;
p kCRLF+2
$21 = 0x55555557bc7a &lt;muduo::net::Buffer::kCRLF+2&gt; &quot;&quot;

为什么const char* crlf = std::search(peek(), beginWrite(), kCRLF, kCRLF+2);返回的是
p crlf
$22 = 0x55555559e20e &quot;&quot;
我调试打印的内容是这样的为什么找不到内容
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="原因1"><a href="#原因1" class="header-anchor">#</a> <strong>原因1</strong></h3> <p>根据你提供的信息和调试输出，我们可以进行一些进一步的分析。</p> <p>从你的调试输出来看：</p> <ul><li><code>peek()</code> 返回的字符串是 <code>&quot;1\\r\\n\n&quot;</code></li> <li><code>beginWrite()</code> 返回的是一个空字符串 <code>&quot;&quot;</code></li> <li><code>kCRLF</code> 的内容是 <code>&quot;\r\n&quot;</code></li> <li><code>kCRLF+2</code> 的内容是一个空字符串 <code>&quot;&quot;</code></li></ul> <p>你的代码逻辑是使用 <code>std::search</code> 函数在从 <code>peek()</code> 到 <code>beginWrite()</code> 的范围内搜索是否存在 <code>kCRLF</code> 序列。但是，根据你提供的数据，这个范围似乎并不包含匹配的 <code>kCRLF</code> 序列。</p> <p>从输出中可以看出，<code>peek()</code> 返回的字符串是 <code>&quot;1\\r\\n\n&quot;</code>，这表示字符串中包含了一些转义字符。具体来说，<code>&quot;\\r\\n&quot;</code> 表示两个字符 <code>\r</code> 和 <code>\n</code>，而不是回车换行符。</p> <p>而 <code>kCRLF</code> 的内容是 <code>&quot;\r\n&quot;</code>，表示一个回车换行符。由于 <code>std::search</code> 在搜索过程中要考虑字符串中的字符一一匹配，因此 <code>&quot;\\r\\n&quot;</code> 和 <code>&quot;\r\n&quot;</code> 并不相等。</p> <p>所以，在你的情况下，<code>std::search</code> 并不会在这个范围内找到匹配的 <code>kCRLF</code> 序列，因此返回的 <code>crlf</code> 指针仍然是空指针。</p> <p>你需要确认 <code>peek()</code> 返回的字符串中实际包含了怎样的字符，以及你的代码逻辑是否需要处理转义字符。如果你希望在搜索中找到回车换行符，你可以将 <code>kCRLF</code> 初始化为 <code>&quot;\\r\\n&quot;</code>，以便与 <code>peek()</code> 返回的字符串相匹配。</p> <h3 id="原因2"><a href="#原因2" class="header-anchor">#</a> <strong>原因2</strong></h3> <p>在终端里直接输入<code>1\r\n</code>，会被识别成<code>1\\r\\n\n</code>，</p> <p><code>\\</code> 是对 <code>\</code> 的转义，能正确输出 <code>\</code></p> <h3 id="原因3"><a href="#原因3" class="header-anchor">#</a> <strong>原因3</strong></h3> <p>在 <code>nc</code> 中，回车键通常被解释为换行字符（<code>\n</code>），而在 <code>telnet</code> 中，回车键通常被解释为回车和换行字符的组合（<code>\r\n</code>）。</p> <h3 id="最后解决办法"><a href="#最后解决办法" class="header-anchor">#</a> 最后解决办法</h3> <p>利用telnet连接，输完数字后直接回车，这样能被识别成<code>\r\n</code></p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/smileatl/smileatlRepository_source/edit/master/docs/25.项目/10.mynetlib/200.面经/05.mynetlib题目.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/12/04, 16:45:12</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/b39f8b/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">MySQL数据库连接池</div></a> <a href="/pages/b33016/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">README</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/b39f8b/" class="prev">MySQL数据库连接池</a></span> <span class="next"><a href="/pages/b33016/">README</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/93a902/"><div>
            cpp新特性
            <!----></div></a> <span class="date">12-04</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/163c8a/"><div>
            复刷还是没记住的题
            <!----></div></a> <span class="date">12-04</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/2aa569/"><div>
            计算机网络
            <!----></div></a> <span class="date">12-04</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1355484300@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/smileatl" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span>smileatl | <a href="https://github.com/smileatl/smileatlRepository_source/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4813674f.js" defer></script><script src="/assets/js/3.cf27d530.js" defer></script><script src="/assets/js/189.45442618.js" defer></script>
  </body>
</html>
