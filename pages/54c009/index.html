<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>myC++ | SAL Repo</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/website_icon.png">
    <meta name="description" content="smileatl个人知识库，用于工作、学习、生活的总结。">
    <meta name="keywords" content="smileatl个人知识库，用于工作、学习、生活的总结。">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.27efc831.css" as="style"><link rel="preload" href="/assets/js/app.4813674f.js" as="script"><link rel="preload" href="/assets/js/3.cf27d530.js" as="script"><link rel="preload" href="/assets/js/41.2cd990a4.js" as="script"><link rel="prefetch" href="/assets/js/10.57c72187.js"><link rel="prefetch" href="/assets/js/100.76551019.js"><link rel="prefetch" href="/assets/js/101.909b1f6a.js"><link rel="prefetch" href="/assets/js/102.b4df429c.js"><link rel="prefetch" href="/assets/js/103.36718b70.js"><link rel="prefetch" href="/assets/js/104.8247d5e5.js"><link rel="prefetch" href="/assets/js/105.ae996141.js"><link rel="prefetch" href="/assets/js/106.664e0ec8.js"><link rel="prefetch" href="/assets/js/107.34387111.js"><link rel="prefetch" href="/assets/js/108.24bd216e.js"><link rel="prefetch" href="/assets/js/109.0ce14ec5.js"><link rel="prefetch" href="/assets/js/11.a6b1ea70.js"><link rel="prefetch" href="/assets/js/110.225cb77d.js"><link rel="prefetch" href="/assets/js/111.987f1649.js"><link rel="prefetch" href="/assets/js/112.804919d1.js"><link rel="prefetch" href="/assets/js/113.61edc8e7.js"><link rel="prefetch" href="/assets/js/114.a2199a4f.js"><link rel="prefetch" href="/assets/js/115.919528ee.js"><link rel="prefetch" href="/assets/js/116.1e165300.js"><link rel="prefetch" href="/assets/js/117.b62cd913.js"><link rel="prefetch" href="/assets/js/118.157a5849.js"><link rel="prefetch" href="/assets/js/119.335bb0f4.js"><link rel="prefetch" href="/assets/js/12.f97190ac.js"><link rel="prefetch" href="/assets/js/120.8ca841a0.js"><link rel="prefetch" href="/assets/js/121.09ef443a.js"><link rel="prefetch" href="/assets/js/122.133de093.js"><link rel="prefetch" href="/assets/js/123.8b5fcdde.js"><link rel="prefetch" href="/assets/js/124.8aef67d0.js"><link rel="prefetch" href="/assets/js/125.07949d7c.js"><link rel="prefetch" href="/assets/js/126.6557ef27.js"><link rel="prefetch" href="/assets/js/127.e2c838f8.js"><link rel="prefetch" href="/assets/js/128.e876bdf8.js"><link rel="prefetch" href="/assets/js/129.0e7d15bb.js"><link rel="prefetch" href="/assets/js/13.ae62b090.js"><link rel="prefetch" href="/assets/js/130.8caf4288.js"><link rel="prefetch" href="/assets/js/131.d091a5f7.js"><link rel="prefetch" href="/assets/js/132.3af86ba2.js"><link rel="prefetch" href="/assets/js/133.9b473677.js"><link rel="prefetch" href="/assets/js/134.d09f520d.js"><link rel="prefetch" href="/assets/js/135.5094d6c6.js"><link rel="prefetch" href="/assets/js/136.f554265c.js"><link rel="prefetch" href="/assets/js/137.db8ad307.js"><link rel="prefetch" href="/assets/js/138.97a9f7dc.js"><link rel="prefetch" href="/assets/js/139.28a187da.js"><link rel="prefetch" href="/assets/js/14.7c89dfed.js"><link rel="prefetch" href="/assets/js/140.58f327a0.js"><link rel="prefetch" href="/assets/js/141.dac9c32e.js"><link rel="prefetch" href="/assets/js/142.15e4cd8a.js"><link rel="prefetch" href="/assets/js/143.29bcf51a.js"><link rel="prefetch" href="/assets/js/144.93e792a5.js"><link rel="prefetch" href="/assets/js/145.1e479d7f.js"><link rel="prefetch" href="/assets/js/146.fef6b20d.js"><link rel="prefetch" href="/assets/js/147.a8939180.js"><link rel="prefetch" href="/assets/js/148.73ab52d1.js"><link rel="prefetch" href="/assets/js/149.de7d77b9.js"><link rel="prefetch" href="/assets/js/15.4266d5a5.js"><link rel="prefetch" href="/assets/js/150.14cd4f5b.js"><link rel="prefetch" href="/assets/js/151.ae320b72.js"><link rel="prefetch" href="/assets/js/152.9f70308b.js"><link rel="prefetch" href="/assets/js/153.8bb08923.js"><link rel="prefetch" href="/assets/js/154.bef6a0fb.js"><link rel="prefetch" href="/assets/js/155.e0e21ff7.js"><link rel="prefetch" href="/assets/js/156.e212e95d.js"><link rel="prefetch" href="/assets/js/157.9af3323d.js"><link rel="prefetch" href="/assets/js/158.a6990b68.js"><link rel="prefetch" href="/assets/js/159.9921842e.js"><link rel="prefetch" href="/assets/js/16.4d11e9b4.js"><link rel="prefetch" href="/assets/js/160.cb690287.js"><link rel="prefetch" href="/assets/js/161.10ec68a7.js"><link rel="prefetch" href="/assets/js/162.5e2e8da5.js"><link rel="prefetch" href="/assets/js/163.7ad3dc89.js"><link rel="prefetch" href="/assets/js/164.0677e91f.js"><link rel="prefetch" href="/assets/js/165.eabba413.js"><link rel="prefetch" href="/assets/js/166.de181132.js"><link rel="prefetch" href="/assets/js/167.eb1f2c20.js"><link rel="prefetch" href="/assets/js/168.33870baa.js"><link rel="prefetch" href="/assets/js/169.0eb4e75c.js"><link rel="prefetch" href="/assets/js/17.2f17b760.js"><link rel="prefetch" href="/assets/js/170.6a8f837b.js"><link rel="prefetch" href="/assets/js/171.33c99890.js"><link rel="prefetch" href="/assets/js/172.e2ac6d6c.js"><link rel="prefetch" href="/assets/js/173.f37baa2e.js"><link rel="prefetch" href="/assets/js/174.3f1765d5.js"><link rel="prefetch" href="/assets/js/175.ee3e624a.js"><link rel="prefetch" href="/assets/js/176.b7c3d2ba.js"><link rel="prefetch" href="/assets/js/177.538dbd98.js"><link rel="prefetch" href="/assets/js/178.688b2ab3.js"><link rel="prefetch" href="/assets/js/179.7605eb3a.js"><link rel="prefetch" href="/assets/js/18.46454e6b.js"><link rel="prefetch" href="/assets/js/180.f734c479.js"><link rel="prefetch" href="/assets/js/181.f009bfc4.js"><link rel="prefetch" href="/assets/js/182.51a8e6fc.js"><link rel="prefetch" href="/assets/js/183.0f688ed3.js"><link rel="prefetch" href="/assets/js/184.e20ab6d5.js"><link rel="prefetch" href="/assets/js/185.336035f1.js"><link rel="prefetch" href="/assets/js/186.e7f18b72.js"><link rel="prefetch" href="/assets/js/187.20bae185.js"><link rel="prefetch" href="/assets/js/188.4d746641.js"><link rel="prefetch" href="/assets/js/189.45442618.js"><link rel="prefetch" href="/assets/js/19.07e2632b.js"><link rel="prefetch" href="/assets/js/190.6f6c4889.js"><link rel="prefetch" href="/assets/js/191.b73399a8.js"><link rel="prefetch" href="/assets/js/192.657f63ce.js"><link rel="prefetch" href="/assets/js/193.348754cf.js"><link rel="prefetch" href="/assets/js/194.7ea4e875.js"><link rel="prefetch" href="/assets/js/195.011c9aaa.js"><link rel="prefetch" href="/assets/js/196.30ca323d.js"><link rel="prefetch" href="/assets/js/197.b404290d.js"><link rel="prefetch" href="/assets/js/198.19eeb699.js"><link rel="prefetch" href="/assets/js/199.578524cd.js"><link rel="prefetch" href="/assets/js/20.e8632e9e.js"><link rel="prefetch" href="/assets/js/200.2483c16f.js"><link rel="prefetch" href="/assets/js/201.80be911a.js"><link rel="prefetch" href="/assets/js/202.6292d716.js"><link rel="prefetch" href="/assets/js/203.0423f992.js"><link rel="prefetch" href="/assets/js/204.220cf5d5.js"><link rel="prefetch" href="/assets/js/205.cf88ea69.js"><link rel="prefetch" href="/assets/js/206.7837a407.js"><link rel="prefetch" href="/assets/js/207.15eb7f61.js"><link rel="prefetch" href="/assets/js/208.c92b54ae.js"><link rel="prefetch" href="/assets/js/209.d6858997.js"><link rel="prefetch" href="/assets/js/21.9d97eca0.js"><link rel="prefetch" href="/assets/js/210.3a916b1e.js"><link rel="prefetch" href="/assets/js/211.99ca202d.js"><link rel="prefetch" href="/assets/js/212.18a13454.js"><link rel="prefetch" href="/assets/js/213.7eb5f7fd.js"><link rel="prefetch" href="/assets/js/214.178507b3.js"><link rel="prefetch" href="/assets/js/215.e9eac7bd.js"><link rel="prefetch" href="/assets/js/216.bdd656c6.js"><link rel="prefetch" href="/assets/js/217.487e6997.js"><link rel="prefetch" href="/assets/js/218.eb54add1.js"><link rel="prefetch" href="/assets/js/219.43da1c82.js"><link rel="prefetch" href="/assets/js/22.ed6e719f.js"><link rel="prefetch" href="/assets/js/220.757359d6.js"><link rel="prefetch" href="/assets/js/221.d58f156a.js"><link rel="prefetch" href="/assets/js/222.99dc1661.js"><link rel="prefetch" href="/assets/js/223.22a61d2b.js"><link rel="prefetch" href="/assets/js/224.514138b9.js"><link rel="prefetch" href="/assets/js/225.fc56b049.js"><link rel="prefetch" href="/assets/js/226.59d64fed.js"><link rel="prefetch" href="/assets/js/227.8841cf23.js"><link rel="prefetch" href="/assets/js/228.f37358c2.js"><link rel="prefetch" href="/assets/js/229.97cb9c4e.js"><link rel="prefetch" href="/assets/js/23.5eccc486.js"><link rel="prefetch" href="/assets/js/230.a16ada6a.js"><link rel="prefetch" href="/assets/js/231.5f761bf3.js"><link rel="prefetch" href="/assets/js/232.76d78495.js"><link rel="prefetch" href="/assets/js/233.162bba41.js"><link rel="prefetch" href="/assets/js/234.a845dfca.js"><link rel="prefetch" href="/assets/js/235.169ff72d.js"><link rel="prefetch" href="/assets/js/236.c50d9ecf.js"><link rel="prefetch" href="/assets/js/237.594eecee.js"><link rel="prefetch" href="/assets/js/238.b599dae8.js"><link rel="prefetch" href="/assets/js/239.7be81ebe.js"><link rel="prefetch" href="/assets/js/24.c81753d3.js"><link rel="prefetch" href="/assets/js/240.b9f18f9e.js"><link rel="prefetch" href="/assets/js/241.77d17f60.js"><link rel="prefetch" href="/assets/js/242.0894cddd.js"><link rel="prefetch" href="/assets/js/243.4c71e0af.js"><link rel="prefetch" href="/assets/js/244.47579b9c.js"><link rel="prefetch" href="/assets/js/245.29344e11.js"><link rel="prefetch" href="/assets/js/246.410a1027.js"><link rel="prefetch" href="/assets/js/247.b22fa817.js"><link rel="prefetch" href="/assets/js/25.f3141c92.js"><link rel="prefetch" href="/assets/js/26.573fd0de.js"><link rel="prefetch" href="/assets/js/27.9a72220d.js"><link rel="prefetch" href="/assets/js/28.e161668a.js"><link rel="prefetch" href="/assets/js/29.6d2ef014.js"><link rel="prefetch" href="/assets/js/30.0dd2ba52.js"><link rel="prefetch" href="/assets/js/31.e8c4ee1d.js"><link rel="prefetch" href="/assets/js/32.c57cfa4e.js"><link rel="prefetch" href="/assets/js/33.7c1ec4ff.js"><link rel="prefetch" href="/assets/js/34.110d90ae.js"><link rel="prefetch" href="/assets/js/35.c5fbf1bd.js"><link rel="prefetch" href="/assets/js/36.58d307d9.js"><link rel="prefetch" href="/assets/js/37.6e68d82d.js"><link rel="prefetch" href="/assets/js/38.0a2bfb96.js"><link rel="prefetch" href="/assets/js/39.79a25586.js"><link rel="prefetch" href="/assets/js/4.10092391.js"><link rel="prefetch" href="/assets/js/40.1b3fb2c7.js"><link rel="prefetch" href="/assets/js/42.3803a3ba.js"><link rel="prefetch" href="/assets/js/43.56cde0b8.js"><link rel="prefetch" href="/assets/js/44.98f12e35.js"><link rel="prefetch" href="/assets/js/45.bbed8377.js"><link rel="prefetch" href="/assets/js/46.80af516b.js"><link rel="prefetch" href="/assets/js/47.bfe18f20.js"><link rel="prefetch" href="/assets/js/48.e4bead99.js"><link rel="prefetch" href="/assets/js/49.da1a7c67.js"><link rel="prefetch" href="/assets/js/5.0b5a1289.js"><link rel="prefetch" href="/assets/js/50.b6011d95.js"><link rel="prefetch" href="/assets/js/51.81adcdd5.js"><link rel="prefetch" href="/assets/js/52.b650e175.js"><link rel="prefetch" href="/assets/js/53.22c44460.js"><link rel="prefetch" href="/assets/js/54.3c9964c8.js"><link rel="prefetch" href="/assets/js/55.80bec639.js"><link rel="prefetch" href="/assets/js/56.2066f85f.js"><link rel="prefetch" href="/assets/js/57.ab6dbc19.js"><link rel="prefetch" href="/assets/js/58.6236e7f0.js"><link rel="prefetch" href="/assets/js/59.618e25d3.js"><link rel="prefetch" href="/assets/js/6.a1e90b5b.js"><link rel="prefetch" href="/assets/js/60.3deac196.js"><link rel="prefetch" href="/assets/js/61.890283e9.js"><link rel="prefetch" href="/assets/js/62.ffe465e9.js"><link rel="prefetch" href="/assets/js/63.cc9a42cc.js"><link rel="prefetch" href="/assets/js/64.c66e6c4f.js"><link rel="prefetch" href="/assets/js/65.95e3ddfd.js"><link rel="prefetch" href="/assets/js/66.256b023f.js"><link rel="prefetch" href="/assets/js/67.436df8a0.js"><link rel="prefetch" href="/assets/js/68.d532ffa8.js"><link rel="prefetch" href="/assets/js/69.963c3596.js"><link rel="prefetch" href="/assets/js/7.74944cf6.js"><link rel="prefetch" href="/assets/js/70.6dfd1704.js"><link rel="prefetch" href="/assets/js/71.53af90e0.js"><link rel="prefetch" href="/assets/js/72.580797e8.js"><link rel="prefetch" href="/assets/js/73.5c14d158.js"><link rel="prefetch" href="/assets/js/74.70cf381f.js"><link rel="prefetch" href="/assets/js/75.01dbab82.js"><link rel="prefetch" href="/assets/js/76.18b48db2.js"><link rel="prefetch" href="/assets/js/77.0fa8965d.js"><link rel="prefetch" href="/assets/js/78.bede6ca6.js"><link rel="prefetch" href="/assets/js/79.1c7c8167.js"><link rel="prefetch" href="/assets/js/8.fbc0181a.js"><link rel="prefetch" href="/assets/js/80.688d4c3b.js"><link rel="prefetch" href="/assets/js/81.4eaaee90.js"><link rel="prefetch" href="/assets/js/82.53bf5bf4.js"><link rel="prefetch" href="/assets/js/83.53cdee38.js"><link rel="prefetch" href="/assets/js/84.848d09d8.js"><link rel="prefetch" href="/assets/js/85.4ef416fa.js"><link rel="prefetch" href="/assets/js/86.559b9784.js"><link rel="prefetch" href="/assets/js/87.1317f521.js"><link rel="prefetch" href="/assets/js/88.61e1f1fa.js"><link rel="prefetch" href="/assets/js/89.c37979bc.js"><link rel="prefetch" href="/assets/js/9.acdf956e.js"><link rel="prefetch" href="/assets/js/90.329e7956.js"><link rel="prefetch" href="/assets/js/91.e9246182.js"><link rel="prefetch" href="/assets/js/92.41e1ecaf.js"><link rel="prefetch" href="/assets/js/93.6cbe0205.js"><link rel="prefetch" href="/assets/js/94.922231b5.js"><link rel="prefetch" href="/assets/js/95.23cfae7c.js"><link rel="prefetch" href="/assets/js/96.790a39b9.js"><link rel="prefetch" href="/assets/js/97.8ce2cb69.js"><link rel="prefetch" href="/assets/js/98.f016d83e.js"><link rel="prefetch" href="/assets/js/99.b1d81562.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.96cada6e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.27efc831.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/website_icon.png" alt="SAL Repo" class="logo"> <span class="site-name can-hide">SAL Repo</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工作" class="dropdown-title"><a href="/work/" class="link-title">工作</a> <span class="title" style="display:none;">工作</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>编程语言</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/C/" class="nav-link">C</a></li><li class="dropdown-subitem"><a href="/work/C++/" class="nav-link">C++</a></li><li class="dropdown-subitem"><a href="/work/Script_Language/" class="nav-link">Script_Language</a></li></ul></li><li class="dropdown-item"><h4>计算机知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Linux/" class="nav-link">Linux</a></li><li class="dropdown-subitem"><a href="/work/dataStruct/" class="nav-link">数据机构与算法</a></li><li class="dropdown-subitem"><a href="/work/OS/" class="nav-link">操作系统</a></li><li class="dropdown-subitem"><a href="/work/network/" class="nav-link">计算机网络</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/MySQL/" class="nav-link">MySQL</a></li><li class="dropdown-subitem"><a href="/work/Redis/" class="nav-link">Redis</a></li></ul></li><li class="dropdown-item"><h4>工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Git/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/work/VM/" class="nav-link">虚拟机</a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/leetcode/" class="nav-link">刷题</a></li><li class="dropdown-subitem"><a href="/work/bg/" class="nav-link">interview</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/project/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/mynetlib/" class="nav-link">mynetlib</a></li><li class="dropdown-item"><!----> <a href="/project/mymprpc/" class="nav-link">mymprpc</a></li><li class="dropdown-item"><!----> <a href="/project/mytinystl/" class="nav-link">mytinystl</a></li><li class="dropdown-item"><!----> <a href="/project/DML/" class="nav-link">DML</a></li><li class="dropdown-item"><!----> <a href="/project/FL/" class="nav-link">FL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学习" class="dropdown-title"><a href="/study/" class="link-title">学习</a> <span class="title" style="display:none;">学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>研究生</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/publications/" class="nav-link">publications</a></li><li class="dropdown-subitem"><a href="/study/ML/" class="nav-link">机器学习</a></li></ul></li><li class="dropdown-item"><h4>阅读</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/read/" class="nav-link">个人摘抄</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="生活" class="dropdown-title"><a href="/life/" class="link-title">生活</a> <span class="title" style="display:none;">生活</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/71024e/" class="nav-link">生活</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/collection/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>总览</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/collection/favorites/" class="nav-link">个人收藏夹</a></li><li class="dropdown-subitem"><a href="/collection/download/" class="nav-link">资源下载</a></li></ul></li><li class="dropdown-item"><h4>快速链接</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://sci-hub.wf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SCI-HUB
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/collection/favorites/#文件转换、解密工具" class="nav-link">文件转换、解密工具</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>索引</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-subitem"><a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-subitem"><a href="/archives/" class="nav-link">归档</a></li></ul></li><li class="dropdown-item"><h4>友链</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/friends/" class="nav-link">友情链接</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <a href="https://github.com/smileatl/smileatlRepository_source" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatar.jpg"> <div class="blogger-info"><h3>smileatl</h3> <span>smileatl, Songlei Lin</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工作" class="dropdown-title"><a href="/work/" class="link-title">工作</a> <span class="title" style="display:none;">工作</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>编程语言</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/C/" class="nav-link">C</a></li><li class="dropdown-subitem"><a href="/work/C++/" class="nav-link">C++</a></li><li class="dropdown-subitem"><a href="/work/Script_Language/" class="nav-link">Script_Language</a></li></ul></li><li class="dropdown-item"><h4>计算机知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Linux/" class="nav-link">Linux</a></li><li class="dropdown-subitem"><a href="/work/dataStruct/" class="nav-link">数据机构与算法</a></li><li class="dropdown-subitem"><a href="/work/OS/" class="nav-link">操作系统</a></li><li class="dropdown-subitem"><a href="/work/network/" class="nav-link">计算机网络</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/MySQL/" class="nav-link">MySQL</a></li><li class="dropdown-subitem"><a href="/work/Redis/" class="nav-link">Redis</a></li></ul></li><li class="dropdown-item"><h4>工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Git/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/work/VM/" class="nav-link">虚拟机</a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/leetcode/" class="nav-link">刷题</a></li><li class="dropdown-subitem"><a href="/work/bg/" class="nav-link">interview</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/project/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/mynetlib/" class="nav-link">mynetlib</a></li><li class="dropdown-item"><!----> <a href="/project/mymprpc/" class="nav-link">mymprpc</a></li><li class="dropdown-item"><!----> <a href="/project/mytinystl/" class="nav-link">mytinystl</a></li><li class="dropdown-item"><!----> <a href="/project/DML/" class="nav-link">DML</a></li><li class="dropdown-item"><!----> <a href="/project/FL/" class="nav-link">FL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学习" class="dropdown-title"><a href="/study/" class="link-title">学习</a> <span class="title" style="display:none;">学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>研究生</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/publications/" class="nav-link">publications</a></li><li class="dropdown-subitem"><a href="/study/ML/" class="nav-link">机器学习</a></li></ul></li><li class="dropdown-item"><h4>阅读</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/read/" class="nav-link">个人摘抄</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="生活" class="dropdown-title"><a href="/life/" class="link-title">生活</a> <span class="title" style="display:none;">生活</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/71024e/" class="nav-link">生活</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/collection/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>总览</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/collection/favorites/" class="nav-link">个人收藏夹</a></li><li class="dropdown-subitem"><a href="/collection/download/" class="nav-link">资源下载</a></li></ul></li><li class="dropdown-item"><h4>快速链接</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://sci-hub.wf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SCI-HUB
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/collection/favorites/#文件转换、解密工具" class="nav-link">文件转换、解密工具</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>索引</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-subitem"><a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-subitem"><a href="/archives/" class="nav-link">归档</a></li></ul></li><li class="dropdown-item"><h4>友链</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/friends/" class="nav-link">友情链接</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <a href="https://github.com/smileatl/smileatlRepository_source" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言-C</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>编程语言-C++</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>C++初识</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/8efc8e/" class="sidebar-link">C++基础入门</a></li><li><a href="/pages/31b836/" class="sidebar-link">C++核心编程</a></li><li><a href="/pages/8cd9f7/" class="sidebar-link">C++提高编程</a></li><li><a href="/pages/54c009/" aria-current="page" class="active sidebar-link">myC++</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/54c009/#自己的知识点" class="sidebar-link">自己的知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/54c009/#引用" class="sidebar-link">引用</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#new-delete" class="sidebar-link">new , delete</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#指针" class="sidebar-link">指针</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#指针与常量" class="sidebar-link">指针与常量</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#指针函数与函数指针" class="sidebar-link">指针函数与函数指针</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#指向指针的引用" class="sidebar-link">指向指针的引用</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#字符串" class="sidebar-link">字符串</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#关键字" class="sidebar-link">关键字</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#auto" class="sidebar-link">auto</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#constexpr" class="sidebar-link">constexpr</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#explict" class="sidebar-link">explict</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#extern" class="sidebar-link">extern</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#final" class="sidebar-link">final</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#friend" class="sidebar-link">friend</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#inline" class="sidebar-link">inline</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#mutable" class="sidebar-link">mutable</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#namespace" class="sidebar-link">namespace</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#noexcept" class="sidebar-link">noexcept</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#override" class="sidebar-link">override</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#static" class="sidebar-link">static</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#static-assert" class="sidebar-link">static_assert</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#typename" class="sidebar-link">typename</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#typedef、using、typename" class="sidebar-link">typedef、using、typename</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#volatile" class="sidebar-link">volatile</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#thread" class="sidebar-link">__thread</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#内置函数" class="sidebar-link">内置函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#builtin-expect" class="sidebar-link">_builtinexpect</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#编程注意点" class="sidebar-link">编程注意点</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#优先队列和sort中的不同点" class="sidebar-link">优先队列和sort中的不同点</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#其他知识点" class="sidebar-link">其他知识点</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#为什么有的时候指针delete后还需要赋值nullptr" class="sidebar-link">为什么有的时候指针delete后还需要赋值nullptr</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#int-main为什么可以不用return" class="sidebar-link">int main为什么可以不用return</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-lock-guard-std-mutex-lock-m-mutex" class="sidebar-link">std::lockguard&lt;std::mutex\&gt; lock(mmutex);</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#匿名对象" class="sidebar-link">匿名对象</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-lock-guard" class="sidebar-link">std::lock_guard</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#boost-check" class="sidebar-link">BOOST_CHECK</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-move" class="sidebar-link">std::move</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-atomic" class="sidebar-link">std::atomic</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-any" class="sidebar-link">std::any</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-function" class="sidebar-link">std::function</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-bind" class="sidebar-link">std::bind</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-atomic-int" class="sidebar-link">std::atomic_int</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#syscall-sys-gettid" class="sidebar-link">syscall(SYS_gettid)</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#linux下-usr-local-include、-usr-local-lib和-usr-include、-usr-lib的区别" class="sidebar-link">linux下/usr/local/include、/usr/local/lib和/usr/include、/usr/lib的区别</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#builtin-expect-2" class="sidebar-link">_builtinexpect</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#类里纯虚函数" class="sidebar-link">类里纯虚函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#虚析构函数" class="sidebar-link">虚析构函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-weak-ptr" class="sidebar-link">std::weak_ptr</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#变量名命名加" class="sidebar-link">变量名命名加_</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#变量作用域" class="sidebar-link">变量作用域</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#c-绑定器" class="sidebar-link">C++绑定器</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#c-str" class="sidebar-link">.c_str()</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#函数对象和函数" class="sidebar-link">函数对象和函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#std-is-trivially-destructible" class="sidebar-link">std::istriviallydestructible</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#trivial-destructor平凡析构函数" class="sidebar-link">trivial destructor平凡析构函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#内存地址是按字节进行编码的" class="sidebar-link">内存地址是按字节进行编码的</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#c-函数什么时候传入参数用" class="sidebar-link">C++函数什么时候传入参数用&amp;</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#c-中return和exit" class="sidebar-link">C++中return和exit</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#静态static" class="sidebar-link">静态static</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#c-和java" class="sidebar-link">C++和java</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#多个main问题" class="sidebar-link">多个main问题</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#c-类模板的声明和定义要放在同一个-h头文件" class="sidebar-link">C++类模板的声明和定义要放在同一个.h头文件</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#常量引用和引用引用" class="sidebar-link">常量引用和引用引用</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#指针指针" class="sidebar-link">指针指针</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#结构体里的静态函数" class="sidebar-link">结构体里的静态函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#stl中的配接器和配置器的区别" class="sidebar-link">STL中的配接器和配置器的区别</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#c-iostream" class="sidebar-link">C++ iostream</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#stl中函数对象和算法的区别" class="sidebar-link">STL中函数对象和算法的区别</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#null和nullptr的区别" class="sidebar-link">NULL和nullptr的区别</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#c-的for循环中-i和i-的区别" class="sidebar-link">C++的for循环中++i和i++的区别：</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#无穷大与无穷小" class="sidebar-link">无穷大与无穷小</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#template" class="sidebar-link">template</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#iterator-type-base-const" class="sidebar-link">iterator_type base() const</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#证同函数" class="sidebar-link">证同函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#const-cast" class="sidebar-link">const_cast</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#reinterpret-cast" class="sidebar-link">reinterpret_cast</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#remove-const" class="sidebar-link">remove_const</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#可变参数模板" class="sidebar-link">可变参数模板</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#左值和右值" class="sidebar-link">左值和右值</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#左值引用和右值引用" class="sidebar-link">左值引用和右值引用</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#右值引用" class="sidebar-link">右值引用&amp;&amp;</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#static-cast" class="sidebar-link">static_cast</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#什么时候用const-cast和什么时候用static-cast" class="sidebar-link">什么时候用constcast和什么时候用staticcast</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#assert" class="sidebar-link">assert</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#cin" class="sidebar-link">cin</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#cin-get" class="sidebar-link">cin.get()</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#const" class="sidebar-link">const &amp;</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#闭包" class="sidebar-link">闭包</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/54c009/#错误" class="sidebar-link">错误</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/pages/54c009/#编译的时候std-any能找到没出错-但是vscode里编辑时找不到std-any" class="sidebar-link">编译的时候std::any能找到没出错，但是vscode里编辑时找不到std::any</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/54c009/#常用实例" class="sidebar-link">常用实例</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/54c009/#_1、函数与库的对应" class="sidebar-link">1、函数与库的对应</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#_2、常用操作" class="sidebar-link">2、常用操作</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#_3、数组" class="sidebar-link">3、数组</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#动态创建数组并输出" class="sidebar-link">动态创建数组并输出</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#_4、vector" class="sidebar-link">4、vector</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#vector创建不定长的一组数据" class="sidebar-link">vector创建不定长的一组数据</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#手动创建vector容器嵌套容器" class="sidebar-link">手动创建vector容器嵌套容器</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#vector容器打印" class="sidebar-link">vector容器打印</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#vector容器嵌套容器的打印" class="sidebar-link">vector容器嵌套容器的打印</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#求容器中的最大最小值" class="sidebar-link">求容器中的最大最小值</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#_5、字符串" class="sidebar-link">5、字符串</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#输入一个不带空格的字符串" class="sidebar-link">输入一个不带空格的字符串</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#输入一个带空格的字符串" class="sidebar-link">输入一个带空格的字符串</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#常用函数" class="sidebar-link">常用函数</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#_6、链表" class="sidebar-link">6、链表</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#尾插法创建不定长的单向链表-带头结点" class="sidebar-link">尾插法创建不定长的单向链表（带头结点）</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#尾插法创建不定长的单向链表-不带头结点" class="sidebar-link">尾插法创建不定长的单向链表（不带头结点）</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#输出链表元素-带头结点" class="sidebar-link">输出链表元素（带头结点）</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#输出链表元素-不带头结点" class="sidebar-link">输出链表元素（不带头结点）</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#_7、树" class="sidebar-link">7、树</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#根据数组-层次法创建二叉树" class="sidebar-link">根据数组，层次法创建二叉树</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#二叉树的遍历-并输出" class="sidebar-link">二叉树的遍历，并输出</a></li><li class="sidebar-sub-header level3"><a href="/pages/54c009/#数学" class="sidebar-link">数学</a></li><li class="sidebar-sub-header level4"><a href="/pages/54c009/#公倍数与公因数" class="sidebar-link">公倍数与公因数</a></li></ul></li></ul></li><li><a href="/pages/10526c/" class="sidebar-link">STL</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言-Script_Language</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机知识-Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机知识-数据结构与算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机知识-操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机知识-计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库-MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库-Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具-Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具-虚拟机</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他-刷题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他-interview</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/work/#工作" data-v-06225672>工作</a></li><li data-v-06225672><a href="/work/#编程语言-C++" data-v-06225672>编程语言-C++</a></li><li data-v-06225672><a href="/work/#C++初识" data-v-06225672>C++初识</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/smileatl" target="_blank" title="作者" class="beLink" data-v-06225672>smileatl</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-12-04</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">myC++<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="myc"><a href="#myc" class="header-anchor">#</a> myC++</h1> <h2 id="自己的知识点"><a href="#自己的知识点" class="header-anchor">#</a> 自己的知识点</h2> <p>返回值不可以作为重载的区分</p> <h3 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h3> <p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p> <p><font color="red">指针常量：指针的指向不可修改，指针指向的值是可以改变的</font></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//发现是引用，转换为 int* const ref = &amp;a;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> ref<span class="token punctuation">)</span><span class="token punctuation">{</span>
	ref <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// ref是引用，转换为*ref = 100</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    
    <span class="token comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ref <span class="token operator">=</span> a<span class="token punctuation">;</span> 
	ref <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span>
    
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;a:&quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ref:&quot;</span> <span class="token operator">&lt;&lt;</span> ref <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
	<span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><img src="/assets/1663253977101.png" alt="1663253977101"></p> <h3 id="new-delete"><a href="#new-delete" class="header-anchor">#</a> new , delete</h3> <p>堆区程序员手动开辟，也需要手动释放，不delete掉的话会造成内存泄漏</p> <p>利用new创建的数据，会返回该数据对应的类型的指针</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//利用new关键字  可以将数据开辟到堆区</span>
<span class="token comment">//利用new创建的数据，会返回该数据对应的类型的指针</span>
<span class="token comment">//指针  本质也是局部变量，放在栈区，指针保存的数据是放在堆区</span>
<span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//释放</span>
<span class="token keyword">delete</span> a<span class="token punctuation">;</span>

<span class="token comment">//释放数组 delete 后加 []</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>指针：本质也是局部变量，放在栈区
指针保存的数据放在堆区</p> <p>当我们使用未初始化内存的指针时：
会导致程序无法进行，因为指针并没有指向一个合法的地址，这时候其内部存的只是一些乱码，所以在调用函数时，会使用乱码所指的内存，指针根本就无权访问，导致出错。
解决办法：new 为指针动态分配内存，之后再用delete将其释放</p> <p>容器中*it是什么是</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//*it就是int</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="指针"><a href="#指针" class="header-anchor">#</a> 指针</h3> <h4 id="指针与常量"><a href="#指针与常量" class="header-anchor">#</a> 指针与常量</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">//指针可以被修改，值也可以被修改</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">//指针可以被修改，值不可以被修改（const int），常量指针</span>
<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">//指针不可以被修改（* const），值可以被修改，指针常量</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">//指针不可以被修改，值也不可以被修改</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="指针函数与函数指针"><a href="#指针函数与函数指针" class="header-anchor">#</a> 指针函数与函数指针</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// addition是指针函数，一个返回类型是指针的函数</span>
<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">addition</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span><span class="token operator">*</span> sum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">subtraction</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span><span class="token operator">*</span> m <span class="token operator">=</span> <span class="token function">addition</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// minus是函数指针，指向函数的指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>minus<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> subtraction<span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">*</span>m<span class="token punctuation">,</span> minus<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="指向指针的引用"><a href="#指向指针的引用" class="header-anchor">#</a> 指向指针的引用</h4> <p>在函数调用时用指针或者引用做参数，表示把变量的地址传递给子函数，
但是子函数只能修改指针所指变量的值，并不能修改指针的指向。</p> <p><mark>如果想要修改指针的指向，就要用指针的指针，或者指针的引用</mark></p> <h3 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string s<span class="token punctuation">;</span> <span class="token comment">// 字符串</span>
s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 字符串中取出来单个字符还是字符串</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h3> <h4 id="auto"><a href="#auto" class="header-anchor">#</a> auto</h4> <p>就是根据后面的值，来自己推测前面的类型是什么。
作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替。
用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错）</p> <h4 id="constexpr"><a href="#constexpr" class="header-anchor">#</a> constexpr</h4> <p><code>constexpr</code> 是 C++11 引入的一个关键字，用于声明在编译时可以计算出结果的表达式或函数。使用 <code>constexpr</code> 声明的表达式或函数在编译时就会被计算出结果，而不是在程序运行时才计算。这样可以提高程序的性能和效率。</p> <p><code>constexpr</code> 可以用于声明变量、函数和类成员函数。对于变量，使用 <code>constexpr</code> 声明的变量必须在编译时就能确定其值。对于函数，使用 <code>constexpr</code> 声明的函数必须能在编译时就能计算出结果。对于类成员函数，使用 <code>constexpr</code> 声明的成员函数必须能在编译时就能计算出结果，并且不能有任何副作用。</p> <p>下面是一个使用 <code>constexpr</code> 声明的函数示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个函数计算一个整数的阶乘，并使用 <code>constexpr</code> 声明，因此可以在编译时就计算出结果。在使用时，可以将其作为常量表达式使用：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x 的值为 120</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// y 的值为 720，在编译时就计算出结果</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>需要注意的是，<code>constexpr</code> 声明的函数必须满足一些限制，比如不能有任何副作用，不能包含循环语句等。</p> <h4 id="explict"><a href="#explict" class="header-anchor">#</a> explict</h4> <p><code>explicit</code> 是 C++ 中的一个关键字，用于修饰构造函数，表示该构造函数只能用于显式地创建对象，而不能隐式地进行类型转换。举个例子，如果有一个类 A，它有一个带有一个参数的构造函数，如果这个构造函数被声明为 <code>explicit</code>，那么就不能像下面这样隐式地进行类型转换：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>A a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 错误，不能隐式地进行类型转换</span>
A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确，可以显式地创建对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果该构造函数没有被声明为 <code>explicit</code>，那么上面的代码就会编译通过，因为编译器会自动把整型转换成类 Anb 的一个对象。<code>explicit</code> 关键字可以避免这种情况的发生，使代码更加明确和安全。</p> <p>C++显式构造是指通过构造函数明确地创建对象，不允许进行隐式转换。这意味着在使用显式构造时，必须使用构造函数来创建对象，不能简单地将其他类型的值赋给该对象。显式构造可以避免一些意外的类型转换，提高代码的可读性和安全性。</p> <h4 id="extern"><a href="#extern" class="header-anchor">#</a> extern</h4> <p>在C++中，<code>extern</code>是一个关键字，用于指示一个变量或函数是在其他文件中定义的。具体来说，如果一个变量或函数被声明为<code>extern</code>，那么编译器将在其他文件中查找该变量或函数的定义。这通常用于在多个源文件中共享变量或函数的定义。例如，如果你在一个源文件中定义了一个全局变量，并且想在另一个源文件中使用该变量，你可以在第二个源文件中使用<code>extern</code>关键字来引用该变量，而不需要重新定义它。</p> <p>例如，假设你在一个源文件中定义了一个全局变量<code>int num = 10;</code>，你可以在另一个源文件中使用<code>extern int num;</code>来引用该变量，而不需要重新定义它。这样，编译器将在其他文件中查找该变量的定义，然后将其链接到你的程序中。</p> <p>注意，<code>extern</code>关键字只是一个声明，它并不会分配内存或定义变量或函数。它只是告诉编译器该变量或函数在其他文件中定义，需要在链接时进行解析。</p> <p>在 C++ 中，<code>extern</code> 是一个关键字，用于在当前文件以外的地方声明一个变量或函数。其作用有以下两个方面：</p> <ol><li><p>声明外部变量：使用 <code>extern</code> 关键字可以在当前文件中声明一个在其他文件中定义的全局变量。这样，在当前文件中就可以使用这个变量，而不需要重新定义一遍。例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// file1.cpp</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

<span class="token comment">// file2.cpp</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;count = &quot;</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在这个例子中，<code>count</code> 变量在 <code>file1.cpp</code> 中被声明为外部变量，然后在 <code>file2.cpp</code> 中被定义为 0。在 <code>main.cpp</code> 中，<code>count</code> 又被声明为外部变量，并被用于输出。</p></li> <li><p>声明外部函数：使用 <code>extern</code> 关键字可以在当前文件中声明一个在其他文件中定义的函数。这样，在当前文件中就可以调用这个函数，而不需要重新定义一遍。</p></li> <li><p><code>extern &quot;C&quot;</code>是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern &quot;C&quot;来说明</p></li></ol> <h4 id="final"><a href="#final" class="header-anchor">#</a> final</h4> <p>在 C++ 中，<code>final</code> 是一个关键字，用于限制类、成员函数或虚函数的继承或覆盖。</p> <ol><li><p><code>final</code> 修饰类：
当一个类被声明为 <code>final</code> 时，表示该类不能被继承。任何试图从该类派生出新类的尝试都将导致编译错误。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token keyword">final</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 错误示例：无法从 final 类派生</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p><code>final</code> 修饰成员函数：
当一个成员函数被声明为 <code>final</code> 时，表示该函数不能被重写（覆盖）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">final</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// 错误示例：无法重写 final 函数</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li> <li><p><code>final</code> 修饰虚函数：
当一个虚函数被声明为 <code>final</code> 时，表示该虚函数不能被子类再次重写（覆盖）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">final</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// 错误示例：无法重写 final 虚函数</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li></ol> <p>使用 <code>final</code> 关键字可以用于防止类被继承、成员函数被重写，或者虚函数在子类中被再次覆盖。这有助于强制执行设计意图，并提高代码的可靠性和可维护性。</p> <h4 id="friend"><a href="#friend" class="header-anchor">#</a> friend</h4> <p>在C++中，<code>friend</code>是一个关键字，用于声明一个函数或类是另一个类的友元。友元可以访问声明它为友元的类的私有成员和保护成员，即使这些成员在其他地方是不可访问的。</p> <p>具体来说，如果一个函数或类被声明为另一个类的友元，那么它就可以访问该类的私有成员和保护成员。这在某些情况下是非常有用的，例如在两个类之间需要共享数据时。但是，友元也可能导致代码的可维护性和安全性降低，因此应该谨慎使用。</p> <p>友元可以声明在类的内部或外部，如果声明在类的内部，它将成为一个成员函数或成员类，如果声明在类的外部，它将成为一个普通函数或类。</p> <p>下面是一个友元函数的例子：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 声明setX为A的友元函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 可以访问A的私有成员x</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个例子中，<code>setX</code>被声明为<code>A</code>的友元函数，因此它可以访问<code>A</code>的私有成员<code>x</code>。注意，<code>setX</code>并不是<code>A</code>的成员函数，因此它不能通过<code>this</code>指针访问<code>A</code>的成员。</p> <h4 id="inline"><a href="#inline" class="header-anchor">#</a> inline</h4> <p><code>inline</code> 是一个关键字，用于向编译器提供函数内联展开的建议。当函数被声明为 <code>inline</code> 时，编译器可以将函数的代码插入到调用该函数的地方，而不是通过函数调用的方式执行。这样可以减少函数调用的开销，提高代码的执行效率。</p> <p>使用 <code>inline</code> 关键字的函数通常是<strong>简短的函数</strong>，函数体内部没有复杂的控制流和大量的代码。这样的函数在被频繁调用时，通过内联展开可以减少函数调用的开销，提高程序的性能。</p> <p>需要注意的是，<code>inline</code> 关键字只是向编译器提供了一个建议，编译器是否真正将函数内联展开取决于编译器的实现和优化策略。编译器可能会根据函数的复杂性、调用频率等因素来决定是否进行内联展开。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>在代码示例中，`inline int tid()` 表示将 `tid` 函数声明为内联函数。这意味着编译器可以选择将 `tid` 函数的代码插入到调用 `tid` 函数的地方，而不是通过函数调用的方式执行。这样可以避免函数调用的开销，提高获取线程 ID 的效率。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="mutable"><a href="#mutable" class="header-anchor">#</a> mutable</h4> <p>在 C++ 中，<code>mutable</code> 是一个关键字，用于修饰类的成员变量。当一个成员变量被声明为 <code>mutable</code> 时，表示该成员变量可以在 const 成员函数中修改。</p> <p>通常情况下，const 成员函数不允许修改类的成员变量，因为 const 成员函数被认为是不会对对象的状态做出任何更改的函数。但有时候，我们可能需要在 const 成员函数中修改某些临时状态或计数器等非关键数据，这时就可以使用 <code>mutable</code> 关键字。</p> <p>以下是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>
  <span class="token keyword">mutable</span> <span class="token keyword">int</span> counter<span class="token punctuation">;</span> <span class="token comment">// 使用 mutable 修饰的可变成员变量</span>

<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    counter<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 在 const 成员函数中修改 mutable 成员变量</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> counter<span class="token punctuation">;</span> <span class="token comment">// 在 const 成员函数中访问 mutable 成员变量</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上述示例中，<code>increment()</code> 是一个 const 成员函数，但由于 <code>counter</code> 被声明为 <code>mutable</code>，它可以在该函数中被递增。而 <code>getCounter()</code> 也是一个 const 成员函数，可以读取 <code>counter</code> 的值。</p> <p>需要注意的是，虽然 <code>mutable</code> 关键字允许在 const 成员函数中修改特定的成员变量，但仍然需要谨慎使用。滥用 <code>mutable</code> 可能会导致代码变得难以理解和维护，因此应该遵循良好的代码设计原则并慎重决定是否使用 <code>mutable</code>。</p> <h4 id="namespace"><a href="#namespace" class="header-anchor">#</a> namespace</h4> <p><code>namespace</code> 是 C++ 中用于避免命名冲突的一种机制。可以将一组相关的函数、类、变量等放在一个命名空间中，从而避免与其他命名空间中的同名实体发生冲突。在 C++ 中，命名空间用 <code>namespace</code> 关键字来定义，语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">namespace</span> namespace_name <span class="token punctuation">{</span>
    <span class="token comment">// 命名空间内的代码</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在命名空间内部定义的变量、函数等只在该命名空间内可见，可以通过 <code>namespace_name::</code> 来访问。例如，假设有一个名为 <code>my_namespace</code> 的命名空间，其中定义了一个名为 <code>my_function</code> 的函数，可以使用以下方式来调用该函数：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>my_namespace<span class="token double-colon punctuation">::</span><span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>此外，还可以使用 <code>using namespace</code> 语句来指定使用哪个命名空间中的实体。例如，以下代码将使用 <code>my_namespace</code> 命名空间中的所有实体：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">using</span> <span class="token keyword">namespace</span> my_namespace<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>需要注意的是，使用 <code>using namespace</code> 语句可能会导致命名冲突，因此应谨慎使用。</p> <h4 id="noexcept"><a href="#noexcept" class="header-anchor">#</a> noexcept</h4> <p><code>noexcept</code> 是 C++11 引入的一个关键字，用于指示一个函数是否会抛出异常。可以在函数声明或定义时使用 <code>noexcept</code> 关键字来指示该函数是否可能抛出异常，例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上述代码中，<code>noexcept</code> 关键字指示函数 <code>func()</code> 不会抛出异常。如果在函数体中抛出了异常，则程序会调用 <code>std::terminate()</code> 来终止程序。</p> <p><code>noexcept</code> 还可以用于模板参数和表达式中，例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token keyword">noexcept</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上述代码中，<code>noexcept</code> 关键字用于模板参数 <code>T</code> 和表达式 <code>std::forward&lt;T&gt;(t)</code>，以指示函数 <code>func()</code> 是否会抛出异常。如果 <code>T</code> 或 <code>std::forward&lt;T&gt;(t)</code> 中包含了可能抛出异常的操作，则 <code>noexcept</code> 的值为 <code>false</code>，否则为 <code>true</code>。</p> <p>使用 <code>noexcept</code> 关键字可以帮助编译器进行优化，提高程序的性能。</p> <h4 id="override"><a href="#override" class="header-anchor">#</a> override</h4> <p>在 C++ 中，<code>override</code> 是一个关键字，用于显式地指示派生类的成员函数覆盖（重写）了基类中的虚函数。</p> <p>当派生类继承自基类并且想要重写基类中的虚函数时，可以使用 <code>override</code> 关键字来提醒编译器检查是否正确地进行了函数的覆盖。这样可以避免一些因拼写错误或函数签名不匹配而导致的错误。</p> <p>以下是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span> <span class="token comment">// 使用 override 关键字，确保正确重写基类的虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上述示例中，<code>Derived</code> 类继承自 <code>Base</code> 类，并重写了基类中的虚函数 <code>foo()</code>。通过在派生类中使用 <code>override</code> 关键字，编译器会检查是否存在与基类虚函数相匹配的函数。如果没有找到匹配的函数，或者函数签名不匹配，编译器将会报错。</p> <p>使用 <code>override</code> 关键字可以增强代码的可读性和可维护性，并帮助捕获常见的重写错误。它是 C++11 引入的特性，但仅在虚函数重写时才需要使用，对于非虚函数没有必要使用 <code>override</code> 关键字。</p> <h4 id="static"><a href="#static" class="header-anchor">#</a> static</h4> <p>C++中的<code>static</code>关键字有多种用法：</p> <ol><li>声明静态变量：在函数内部使用<code>static</code>关键字声明的变量将成为静态变量，其生命周期将与程序的生命周期相同，而不是与函数的生命周期相同。</li> <li>声明静态成员变量：在类中使用<code>static</code>关键字声明的变量将成为静态成员变量，它们属于类而不是属于类的任何实例。静态成员变量在所有类的实例之间共享。</li> <li>声明静态成员函数：在类中使用<code>static</code>关键字声明的函数将成为静态成员函数，它们不属于任何特定的实例，可以直接通过类名调用。</li> <li>声明静态局部变量：在函数内部使用<code>static</code>关键字声明的变量将成为静态局部变量，其生命周期将与程序的生命周期相同，而不是与函数的生命周期相同。静态局部变量只能在声明的函数内部访问。</li></ol> <p>总的来说，<code>static</code>关键字的作用是限制变量或函数的作用域，并且可以使变量或函数在程序的生命周期内保持状态。</p> <h4 id="static-assert"><a href="#static-assert" class="header-anchor">#</a> static_assert</h4> <p><code>static_assert</code> 是 C++11 标准引入的一个关键字，用于在编译期检查表达式是否为真。它的语法形式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">static_assert</span><span class="token punctuation">(</span>expression<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中，<code>expression</code> 是要进行检查的表达式，可以是任意的常量表达式，如果表达式的结果为 false，则编译器会在编译期间产生一条错误信息，并输出 <code>message</code>。<code>message</code> 是可选的，用于指定错误信息的提示消息。</p> <p><code>static_assert</code> 的作用是在编译期间检查程序的正确性，可以避免一些常见的编程错误。例如，可以使用 <code>static_assert</code> 来检查数组的大小是否符合要求，或者检查类型的大小是否满足某些限制。</p> <h4 id="typename"><a href="#typename" class="header-anchor">#</a> typename</h4> <p><code>typename</code> 是 C++ 中的一个关键字，通常用于模板元编程中。在模板中使用类型时，如果该类型依赖于模板参数，则需要使用 <code>typename</code> 关键字来告诉编译器该类型是一个类型而非一个变量或函数。例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>value_type<span class="token operator">*</span> ptr<span class="token punctuation">;</span> <span class="token comment">// T::value_type 是一个依赖于模板参数 T 的类型</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上面的例子中，我们需要使用 <code>typename</code> 关键字来告诉编译器 <code>T::value_type</code> 是一个类型而非一个变量或函数。如果不使用 <code>typename</code>，编译器会将 <code>T::value_type</code> 解释为一个变量或函数，从而导致编译错误。</p> <h4 id="typedef、using、typename"><a href="#typedef、using、typename" class="header-anchor">#</a> typedef、using、typename</h4> <p>不完全正确。在C++中，<code>typename</code> 关键字通常用于指示一个依赖类型（dependent type）。它在模板编程中经常用于告诉编译器某个名称是一个类型而不是一个值或静态成员。</p> <p><code>typename</code> 关键字通常在以下两种情况下使用：</p> <ol><li>在模板中使用嵌套类型时，如果嵌套类型依赖于模板参数，需要使用 <code>typename</code> 来告诉编译器它是一个类型。例如：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>NestedType variable<span class="token punctuation">;</span> <span class="token comment">// 告诉编译器 NestedType 是一个类型</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>在模板特化中引用依赖类型时，也需要使用 <code>typename</code>。例如：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">MyStruct</span> <span class="token punctuation">{</span>
    <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>NestedType member<span class="token punctuation">;</span> <span class="token comment">// 告诉编译器 NestedType 是一个类型</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>注意，<code>typename</code> 并非用于重命名类型的关键字。如果要重命名类型，可以使用 <code>typedef</code> 或 <code>using</code> 关键字。例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">int</span> MyInt<span class="token punctuation">;</span> <span class="token comment">// 将 int 重命名为 MyInt</span>

<span class="token keyword">using</span> MyType <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 将 std::vector&lt;int&gt; 重命名为 MyType</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>总结来说，<code>typename</code> 关键字用于指示依赖类型，而 <code>typedef</code> 或 <code>using</code> 关键字用于重命名类型。</p> <h4 id="volatile"><a href="#volatile" class="header-anchor">#</a> volatile</h4> <p>在 C++ 中，<code>volatile</code> 是一个关键字，用于告诉编译器该变量的值可能会在程序的其他部分被修改，因此编译器不应该对该变量进行优化，例如缓存该变量的值，而应该每次都从内存中读取该变量的值。</p> <p><code>volatile</code> 通常用于多线程编程或者与硬件交互的程序中，因为在这些情况下，变量的值可能会在程序的其他部分被修改，而编译器可能会对变量进行优化，导致程序出现错误。使用 <code>volatile</code> 可以避免这种情况发生。</p> <p>需要注意的是，<code>volatile</code> 并不是线程安全的解决方案，它只是告诉编译器该变量可能会被修改，编译器会相应地生成代码，但是如果多个线程同时修改该变量，仍然需要使用其他的线程安全机制来保证程序的正确性。</p> <h4 id="thread"><a href="#thread" class="header-anchor">#</a> __thread</h4> <p><code>__thread</code> 是一个GCC编译器提供的关键字，用于声明线程局部存储(thread-local storage)的变量。</p> <p>线程局部存储是一种机制，可以使得每个线程都拥有自己独立的变量副本，各个线程之间互不干扰。通常情况下，全局变量和静态变量是所有线程共享的，而使用 <code>__thread</code> 声明的变量则是每个线程独有的。</p> <p>使用 <code>__thread</code> 关键字声明的变量只能是基本数据类型或指针类型，并且其生命周期与所属线程的生命周期相同。每个线程对应的变量副本在线程创建时被初始化，在线程销毁时被销毁。</p> <p>这种线程局部存储的机制在多线程编程中非常有用，可以避免多个线程之间对同一变量的竞争和冲突。常见的应用场景包括线程安全的日志记录、线程特定的缓存等。需要注意的是，<code>__thread</code> 关键字仅在一些特定的编译器中有效，因此在编写跨平台的代码时需谨慎使用。</p> <h3 id="内置函数"><a href="#内置函数" class="header-anchor">#</a> 内置函数</h3> <h4 id="builtin-expect"><a href="#builtin-expect" class="header-anchor">#</a> __builtin_expect</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 使用 __builtin_expect 内置函数来提高条件判断的性能
// __builtin_expect用于给编译器提示条件表达式的预期结果，以便优化生成的代码。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="编程注意点"><a href="#编程注意点" class="header-anchor">#</a> 编程注意点</h3> <h4 id="优先队列和sort中的不同点"><a href="#优先队列和sort中的不同点" class="header-anchor">#</a> 优先队列和sort中的不同点</h4> <ul><li><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;</code>：这行代码创建了一个名为 <code>minHeap</code> 的 <code>std::priority_queue</code>，并使用 <code>std::greater&lt;int&gt;</code> 作为比较函数。在优先队列中，<code>std::greater&lt;int&gt;</code> 会导致元素按照升序排列，因此 <code>minHeap</code> 是一个小顶堆，最小的元素位于队列的顶部。</li> <li><code>sort(res.begin(), res.end(), greater&lt;int&gt;());</code>：这行代码使用 <code>std::greater&lt;int&gt;</code> 作为比较函数来对 <code>res</code> 容器中的元素进行排序。在 <code>std::sort</code> 函数中，<code>std::greater&lt;int&gt;</code> 会导致元素按照降序排列，因此 <code>res</code> 容器的元素将会按照降序排列。</li></ul> <p>总结：</p> <ul><li>对于优先队列 <code>std::priority_queue</code>，<code>std::greater&lt;int&gt;</code> 作为比较函数会导致小顶堆的形式，最小的元素位于堆顶。</li> <li>对于排序函数 <code>std::sort</code>，<code>std::greater&lt;int&gt;</code> 作为比较函数会导致降序排列，最大的元素位于容器的前面。</li></ul> <p>问题的关键在于比较函数的定义和上下文中的使用方式。</p> <ul><li><strong>优先队列中的 <code>std::greater&lt;int&gt;</code></strong>：在优先队列中，<code>std::greater&lt;int&gt;</code> 作为比较函数，会导致元素按照升序排列，因为优先队列的特性是，堆顶元素是最小的。使用 <code>std::greater&lt;int&gt;</code> 作为比较函数确保较小的元素排在前面，创建了一个小顶堆。</li> <li><strong>排序函数中<code>的 std::greater&lt;int&gt;</code></strong>：在排序函数中，<code>std::greater&lt;int&gt;</code> 作为比较函数，会导致元素按照降序排列，因为该比较函数会将较大的元素排在前面，从而实现降序排列。</li></ul> <p>实际上，<code>std::greater&lt;int&gt;</code> 所做的事情是定义了一个“比较规则”，以决定元素之间的相对顺序。在优先队列中，这个比较规则用于确定元素在堆中的排列顺序，而在排序函数中，它用于确定元素在结果序列中的排列顺序。</p> <p>所以，尽管在两个情境中都使用了 <code>std::greater&lt;int&gt;</code>，但是它们在不同的上下文中被用于不同的目的，从而产生了不同的效果。我希望这次的解释能够更加清楚地回答你的问题。如果还有疑惑，请随时继续提问。</p> <h3 id="其他知识点"><a href="#其他知识点" class="header-anchor">#</a> 其他知识点</h3> <h4 id="为什么有的时候指针delete后还需要赋值nullptr"><a href="#为什么有的时候指针delete后还需要赋值nullptr" class="header-anchor">#</a> 为什么有的时候指针delete后还需要赋值nullptr</h4> <p>在 C++ 中，使用 <code>delete</code> 关键字释放动态分配的内存时，被释放的指针仍然保留着之前分配的内存地址。这意味着，即使你已经释放了内存，该指针仍然拥有一个无效的地址，也称为野指针。</p> <p>为了避免在对已释放内存进行误操作时出现问题，通常建议将指针赋值为 <code>nullptr</code>。<code>nullptr</code> 是 C++11 引入的特殊空指针值，表示指针不指向任何有效的对象或函数。</p> <p>通过将指针赋值为 <code>nullptr</code>，你可以在后续引用指针时进行检查，并避免意外地使用已释放的内存。这样做能够增加代码的可读性和可靠性，帮助你更容易地发现并处理潜在的 bug。</p> <p>下面是一个示例，展示了删除指针后赋值为 <code>nullptr</code> 的用法：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 动态分配内存并初始化指针</span>
<span class="token comment">// 使用指针进行一些操作</span>
<span class="token keyword">delete</span> ptr<span class="token punctuation">;</span> <span class="token comment">// 释放内存</span>
ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 将指针赋值为 nullptr</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>注意，将指针赋值为 <code>nullptr</code> 只是一种良好的编程实践，并不是必需的操作。但是在多人协作或复杂的代码中，这样做可以提高代码的可维护性和安全性。</p> <h4 id="int-main为什么可以不用return"><a href="#int-main为什么可以不用return" class="header-anchor">#</a> int main为什么可以不用return</h4> <p>在 C++ 的 <code>main</code> 函数中，可以省略 <code>return</code> 语句，并且默认情况下视为隐含了 <code>return 0;</code>。这是因为 C++ 标准规定，如果 <code>main</code> 函数没有显式指定返回值，则默认返回值为 0，表示程序成功地终止。</p> <p>这种行为是由 C++ 标准定义的一种约定，用于简化编写入口函数的代码。当 <code>main</code> 函数执行完毕时，程序会自动返回 0。这对于绝大多数程序来说是合适的，因为返回 0 通常表示程序正常退出。</p> <p>然而，也可以显式地在 <code>main</code> 函数中使用 <code>return</code> 语句，并提供其他的返回值，以便表示特定的程序状态或错误码。例如，返回一个非零值可能表示程序发生了某种错误或异常情况。</p> <p>总之，在大多数情况下，如果在 <code>main</code> 函数中省略了 <code>return</code> 语句，编译器会自动插入 <code>return 0;</code> 作为默认的返回值。但为了代码的清晰和可读性，建议在 <code>main</code> 函数中显式地使用 <code>return</code> 语句，以明确指定返回值。</p> <h4 id="std-lock-guard-std-mutex-lock-m-mutex"><a href="#std-lock-guard-std-mutex-lock-m-mutex" class="header-anchor">#</a> std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</h4> <p><code>std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</code> 是一个常用的用法，它使用了 C++ 标准库中的 <code>std::lock_guard</code> 类来实现互斥锁的自动上锁和解锁。</p> <p>在这个用法中，<code>m_mutex</code> 是一个 <code>std::mutex</code> 对象，表示一个互斥锁。<code>std::lock_guard</code> 类是一个轻量级的 RAII（资源获取即初始化）封装类，用于管理互斥锁的上锁和解锁。</p> <p>当定义 <code>std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</code> 时，构造函数会被调用，并且自动上锁 <code>m_mutex</code>。在 <code>lock_guard</code> 对象离开作用域时，析构函数会被调用，自动解锁 <code>m_mutex</code>。这样确保了在任何情况下都能正确地进行互斥锁的释放。</p> <p>这种方式可以避免由于异常或代码中的早期返回而导致忘记手动解锁互斥锁的情况，从而更有效地编写线程安全的代码。</p> <p>以下是一个简单示例，展示了如何使用 <code>std::lock_guard</code> 来保护一个临界区：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>mutex m_mutex<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">criticalSection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在这里执行需要保护的临界区代码</span>
    <span class="token comment">// ...</span>

<span class="token punctuation">}</span> <span class="token comment">// lock_guard 的析构函数在这里自动解锁互斥锁</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，<code>criticalSection()</code> 函数定义了一个临界区，在进入临界区之前使用 <code>std::lock_guard</code> 对 <code>m_mutex</code> 进行了上锁。当 <code>criticalSection()</code> 函数执行完毕时，<code>lock_guard</code> 的析构函数会自动解锁 <code>m_mutex</code>。</p> <p>通过使用 <code>std::lock_guard</code>，我们可以确保在任何情况下都能正确地管理互斥锁的上锁和解锁操作。</p> <p>希望对您有所帮助！如果您还有其他问题，请随时提问。</p> <h4 id="匿名对象"><a href="#匿名对象" class="header-anchor">#</a> 匿名对象</h4> <p>C++中的匿名对象是指没有被命名或赋值给变量的临时对象。它们通常在表达式中使用，并且只在该表达式的作用域内存在。</p> <p>匿名对象可以用于简化代码和对临时结果的处理。例如，在函数调用时，可以直接传递一个匿名对象作为参数，而无需显式定义一个变量来保存临时结果。另外，匿名对象还可以用于链式调用，如多个成员函数的连续调用。</p> <p>然而，需要注意以下几点：</p> <ol><li><p>生命周期：匿名对象的生命周期仅限于包含它的表达式的作用域。一旦该表达式结束，匿名对象将被销毁。</p></li> <li><p>可读性和可维护性：由于匿名对象没有名称，所以在代码阅读和维护时可能会增加困难。因此，过多地使用匿名对象可能降低代码的可读性。</p></li> <li><p>性能开销：如果一个匿名对象需要进行较为复杂的构造或析构操作，那么频繁创建和销毁匿名对象可能会带来一定的性能开销。在这种情况下，可以考虑使用命名对象来提高代码的可读性和性能。</p></li></ol> <p>总结来说，C++中的匿名对象是没有被命名或赋值给变量的临时对象。它们主要用于简化代码和处理临时结果，但需要注意生命周期、可读性和性能开销等方面的考虑。正确使用匿名对象可以提高代码的简洁性和可维护性。</p> <h4 id="std-lock-guard"><a href="#std-lock-guard" class="header-anchor">#</a> std::lock_guard</h4> <p><code>std::lock_guard</code> 是 C++ 标准库中的一个模板类，用于在作用域内自动管理互斥锁。</p> <p>它是基于 RAII（Resource Acquisition Is Initialization）原则设计的，即资源获取即初始化。<code>std::lock_guard</code> 的主要作用是在构造时获取互斥锁，并在析构时释放互斥锁，确保在任何情况下都能正确释放锁。</p> <p>下面是使用 <code>std::lock_guard</code> 的示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这里获取互斥锁</span>
    
    <span class="token comment">// 临界区，执行需要互斥访问的代码块</span>
    <span class="token comment">// ...</span>
    
<span class="token punctuation">}</span> <span class="token comment">// 在这里离开作用域，std::lock_guard 的析构函数会自动释放互斥锁</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>通过创建 <code>std::lock_guard</code> 对象并传入互斥锁，可以确保在退出作用域时自动释放互斥锁，避免了手动调用 <code>unlock()</code> 的麻烦，并且保证了异常安全性，即使在发生异常的情况下也能正确释放锁。</p> <p>请注意，<code>std::lock_guard</code> 是一种辅助工具，用于简化互斥锁的使用。如果需要更复杂的锁操作，可以考虑使用 <code>std::unique_lock</code> 或 <code>std::shared_lock</code>。</p> <h4 id="boost-check"><a href="#boost-check" class="header-anchor">#</a> BOOST_CHECK</h4> <p><code>BOOST_CHECK</code> 是 Boost.Test 库中的一个断言宏，用于判断给定条件是否为真。如果条件为真，则测试继续进行；如果条件为假，则测试失败并输出相应的错误信息。</p> <h4 id="std-move"><a href="#std-move" class="header-anchor">#</a> std::move</h4> <p><code>std::move</code>是C++标准库中的一个函数模板，位于 <code>&lt;utility&gt;</code> 头文件中，用于实现右值引用语义，将左值转换为对应的右值引用。它的作用是将对象的所有权从一个对象移动到另一个对象，而不进行内存拷贝或额外的资源分配。</p> <p>具体来说，<code>std::move</code>的使用方式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><p>参数 <code>arg</code>：转移所有权的对象。</p></li> <li><p>返回值：右值引用类型，即将参数转换为对应的右值引用。</p></li></ul> <p>以下是对 <code>std::move</code> 的详细解释和常见用法：</p> <ol><li><p>转移语义（Move Semantics）：<code>std::move</code> 的主要目的是实现转移语义，通过将对象的资源所有权从一个对象转移到另一个对象，避免不必要的复制和资源分配，提高性能。</p></li> <li><p>右值引用（Rvalue Reference）：<code>std::move</code> 将左值强制转换为右值引用。右值引用表示临时对象、匿名对象或即将销毁的对象。通过右值引用，可以调用移动构造函数或移动赋值操作符，实现高效的资源管理。</p></li> <li><p>安全地交换对象：<code>std::move</code> 常用于容器类中的元素交换、移动语义的实现等场景。可以通过 <code>std::move</code> 将对象移动到容器或容器中的元素，避免不必要的复制和内存分配。</p></li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> source <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> destination<span class="token punctuation">;</span>

destination <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将source的内容移动到destination，并清空source</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="4"><li>注意事项：
<ul><li>使用 <code>std::move</code> 后，原来的对象处于有效但未定义的状态，不应再访问该对象。</li> <li>被转移的对象，其资源所有权会被转移到目标对象，源对象不再拥有该资源。</li> <li><code>std::move</code> 并不实际移动数据，它只是改变了对象的状态，告诉编译器使用右值引用。</li></ul></li></ol> <p>总结：<code>std::move</code> 是C++中实现转移语义的重要函数模板，通过将左值转换为对应的右值引用，实现高效的资源管理和对象交换。使用 <code>std::move</code> 可以显式地指定转移所有权，并提高代码的性能和效率。但需要注意的是，在使用 <code>std::move</code> 后，源对象的状态会发生改变，不应再对其进行访问。</p> <h4 id="std-atomic"><a href="#std-atomic" class="header-anchor">#</a> std::atomic</h4> <p><code>std::atomic</code> 是 C++ 标准库提供的模板类之一，位于 <code>&lt;atomic&gt;</code> 头文件中。它用于实现原子操作，提供了对共享变量的原子性访问和修改。</p> <p><code>std::atomic</code> 类的主要功能有：</p> <ol><li>原子加载（load）：使用 <code>load()</code> 成员函数可以原子地获取当前存储在 <code>std::atomic</code> 对象中的值。</li> <li>原子存储（store）：使用 <code>store()</code> 成员函数可以原子地将指定的值存储到 <code>std::atomic</code> 对象中。</li> <li>原子交换（exchange）：使用 <code>exchange()</code> 成员函数可以原子地将新值存储到 <code>std::atomic</code> 对象中，并返回之前的值。</li> <li>原子比较和交换（compare-and-exchange）：使用 <code>compare_exchange_weak()</code> 或 <code>compare_exchange_strong()</code> 成员函数可以原子地比较 <code>std::atomic</code> 对象的值，并根据比较结果进行条件性的存储或交换操作。</li> <li>原子算术操作：<code>std::atomic</code> 提供了一系列的成员函数，如 `fetch_add</li></ol> <h4 id="std-any"><a href="#std-any" class="header-anchor">#</a> std::any</h4> <p><code>std::any</code> 是 C++17 中引入的标准库类之一，位于 <code>&lt;any&gt;</code> 头文件中。它是一种类型安全的容器，可以存储任何可复制、可移动的类型。</p> <p><code>std::any</code> 类的主要功能有：</p> <ol><li>存储和访问任意类型的值：<code>std::any</code> 可以存储任何类型的值，包括内置类型、用户定义的类型和标准库类型等。它使用类型擦除的机制，可以在运行时存储和提取值，而不需要提前知道具体的类型。</li> <li>类型安全的值提取：可以使用 <code>std::any_cast</code> 函数将存储在 <code>std::any</code> 中的值按照指定的类型进行提取，同时会进行类型检查，如果类型不匹配，则会抛出 <code>std::bad_any_cast</code> 异常。</li> <li>支持空状态：<code>std::any</code> 在默认构造时是空的，可以通过赋值操作或者 <code>emplace</code> 成员函数来设置非空值，也可以通过 <code>reset</code> 成员函数将其重置为空状态。</li> <li>支持复制和移动语义：<code>std::any</code> 可以通过复制构造函数和移动构造函数进行复制和移动操作，从一个 <code>std::any</code> 对象转移到另一个对象，并保持存储的值不变。</li></ol> <p>使用 <code>std::any</code> 可以灵活地处理不确定的数据类型，特别适用于需要在运行时处理不同类型数据的情况，同时提供了类型安全的访问机制。例如，在实现通用容器、配置解析等场景中，可以使用 <code>std::any</code> 存储和操作各种类型的值。</p> <h4 id="std-function"><a href="#std-function" class="header-anchor">#</a> std::function</h4> <p><code>std::function</code> 是 C++ 标准库中的一个模板类，用于封装可调用对象（callable object），并提供一种统一的接口来处理不同类型的可调用实体。</p> <p>通过 <code>std::function</code>，可以将函数、函数指针、成员函数、lambda 表达式等各种可调用实体存储到同一类型的对象中，并能够在需要时进行调用。它提供了一种灵活且类型安全的方式来操作可调用实体。</p> <p>使用 <code>std::function</code> 的语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token comment">// 定义一个 std::function 对象</span>
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span>返回类型<span class="token punctuation">(</span>参数类型<span class="token punctuation">)</span><span class="token operator">&gt;</span> func<span class="token punctuation">;</span>

<span class="token comment">// 绑定一个函数</span>
func <span class="token operator">=</span> 函数名<span class="token punctuation">;</span>

<span class="token comment">// 绑定一个函数对象</span>
func <span class="token operator">=</span> 函数对象<span class="token punctuation">;</span>

<span class="token comment">// 调用可调用实体</span>
<span class="token function">func</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>其中，<code>返回类型</code> 是函数或函数对象的返回类型，<code>参数类型</code> 是函数或函数对象的参数类型。</p> <p>通过 <code>std::function</code>，可以实现函数的传递、回调、事件处理等功能。它还支持函数对象之间的复制和赋值操作，使得代码更加灵活和可重用。</p> <p>需要注意的是，<code>std::function</code> 对于函数的调用可能会引入一定的开销，但在大多数情况下这种开销可以忽略不计。此外，<code>std::function</code> 不能存储非静态的成员变量指针，只能存储成员函数或静态成员函数。</p> <h4 id="std-bind"><a href="#std-bind" class="header-anchor">#</a> std::bind</h4> <p><code>std::bind</code> 是 C++ 标准库中的一个函数模板，用于创建一个可调用对象（callable object），将参数绑定到特定的函数或成员函数上。</p> <p>通过 <code>std::bind</code>，可以实现对函数或成员函数进行参数绑定、占位符替换和部分应用等操作，以生成新的可调用对象。这样可以延迟函数的调用，并在需要时提供参数。</p> <p>使用 <code>std::bind</code> 的语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token comment">// 绑定一个函数</span>
<span class="token keyword">auto</span> boundFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>函数名<span class="token punctuation">,</span> 参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 绑定成员函数</span>
<span class="token keyword">auto</span> boundMemberFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>类名<span class="token double-colon punctuation">::</span>成员函数名<span class="token punctuation">,</span> 对象指针<span class="token punctuation">,</span> 参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用占位符进行参数绑定</span>
<span class="token keyword">auto</span> boundFuncWithPlaceholder <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>函数名<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>其中，<code>函数名</code> 是要绑定的函数或成员函数的名称，<code>参数1, 参数2, ...</code> 是要绑定的参数。对于成员函数，需要提供对象指针作为第一个参数。</p> <p>通过 <code>std::bind</code> 绑定的可调用对象可以像普通函数一样进行调用，并根据绑定的参数来执行相应的操作。</p> <p>除了参数绑定，<code>std::bind</code> 还支持占位符（placeholder）的使用。占位符使用 <code>std::placeholders::_N</code> 表示，其中 N 是参数的位置索引。通过占位符，可以在调用时提供缺失的参数，并将其绑定到正确的位置。</p> <p>需要注意的是，<code>std::bind</code> 可以实现函数的柯里化（currying）和部分应用（partial application），以及对参数排序和重排等操作。它提供了更灵活的方式来处理函数对象，并可以用于实现回调、事件处理等功能。</p> <p>然而，C++11 引入了 lambda 表达式，它提供了更简洁和直观的语法来处理函数对象和参数绑定的需求。在现代 C++ 中，通常推荐使用 lambda 表达式而不是 <code>std::bind</code>。</p> <h4 id="std-atomic-int"><a href="#std-atomic-int" class="header-anchor">#</a> std::atomic_int</h4> <p><code>std::atomic_int</code> 是 C++ 标准库中的一个原子类型，用于实现多线程环境下的原子操作。</p> <p>原子操作是指在并发环境中不会被其他线程中断的操作。<code>std::atomic_int</code> 类型提供了一种线程安全的方式来使用整数类型变量（int），保证对该变量的读取和写入操作具有原子性。</p> <p>通过 <code>std::atomic_int</code>，你可以进行原子的读取、写入、交换、自增/自减、比较与交换等操作。这些操作都能够确保在多线程环境下不会出现数据竞争或不一致的情况。</p> <p>使用 <code>std::atomic_int</code> 的语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>atomic_int myAtomicInt<span class="token punctuation">;</span> <span class="token comment">// 声明一个 std::atomic_int 类型的变量</span>

myAtomicInt<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存储值为 42</span>
<span class="token keyword">int</span> value <span class="token operator">=</span> myAtomicInt<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加载当前值</span>

myAtomicInt<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原子地将当前值加 1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>需要注意的是，<code>std::atomic_int</code> 类型只适用于基本整数类型，例如 int、unsigned int、short 等等。如果需要原子操作其他类型的对象，可以使用 <code>std::atomic</code> 模板，并在模板参数中指定相应的类型。</p> <h4 id="syscall-sys-gettid"><a href="#syscall-sys-gettid" class="header-anchor">#</a> syscall(SYS_gettid)</h4> <p><code>syscall(SYS_gettid)</code> 是一个系统调用，用于获取当前线程的线程ID（Thread ID）。</p> <p>在Linux系统中，每个线程都具有唯一的线程ID，可以通过 <code>syscall(SYS_gettid)</code> 来获取当前线程的线程ID。<code>SYS_gettid</code> 是一个宏定义，表示获取线程ID的系统调用号。</p> <p>使用 <code>syscall(SYS_gettid)</code> 时需要包含头文件 <code>&lt;sys/syscall.h&gt;</code>。该调用返回一个整数值，表示当前线程的线程ID。</p> <p>需要注意的是，<code>syscall()</code> 函数是一个底层的系统调用接口，直接调用底层的系统调用而不经过C库的封装。在一般情况下，我们更倾向于使用标准的C库函数或C++标准库提供的接口来进行线程相关的操作，如 <code>pthread_self()</code> 函数来获取线程ID。</p> <h4 id="linux下-usr-local-include、-usr-local-lib和-usr-include、-usr-lib的区别"><a href="#linux下-usr-local-include、-usr-local-lib和-usr-include、-usr-lib的区别" class="header-anchor">#</a> linux下/usr/local/include、/usr/local/lib和/usr/include、/usr/lib的区别</h4> <p><code>/usr/local/include</code> 和 <code>/usr/local/lib</code> 目录通常用于存放本地安装的软件的头文件和库文件，而 <code>/usr/include</code> 和 <code>/usr/lib</code> 目录则是系统默认的头文件和库文件的存放位置。</p> <ol><li><p><code>/usr/local/include</code>：这个目录是用来存放本地安装的软件的头文件的。当你手动编译和安装某个软件时，它的头文件通常会被安装到 <code>/usr/local/include</code> 目录下。这样做的好处是可以将本地安装的软件与系统默认的软件区分开来，避免冲突。</p></li> <li><p><code>/usr/local/lib</code>：这个目录是用来存放本地安装的软件的库文件的。当你手动编译和安装某个软件时，它的库文件通常会被安装到 <code>/usr/local/lib</code> 目录下。同样地，这样做可以将本地安装的库文件与系统默认的库文件区分开来。</p></li> <li><p><code>/usr/include</code>：这个目录是系统默认的头文件的存放位置。它包含了系统提供的标准库的头文件以及其他系统级别的头文件。当你编译系统默认提供的库时，编译器会在 <code>/usr/include</code> 目录中查找相应的头文件。</p></li> <li><p><code>/usr/lib</code>：这个目录是系统默认的库文件的存放位置。它包含了系统提供的标准库以及其他系统级别的库文件。当你链接系统默认提供的库时，链接器会在 <code>/usr/lib</code> 目录中查找相应的库文件。</p></li></ol> <p>总结起来，<code>/usr/local/include</code> 和 <code>/usr/local/lib</code> 目录是用于存放本地安装的软件的头文件和库文件，而 <code>/usr/include</code> 和 <code>/usr/lib</code> 目录是系统默认的头文件和库文件的存放位置。这种分离可以帮助你管理本地安装的软件和系统默认的软件，并避免冲突。</p> <h4 id="builtin-expect-2"><a href="#builtin-expect-2" class="header-anchor">#</a> __builtin_expect</h4> <p><code>__builtin_expect</code> 是一个内置函数，用于给编译器提示条件表达式的预期结果，以便优化生成的代码。它的形式如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">__builtin_expect</span><span class="token punctuation">(</span>expression<span class="token punctuation">,</span> expected_value<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这段代码中，<code>__builtin_expect(t_cachedTid == 0, 0)</code> 表示条件表达式 <code>t_cachedTid == 0</code> 的预期结果是 0。这个提示告诉编译器，条件 <code>t_cachedTid == 0</code> 很可能为假，以便编译器进行相应的优化。</p> <p>通过使用 <code>__builtin_expect</code>，编译器可以根据预期结果对代码进行优化，使得更有可能的分支更容易被预测，从而提高代码的执行效率。在这个特定的例子中，条件表达式 <code>t_cachedTid == 0</code> 的预期结果为假（0），因此编译器可能会优化条件判断的分支，使得条件为假时的代码更容易被执行。这样可以提高程序的性能，特别是在条件判断的分支频繁发生且有明显的倾向性时。</p> <p>需要注意的是，<code>__builtin_expect</code> 只是给编译器提供了一种提示，具体的优化效果还取决于编译器的实现。不同的编译器可能对 <code>__builtin_expect</code> 的处理方式有所不同。</p> <h4 id="类里纯虚函数"><a href="#类里纯虚函数" class="header-anchor">#</a> 类里纯虚函数</h4> <p>在 C++ 中，纯虚函数是在基类中声明但没有实现的虚函数。它通过在函数声明的末尾使用 &quot;= 0&quot; 来表示。</p> <p>纯虚函数的作用是为了将基类定义为一个抽象类，它只用于作为其他具体派生类的接口定义，而不能直接实例化。抽象类是一种不能创建对象的类，它只能被用作其他类的基类。</p> <p>通过在基类中定义纯虚函数，可以强制要求派生类必须实现这个函数。派生类必须提供纯虚函数的具体实现，否则它也会成为一个抽象类，无法实例化。</p> <p>纯虚函数可以被派生类重写，提供具体的实现。这样，通过基类指针或引用可以调用派生类的纯虚函数，实现多态的行为。</p> <p>以下是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">pureVirtualFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 纯虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">pureVirtualFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
        <span class="token comment">// 派生类提供的具体实现</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Base<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr<span class="token operator">-&gt;</span><span class="token function">pureVirtualFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通过基类指针调用派生类的纯虚函数</span>
    <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在上面的示例中，基类 <code>Base</code> 定义了一个纯虚函数 <code>pureVirtualFunction()</code>，派生类 <code>Derived</code> 重写了这个函数并提供了具体的实现。在 <code>main()</code> 函数中，通过基类指针 <code>ptr</code> 创建了一个派生类对象，并通过指针调用了纯虚函数。</p> <p>纯虚函数的存在使得基类成为一个抽象类，它只用于定义接口，并提供了一种规范让派生类必须实现特定的功能。这种设计可以帮助实现多态性、代码的可扩展性和可维护性。</p> <h4 id="虚析构函数"><a href="#虚析构函数" class="header-anchor">#</a> 虚析构函数</h4> <p>在 C++ 中，当一个类被设计为作为基类使用，并且可能会被其他类通过指针或引用来操作时，通常需要在该类中定义一个虚析构函数。</p> <p>虚析构函数在基类中的作用是确保在通过基类指针或引用删除派生类对象时，能够正确调用派生类的析构函数。如果基类的析构函数不是虚函数，那么当通过基类指针或引用删除派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类中的资源没有得到正确释放，造成内存泄漏或其他问题。</p> <p>通过在基类中定义虚析构函数，可以实现多态的析构行为。当通过基类指针或引用删除派生类对象时，会首先调用派生类的析构函数，然后再调用基类的析构函数。这样可以确保派生类中的资源得到正确释放，同时避免内存泄漏和未定义行为。</p> <p>以下是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 基类析构函数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token operator">~</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 派生类析构函数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Base<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>  <span class="token comment">// 通过基类指针删除派生类对象</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>在上面的示例中，基类 <code>Base</code> 定义了一个虚析构函数 <code>~Base()</code>，派生类 <code>Derived</code> 重写了析构函数 <code>~Derived()</code>。在 <code>main()</code> 函数中，通过基类指针 <code>ptr</code> 创建了一个派生类对象，并使用 <code>delete</code> 删除该对象。由于基类的析构函数是虚函数，所以会首先调用派生类的析构函数 <code>~Derived()</code>，然后再调用基类的析构函数 <code>~Base()</code>。</p> <p>通过定义虚析构函数，可以正确释放派生类对象中的资源，确保程序的行为符合预期并避免潜在的问题。</p> <h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="header-anchor">#</a> std::weak_ptr</h4> <p><code>std::weak_ptr&lt;void&gt;</code> 是一个弱引用指针，它可以用于跟踪一个被 <code>std::shared_ptr</code> 管理的对象，但不会增加对象的引用计数。由于 <code>std::weak_ptr</code> 是一个通用的模板类，它可以用于跟踪任何类型的对象。</p> <p>在您提供的代码中，<code>tie_</code> 被声明为一个 <code>std::weak_ptr&lt;void&gt;</code> 类型的变量。这意味着 <code>tie_</code> 可以用于跟踪一个 <code>void</code> 类型的对象，或者跟踪任何类型的对象，因为 <code>void</code> 是一个通用的类型。</p> <p>使用 <code>std::weak_ptr</code> 可以解决一些潜在的问题，例如循环引用。它允许您在需要时访问被 <code>std::shared_ptr</code> 管理的对象，但不会阻止对象的销毁。</p> <p>请注意，由于 <code>std::weak_ptr</code> 是一个弱引用，如果被跟踪的对象已经被销毁，那么使用 <code>std::weak_ptr</code> 访问对象会返回一个空指针。</p> <h4 id="变量名命名加"><a href="#变量名命名加" class="header-anchor">#</a> 变量名命名加_</h4> <p>系统库里的变量是_在前，_变量名</p> <p>所以自建库里一般用 变量名_，防止冲突</p> <h4 id="变量作用域"><a href="#变量作用域" class="header-anchor">#</a> 变量作用域</h4> <p>命名空间最好都加上，防止污染</p> <p>很多错误经常是没加上作用域导致的</p> <h4 id="c-绑定器"><a href="#c-绑定器" class="header-anchor">#</a> C++绑定器</h4> <p>在 C++ 中，绑定器（Binder）是一种将函数与其参数部分绑定在一起创建新函数的机制。通过绑定器，我们可以创建一个新的函数对象，该对象包含了原始函数的部分参数。绑定器可以用于延迟函数调用、固定函数参数、改变函数签名等场景。</p> <p>C++ 标准库中提供了 <code>std::bind</code> 函数，用于创建绑定器。<code>std::bind</code> 函数的基本语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>Function<span class="token punctuation">,</span> Arg1<span class="token punctuation">,</span> Arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中，<code>Function</code> 是被绑定的函数，<code>Arg1, Arg2, ...</code> 是需要绑定的参数。绑定器将返回一个新的函数对象，该对象可以像普通函数一样调用。</p> <p>下面是一个简单的示例，演示如何使用 <code>std::bind</code> 创建绑定器：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;a + b = &quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> boundFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">boundFunc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出：a + b = 30</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在上面的示例中，我们使用 <code>std::bind</code> 创建了一个绑定器 <code>boundFunc</code>，将 <code>foo</code> 函数的第一个参数绑定为 10，第二个参数使用占位符 <code>std::placeholders::_1</code> 表示在调用时传入。然后，我们通过调用 <code>boundFunc</code> 来执行绑定的函数调用。</p> <p>绑定器还可以用于绑定成员函数、函数对象、函数指针等。通过灵活使用绑定器，我们可以实现更加灵活和可复用的函数调用方式。</p> <h4 id="c-str"><a href="#c-str" class="header-anchor">#</a> .c_str()</h4> <p>在C++中，<code>.c_str()</code> 是一个字符串成员函数，用于返回一个指向以 null 结尾的字符数组（C 风格字符串）的指针。它通常用于将 C++ 的 <code>std::string</code> 对象转换为 C 风格字符串。</p> <p><code>std::string</code> 是 C++ 标准库中提供的字符串类，它提供了许多方便的操作和功能。然而，在某些情况下，你可能需要将 <code>std::string</code> 对象传递给接受 C 风格字符串的函数或库。这时，你可以使用 <code>.c_str()</code> 函数来获取一个以 null 结尾的字符数组。</p> <p>例如，假设你有一个 <code>std::string</code> 对象 <code>str</code>，你可以通过调用 <code>str.c_str()</code> 来获取一个指向以 null 结尾的字符数组的指针。然后，你可以将该指针传递给需要 C 风格字符串的函数或库。</p> <p>需要注意的是，返回的字符数组指针指向 <code>std::string</code> 对象内部的字符数据，因此在 <code>std::string</code> 对象被销毁之前，该指针是有效的。如果你需要在 <code>std::string</code> 对象被销毁后继续使用该字符数组，你需要将其复制到另一个字符数组中。</p> <h4 id="函数对象和函数"><a href="#函数对象和函数" class="header-anchor">#</a> 函数对象和函数</h4> <p>在C++中，函数和函数对象（也称为函数符）之间有一些区别。</p> <ol><li>函数是一段可执行的代码，用于执行特定的任务。函数可以通过函数名直接调用，例如：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>函数对象是一种特殊类型的对象，它可以像函数一样被调用。在C++中，函数对象通常通过函数符（函数调用运算符<code>()</code>的重载）来实现。函数对象可以具有状态，并且可以在调用之间保留数据。例如：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Add</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Add add_obj<span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">add_obj</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用函数对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在上面的示例中，<code>Add</code>是一个函数对象，它重载了函数调用运算符<code>()</code>，使得<code>add_obj</code>可以像函数一样被调用。</p> <p>总结：</p> <ul><li>函数是一段可执行的代码，用于执行特定任务。</li> <li>函数对象是一种特殊类型的对象，它可以像函数一样被调用，通常通过函数符（函数调用运算符<code>()</code>）来实现。</li></ul> <p>需要注意的是，C++中的函数对象提供了更大的灵活性，因为它们可以具有状态和成员变量。此外，函数对象还可以作为参数传递给其他函数，从而实现更高级的编程模式，如函数式编程和泛型编程。</p> <h4 id="std-is-trivially-destructible"><a href="#std-is-trivially-destructible" class="header-anchor">#</a> std::is_trivially_destructible</h4> <p><code>std::is_trivially_destructible</code> 是 C++ 标准库 <code>&lt;type_traits&gt;</code> 头文件中定义的类型特征（type trait）。它用于判断一个类型是否是平凡可销毁的（trivially destructible）。</p> <p>平凡可销毁的类型是指其析构函数是空操作且没有任何副作用的类型。换句话说，可以安全地销毁该对象而无需进行任何显式的清理或资源管理。</p> <p><code>std::is_trivially_destructible</code> 特征是一个在编译时确定的常量，如果给定类型是平凡可销毁的，则其值为 <code>true</code>，否则为 <code>false</code>。它可以根据类型的销毁性质有条件地启用或禁用某些代码优化或行为。</p> <p>以下是一个示例用法：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">MyType</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">MyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;析构函数被调用\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;MyType 是否是平凡可销毁的？&quot;</span>
              <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_trivially_destructible<span class="token operator">&lt;</span>MyType<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在这个示例中，输出将是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>MyType 是否是平凡可销毁的？false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>由于 <code>MyType</code> 的析构函数具有副作用（打印一条消息），它不是平凡可销毁的。</p> <h4 id="trivial-destructor平凡析构函数"><a href="#trivial-destructor平凡析构函数" class="header-anchor">#</a> trivial destructor平凡析构函数</h4> <p>在C++中，根据C++标准（C++ Standard），一个类的析构函数（Destructor）被称为&quot;trivial destructor&quot;（平凡析构函数），如果满足以下条件之一：</p> <ol><li>类没有虚函数（virtual function）和虚基类（virtual base class）。</li> <li>类的基类（base class）也有平凡析构函数并且是非虚的。</li> <li>类的所有非静态数据成员（non-static data members）也都有平凡析构函数。</li></ol> <p>当一个类的析构函数被认为是平凡的，意味着它不需要执行任何特殊的清理操作。编译器会自动生成一个默认的平凡析构函数，它会自动调用类的成员对象的析构函数，并释放类的内存。</p> <p>平凡析构函数的存在可以对编译器进行优化，例如在某些情况下可以进行内存布局的优化，或者在数组和容器等数据结构中进行快速的析构操作。</p> <p>需要注意的是，当类的析构函数不满足上述条件时，它将被认为是非平凡的（non-trivial），可能需要执行额外的清理操作，如释放资源、销毁对象等。非平凡析构函数需要由程序员显式定义和实现。</p> <p>总结起来，C++中的平凡析构函数（trivial destructor）是指满足一定条件的类的析构函数，它不需要执行特殊的清理操作，并由编译器自动生成。这些条件包括类没有虚函数、虚基类和非静态数据成员都有平凡析构函数。非平凡析构函数则需要程序员显式定义和实现，并可能执行额外的清理操作。</p> <h4 id="内存地址是按字节进行编码的"><a href="#内存地址是按字节进行编码的" class="header-anchor">#</a> 内存地址是按字节进行编码的</h4> <p>在大多数情况下，内存地址+1表示增加一个字节的大小。</p> <p>内存地址是以字节为单位进行编址的，每个字节对应一个唯一的内存地址。因此，对一个内存地址进行加1操作，通常会使其指向下一个相邻的字节。</p> <p>然而，需要注意的是，指针的自增操作并不一定严格等同于增加一个字节。指针的自增操作会根据指针所指向的数据类型的大小来进行增加。例如，对一个<code>char*</code>类型的指针进行自增操作，会使指针增加一个字节；而对一个<code>int*</code>类型的指针进行自增操作，会使指针增加四个字节（32位系统）或八个字节（64位系统）。</p> <p>因此，当我们说内存地址+1表示增加一个字节的大小时，是基于通常情况下的假设，即指针的类型为<code>char*</code>或者我们希望以字节为单位进行地址操作。具体情况仍取决于指针的类型和所指向的数据类型的大小。</p> <h4 id="c-函数什么时候传入参数用"><a href="#c-函数什么时候传入参数用" class="header-anchor">#</a> C++函数什么时候传入参数用&amp;</h4> <p>在 C++ 函数中，传递参数时使用 <code>&amp;</code> 的主要情况是为了实现引用传递（Pass-by-Reference），而不是传递参数的副本。以下是一些常见的情况：</p> <ol><li><p>修改函数外部变量：
如果希望在函数内部修改函数外部的变量，并且避免进行参数的复制，可以使用引用传递。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  num<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 修改函数外部的变量</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token function">increment</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过引用传递参数</span>
  cout <span class="token operator">&lt;&lt;</span> value<span class="token punctuation">;</span> <span class="token comment">// 输出 6</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>避免大对象复制：
当传递一个大的对象作为函数参数时，如果不希望发生对象的拷贝构造，可以使用引用传递来避免额外的开销。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">processObject</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 对 obj 进行操作</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object obj<span class="token punctuation">;</span> <span class="token comment">// 假设 Object 是一个大的对象类型</span>
  <span class="token function">processObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过引用传递大对象</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>返回多个值：
在 C++ 中，函数只能返回一个值。如果需要从函数中返回多个值，可以使用引用参数，在函数中修改参数的值。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">calculateValues</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> difference<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  sum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  difference <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> resultSum<span class="token punctuation">,</span> resultDifference<span class="token punctuation">;</span>
  <span class="token function">calculateValues</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resultSum<span class="token punctuation">,</span> resultDifference<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过引用传递返回多个值</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Sum: &quot;</span> <span class="token operator">&lt;&lt;</span> resultSum <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, Difference: &quot;</span> <span class="token operator">&lt;&lt;</span> resultDifference<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li></ol> <p>总结：
使用 <code>&amp;</code> 来传递参数时，可以实现引用传递，以便在函数内部修改函数外部的变量、避免大对象复制或返回多个值。这样可以提高效率和灵活性，并避免不必要的数据复制。</p> <h4 id="c-中return和exit"><a href="#c-中return和exit" class="header-anchor">#</a> C++中return和exit</h4> <p>在 C++ 中，<code>return</code> 和 <code>exit</code> 是用于程序控制流程的关键字，但它们有不同的用途和行为。</p> <ol><li><p><code>return</code>：</p> <ul><li><code>return</code> 用于从函数中返回值，并终止当前函数的执行。当函数达到 <code>return</code> 语句时，它会立即返回并将指定的值传递给调用者。</li> <li><code>return</code> 可以在任何函数中使用，包括主函数 <code>main()</code>。在 <code>main()</code> 函数中，<code>return</code> 的参数将作为程序的退出状态码返回给操作系统。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// 返回 a+b 的结果，并终止函数执行</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 sum 函数并接收返回值</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token comment">// 将 result 作为程序的退出状态码返回给操作系统</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p><code>exit</code>：</p> <ul><li><code>exit</code> 用于立即终止整个程序的执行，并返回给操作系统。它可以在任何地方被调用，不仅限于函数体内部。</li> <li><code>exit</code> 接受一个整数参数，作为程序的退出状态码。这个状态码可以用来向调用程序传递附加信息，通常用 0 表示成功，非零值表示错误。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行一些代码...</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>someCondition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 程序立即终止，并返回状态码 1 给操作系统表示错误</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 执行一些代码...</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li></ol> <p>总结：</p> <ul><li><code>return</code> 用于函数内部，用于从函数中返回值并终止函数的执行。</li> <li><code>exit</code> 用于程序任何地方，用于立即终止整个程序的执行，并返回给操作系统一个状态码作为退出信息。</li></ul> <h4 id="静态static"><a href="#静态static" class="header-anchor">#</a> 静态static</h4> <p>在 C++ 中，静态成员变量和静态成员函数是属于类本身而不是类的实例的成员。它们与类相关联，而不是与类的每个对象实例相关联。</p> <ol><li><p>静态成员变量：</p> <ul><li>静态成员变量是在类中定义的，但不是在对象实例中分配内存的。它只有一个副本，被所有类的实例共享。</li> <li>静态成员变量可以在类定义中进行初始化，并且必须在类外部进行定义（通常在源文件中）以分配内存空间。</li> <li>访问静态成员变量时，使用类名加上作用域解析运算符 <code>::</code> 进行访问。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">// 声明静态成员变量</span>

  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 在类外部进行静态成员变量的定义和初始化</span>
<span class="token keyword">int</span> MyClass<span class="token double-colon punctuation">::</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">incrementCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用类名调用静态成员函数</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Count: &quot;</span> <span class="token operator">&lt;&lt;</span> MyClass<span class="token double-colon punctuation">::</span>count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 使用类名访问静态成员变量</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li> <li><p>静态成员函数：</p> <ul><li>静态成员函数在类的命名空间中存在，它们不操作特定对象的数据，因此没有隐式的 <code>this</code> 指针。</li> <li>静态成员函数可以直接从类名调用，无需创建对象实例。</li> <li>静态成员函数只能访问静态成员变量和其他静态成员函数。它们不能访问非静态成员变量或调用非静态成员函数。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;This is a static member function.&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用类名调用静态成员函数</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ol> <p>通过使用静态成员变量和静态成员函数，我们可以在不创建类的实例的情况下，共享数据和功能，并为类提供一些全局性质的特性。</p> <h4 id="c-和java"><a href="#c-和java" class="header-anchor">#</a> C++和java</h4> <p>C++同一个文件中，类要写在main函数之前</p> <p>java同一个文件中，main函数写在类的前面或者后面无所谓，编译器并不关心它的位置。这是因为Java编译器会对整个文件进行扫描和解析，无论<code>main</code>函数在文件中的具体位置，它都能被正确地识别为程序的入口点。</p> <h4 id="多个main问题"><a href="#多个main问题" class="header-anchor">#</a> 多个main问题</h4> <p>在VS中，会编译和链接所有源文件，会因重复定义main()函数而报错。</p> <p>vscode中可以只编译和链接一个源文件，所以暂时没错。</p> <h4 id="c-类模板的声明和定义要放在同一个-h头文件"><a href="#c-类模板的声明和定义要放在同一个-h头文件" class="header-anchor">#</a> C++类模板的声明和定义要放在同一个.h头文件</h4> <p>不是只能放在.h里面，但是推荐放在.h里面。STL模板实现全部是放在.h里面的。</p> <p>编译能通过。
1）参与编译的只是.cpp文件，不会报错的原因，是因为它能在.h里面找到模板的声明。
链接错误。
1）链接的时候，需要实例化模板，这时候就需要找模板的具体实现了。假设在main函数中调用了一个模板函数，这时候就需要去实例化该类型的模板。注意main函数里面只包含了.h文件，也就是只有模板的声明，没有具体实现。就会报错。
2）而模板的实现.cpp里面，虽然有模板的具体实现，但是没有谁在该.cpp里面使用一个模板函数，就不会生成一个具体化的实例。
ps：模板是在需要的时候，才会去生成一个具体化的实例的，比如，你只要一个int型的实例，模板就只会给你生成一个int型的实例，模板本身是不会被执行的（也就是模板本身不产生汇编指令），是模板生成的具体化实例才产生指令（这个实例是隐藏的，我们是看不到的）</p> <p>解决方案：
1）将模板实现写在.h里面
2）如果你非要写在.cpp里面，那么请在模板实现的.cpp文件里面（或者.h里面）显式的实例化一个模板。如果是这样的话，那模板就没有太大的意义了，难道你去自己手动实例化所有的实例？</p> <h4 id="常量引用和引用引用"><a href="#常量引用和引用引用" class="header-anchor">#</a> 常量引用和引用引用</h4> <p>常量引用和引用引用（也称为右值引用）是 C++ 中两种不同的引用类型。</p> <p>常量引用是指被引用对象的值不能被修改，而引用引用则是用于绑定到右值表达式上的引用类型，用于实现移动语义和完美转发。</p> <p>具体来说，常量引用使用 const 关键字进行声明，例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ref <span class="token operator">=</span> num<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里的 ref 是一个常量引用，它指向 num 这个整数变量，并且不能修改 num 的值。</p> <p>引用引用则使用 &amp;&amp; 进行声明，例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里的 ref 是一个引用引用，它指向 num 这个右值，并且可以用于实现移动语义和完美转发。</p> <p>总的来说，常量引用和引用引用都是引用类型，但是它们的作用和使用场景有所不同。常量引用主要用于传递参数和返回值，以避免拷贝对象，而引用引用则主要用于实现移动语义和完美转发。</p> <h4 id="指针指针"><a href="#指针指针" class="header-anchor">#</a> 指针指针</h4> <p>指针指针（double pointer）在 C++ 中通常用于传递指向指针的指针，或者在函数中动态分配内存并返回指向指针的指针。指针指针可以用来实现一些高级数据结构，如链表和树等。</p> <p>一个常见的用法是在函数中动态分配内存并返回指向指针的指针。例如，如果你想在函数中创建一个数组，并返回该数组的指针，你可以使用指针指针来实现。下面是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">[</span>rows<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>cols<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> array<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个函数创建一个 <code>rows</code> 行 <code>cols</code> 列的二维数组，并返回一个指向指针的指针。在这个函数中，我们首先创建一个指针数组 <code>array</code>，然后使用循环为每个指针分配一个数组。</p> <p>另一个常见的用法是在函数中传递指向指针的指针，以便在函数中修改指针的值。这在某些情况下是非常有用的，例如，当你想在函数中创建一个新的对象并将其分配给一个指针时，你可以使用指针指针来修改指针的值。下面是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">createObject</span><span class="token punctuation">(</span>Object<span class="token operator">*</span><span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个函数创建一个新的 <code>Object</code> 对象，并将其分配给指向指针的指针 <code>obj</code>。在函数中，我们通过解引用指针指针来修改指针的值。</p> <p>总之，指针指针在 C++ 中通常用于传递指向指针的指针，或者在函数中动态分配内存并返回指向指针的指针。</p> <h4 id="结构体里的静态函数"><a href="#结构体里的静态函数" class="header-anchor">#</a> 结构体里的静态函数</h4> <p>在 C++ 中，结构体可以包含静态函数。静态函数是指不需要实例化结构体对象即可被调用的函数。静态函数可以使用结构体中的静态成员变量，但不能使用结构体中的非静态成员变量。</p> <p>静态函数的语法与普通函数类似，只需要在函数前面加上 <code>static</code> 关键字即可。下面是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">MyStruct</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> myStaticVar<span class="token punctuation">;</span>

  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">myStaticFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 静态函数可以使用静态成员变量</span>
    myStaticVar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Hello from myStaticFunc!&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 静态成员变量需要在类外进行初始化</span>
<span class="token keyword">int</span> MyStruct<span class="token double-colon punctuation">::</span>myStaticVar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用静态函数</span>
  <span class="token class-name">MyStruct</span><span class="token double-colon punctuation">::</span><span class="token function">myStaticFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>注意，在结构体中定义静态函数时，函数的实现必须在结构体内部进行。另外，静态函数可以通过 <code>结构体名::函数名()</code> 的方式进行调用。</p> <h4 id="stl中的配接器和配置器的区别"><a href="#stl中的配接器和配置器的区别" class="header-anchor">#</a> STL中的配接器和配置器的区别</h4> <p>STL中的配接器（adapter）和配置器（allocator）是两个不同的概念。</p> <p>配接器是一种模式，用于将一个容器的接口转化为另一个容器的接口。STL中提供了多种配接器，如stack、queue、priority_queue等。这些配接器都是通过适配器模式来实现的，可以将一个容器适配为具有不同接口的容器。</p> <p>而配置器则是用于控制容器的内存分配和释放的机制。STL中的容器都是通过配置器来进行内存管理的，配置器可以自定义内存分配和释放的方式，以满足不同的需求。STL中提供了默认的配置器std::allocator，也可以自定义配置器来实现更灵活的内存管理。</p> <p>因此，配接器和配置器虽然都是STL中的重要概念，但是它们的作用和实现方式是不同的。</p> <h4 id="c-iostream"><a href="#c-iostream" class="header-anchor">#</a> C++ iostream</h4> <p>C++ 的 iostream 库提供了输入输出流的支持，包括了 <code>iostream</code>、<code>fstream</code>、<code>stringstream</code> 等头文件。其中，<code>iostream</code> 用于控制台输入输出；<code>fstream</code> 用于文件输入输出；<code>stringstream</code> 用于字符串输入输出。</p> <p><code>iostream</code> 头文件中主要包含了 <code>cin</code>、<code>cout</code>、<code>cerr</code> 和 <code>clog</code> 四个对象，它们分别代表标准输入流、标准输出流、标准错误流和日志输出流。<code>cin</code> 和 <code>cout</code> 是最常用的输入输出流对象，分别用于从控制台读取输入和向控制台输出内容。<code>cerr</code> 和 <code>clog</code> 用于输出错误信息和日志信息，但它们的输出方式略有不同，<code>cerr</code> 直接输出到控制台，而 <code>clog</code> 输出到文件中。</p> <p>除了对象之外，<code>iostream</code> 还提供了一些用于格式化输出的函数和操作符，例如 <code>setw</code>、<code>setprecision</code>、<code>fixed</code>、<code>scientific</code> 等等。这些函数和操作符可以帮助我们更方便地输出特定格式的内容。</p> <p>总的来说，C++ 的 iostream 库提供了非常强大和灵活的输入输出功能，可以满足各种不同</p> <h4 id="stl中函数对象和算法的区别"><a href="#stl中函数对象和算法的区别" class="header-anchor">#</a> STL中函数对象和算法的区别</h4> <p>STL中的函数对象和算法都是STL的重要组成部分，但它们的作用有所不同。</p> <p>函数对象（Functor）是一种行为类似函数的对象。它们可以像函数一样被调用，但与函数不同的是，函数对象可以保存状态。STL中的函数对象通常用于排序、查找、遍历等算法中，以提供自定义的比较、判定、转换等操作。</p> <p>算法（Algorithm）是STL中的另一个重要组成部分，它们是对容器中的元素进行操作的函数。STL中的算法包括查找、排序、遍历、删除等操作。这些算法通常需要一个或多个函数对象作为参数，以提供自定义的比较、判定、转换等操作。</p> <p>因此，函数对象和算法是相互依存的关系，函数对象提供了算法所需的自定义操作，而算法则使用这些函数对象来完成具体的操作。</p> <p>return static_cast&lt;bool&gt;(L.length);  //c++运算符，类型转换，将一个表达式转换为某种类型，但没有运行时的类型检查来保证转换的安全</p> <p>cerr&lt;&lt;&quot;error&quot;&lt;&lt;endl;  //输出到标准错误的ostream对象，常用于程序错误信息；</p> <p>size_t：size type，一种用来记录大小的数据类型，表示C中任何对象所能达到的最大长度，它是无符号整数。size_t在32位系统上定义为 unsigned int，也就是32位无符号整型，4字节。在64位系统上定义为 unsigned long ，也就是64位无符号整形，8字节。</p> <h4 id="null和nullptr的区别"><a href="#null和nullptr的区别" class="header-anchor">#</a> NULL和nullptr的区别</h4> <p>在C语言中，NULL：
是一个宏，被定义为空指针，定义如下：#define NULL ((void *)0)
NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span>  <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>pc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>C++程序中的NULL，因为C++是强类型语言，void*是不能隐式转换成其他类型的指针的，所以实际上编译器提供的头文件做了相应的处理：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可见，在C++中，NULL实际上是0。因为C++中不能把void*类型的指针隐式转换成其他类型的指针，所以为了结果空指针的表示问题，C++引入了0来表示空指针，这样就有了上述代码中的NULL宏定义。
但是实际上，用NULL代替0表示空指针在函数重载时会出现问题，程序执行的结果会与我们的想法不同，举例如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;func1&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;func2&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><img src="/assets/1666951796042.png" alt="1666951796042"></p> <p>在这段代码中，我们对函数func进行可重载，参数分别是void*类型和int类型，但是运行结果却与我们使用NULL的初衷是相违背的，因为我们本来是想用NULL来代替空指针，但是在将NULL输入到函数中时，它却选择了int形参这个函数版本，所以是有问题的，这就是用NULL代替空指针在C++程序中的二义性。</p> <p>为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中特意引入了nullptr这一新的关键字来代指空指针，从上面的例子中我们可以看到，使用nullptr作为实参，确实选择了正确的以void*作为形参的函数版本。</p> <p>**总结：*<em>NULL在C++中就是0，这是因为在C++中void</em> 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用</p> <h4 id="c-的for循环中-i和i-的区别"><a href="#c-的for循环中-i和i-的区别" class="header-anchor">#</a> C++的for循环中++i和i++的区别：</h4> <p>最终输出的结果没有区别。
二者的实现代码如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>   A  <span class="token keyword">operator</span> <span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">//前++</span>
    <span class="token punctuation">{</span>
        i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    A  <span class="token keyword">operator</span> <span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>      <span class="token comment">//后++</span>
    <span class="token punctuation">{</span>
        A t<span class="token operator">=</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>          <span class="token comment">//先保存一份变量</span>
        <span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//调用前++</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>可以发现，i++需要一个暂时变量，然后将i加1后，返回的是暂时变量。而++i就是自增后返回i。
所以在<strong>空间损耗</strong>上，<strong>i++要略高于++i</strong>，因此，<strong>在不影响代码逻辑的前提下，要尽量使用++i</strong>。</p> <h4 id="无穷大与无穷小"><a href="#无穷大与无穷小" class="header-anchor">#</a> 无穷大与无穷小</h4> <p>如果是int，可以用INT_MAX表示正无穷，INT_MIN表示负无穷，需要包含limits.h。
如果是double，可以用DBL_MAX表示正无穷，-DBL_MAX表示负无穷(注意不是DBL_MIN)，需要包含float.h。</p> <p>返回值很奇怪，一般是没有初始化。</p> <p><img src="/assets/1679407169616.png" alt="1679407169616"></p> <p>逻辑都正确，出现不应该出现的error，很可能是数组访问下标越界。</p> <p><img src="/assets/1679402810832.png" alt="1679402810832"></p> <p>要把int改为long</p> <h4 id="template"><a href="#template" class="header-anchor">#</a> template</h4> <p>C++中的模板（template）是一种通用的编程工具，可以让我们编写可以处理多种数据类型的代码。模板可以用于函数、类和类成员函数，它们可以接受任意类型的参数，包括基本数据类型、自定义类型和STL容器等。使用模板可以提高代码的复用性和灵活性，可以减少代码量，提高代码的可读性和可维护性。</p> <h5 id="函数模板"><a href="#函数模板" class="header-anchor">#</a> 函数模板</h5> <p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p> <p><strong>语法：</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
函数声明或定义
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>解释：</strong></p> <p>template  ---  声明创建模板</p> <p>typename  --- 表面其后面的符号是一种数据类型，可以用class代替</p> <p>T    ---   通用的数据类型，名称可以替换，通常为大写字母</p> <h5 id="类模板"><a href="#类模板" class="header-anchor">#</a> 类模板</h5> <p>类模板作用：</p> <ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul> <p><strong>语法：</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
类
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>解释：</strong></p> <p>template  ---  声明创建模板</p> <p>typename  --- 表面其后面的符号是一种数据类型，可以用class代替</p> <p>T    ---   通用的数据类型，名称可以替换，通常为大写字母</p> <p>类模板在模板参数列表中可以有默认参数</p> <h4 id="iterator-type-base-const"><a href="#iterator-type-base-const" class="header-anchor">#</a> iterator_type base() const</h4> <p>函数后面加const关键字表示该函数一个const成员函数，它保证该函数不会修改对象的状态。</p> <p>在迭代器中，base() 函数返回迭代器所指向的底层迭代器，因此它不需要修改迭代器对象本身的状态。</p> <h4 id="证同函数"><a href="#证同函数" class="header-anchor">#</a> 证同函数</h4> <p>C++中的证同函数（identity function）通常用于模板编程中的类型转换或类型萃取。证同函数是一个模板函数，它接受一个参数并返回该参数，不对参数进行任何操作，因此被称为“证同函数”。</p> <p>在模板编程中，有时需要对某个类型进行转换或者获取该类型的某些属性，但是不希望对该类型进行任何修改，这时可以使用证同函数来实现。例如，可以使用如下的证同函数来获取某个类型的 const 版本：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">as_const</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在 C++11 中，也可以使用标准库中的 <code>std::identity</code> 函数模板来实现证同函数，例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">identity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 42</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">identity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 &quot;hello&quot;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这里的 <code>std::identity&lt;T&gt;</code> 是一个函数对象，它的 <code>operator()</code> 实现了证同函数的功能。</p> <h4 id="const-cast"><a href="#const-cast" class="header-anchor">#</a> const_cast</h4> <p><code>const_cast</code> 是 C++ 中的一个类型转换运算符，用于将常量指针或引用转换为非常量指针或引用，以便在程序中修改其所指向的值。需要注意的是，<code>const_cast</code> 只能用于去除常量性，而不能用于添加常量性。</p> <p>下面是一个示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">*</span>q <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 合法，但是会导致未定义行为</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在上面的示例中，<code>p</code> 是一个指向常量整数的指针，但是我们可以使用 <code>const_cast</code> 将其转换为一个指向非常量整数的指针 <code>q</code>，然后修改 <code>q</code> 所指向的值。需要注意的是，这样的行为会导致未定义行为，因为我们试图修改一个常量对象的值。因此，在实际编程中，我们应该避免这样的行为。</p> <h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="header-anchor">#</a> reinterpret_cast</h4> <p><code>reinterpret_cast</code> 是 C++ 中的一种类型转换运算符，用于在不同类型之间进行强制转换。它可以将一个指针或引用转换为一个完全不相关的类型，甚至可以将一个整数类型转换为指针类型或反之。</p> <p><code>reinterpret_cast</code> 的语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>new_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中，<code>new_type</code> 是要转换为的目标类型，<code>expression</code> 是要转换的表达式。</p> <p>下面是一些 <code>reinterpret_cast</code> 的使用示例：</p> <ol><li>将指针类型转换为另一个指针类型：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">*</span> charPtr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这个示例中，<code>ptr</code> 是一个 <code>int*</code> 类型的指针，通过 <code>reinterpret_cast</code> 将其转换为 <code>char*</code> 类型的指针 <code>charPtr</code>。这样做会改变指针的类型，但不会修改指针指向的数据。</p> <ol start="2"><li>将指针类型转换为整数类型：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
uintptr_t intVal <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>uintptr_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这个示例中，<code>ptr</code> 是一个 <code>int*</code> 类型的指针，通过 <code>reinterpret_cast</code> 将其转换为 <code>uintptr_t</code> 类型的整数 <code>intVal</code>。这样做可以将指针的值表示为一个整数，但不会修改指针指向的数据。</p> <ol start="3"><li>将整数类型转换为指针类型：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>uintptr_t intVal <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>intVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这个示例中，<code>intVal</code> 是一个 <code>uintptr_t</code> 类型的整数，通过 <code>reinterpret_cast</code> 将其转换为 <code>int*</code> 类型的指针 <code>ptr</code>。这样做会将整数解释为一个指针，但这可能是危险的，因为指针指向的数据可能是无效的。</p> <p>需要注意的是，使用 <code>reinterpret_cast</code> 进行类型转换存在一些限制和风险。由于它执行的是一种底层的类型转换，编译器不会进行任何类型检查或安全性验证。因此，在使用 <code>reinterpret_cast</code> 进行类型转换时，需要确保转换是合法的，并且要小心处理指针类型的转换，以避免潜在的错误和未定义行为。</p> <h4 id="remove-const"><a href="#remove-const" class="header-anchor">#</a> remove_const</h4> <p><code>remove_const</code> 是 C++ 中的类型转换模板，用于去除类型中的 <code>const</code> 修饰符。它可以将一个类型中的 <code>const</code> 修饰符移除，返回一个新的类型，该类型与原始类型除去 <code>const</code> 修饰符外的其他部分完全相同。</p> <p><code>remove_const</code> 的定义位于 <code>&lt;type_traits&gt;</code> 头文件中，是 C++ 标准库中的一部分。下面是 <code>remove_const</code> 的语法：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_const</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> remove_const_t <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">remove_const</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>remove_const</code> 是一个模板结构体，它接受一个类型 <code>T</code> 作为模板参数，并定义了一个名为 <code>type</code> 的内部类型，该类型是去除 <code>T</code> 中的 <code>const</code> 修饰符后的结果类型。</p> <p><code>remove_const_t</code> 是一个类型别名模板，它使用 <code>remove_const</code> 结构体的 <code>type</code> 成员类型作为其类型。</p> <p>下面是一些使用 <code>remove_const</code> 的示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> T1 <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
    <span class="token keyword">using</span> T2 <span class="token operator">=</span> remove_const_t<span class="token operator">&lt;</span>T1<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// T2 是 int 类型</span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same_v<span class="token operator">&lt;</span>T2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token string">&quot;T2 should be int&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">using</span> T3 <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token punctuation">;</span>
    <span class="token keyword">using</span> T4 <span class="token operator">=</span> remove_const_t<span class="token operator">&lt;</span>T3<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// T4 是 double 类型</span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same_v<span class="token operator">&lt;</span>T4<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token string">&quot;T4 should be double&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在上面的示例中，我们定义了两个类型 <code>T1</code> 和 <code>T3</code>，它们都是使用 <code>const</code> 修饰符修饰的类型。通过使用 <code>remove_const_t</code>，我们可以获得去除了 <code>const</code> 修饰符的类型 <code>T2</code> 和 <code>T4</code>，它们分别是 <code>int</code> 和 <code>double</code> 类型。</p> <p><code>remove_const</code> 在模板元编程中非常有用，可以帮助我们处理类型的特性和属性，并进行相应的类型转换和转型操作。</p> <h4 id="可变参数模板"><a href="#可变参数模板" class="header-anchor">#</a> 可变参数模板</h4> <p>这是 C++ 中的可变参数模板（Variadic Templates）语法，它允许定义一个接受可变数量参数的模板函数或模板类。在模板参数列表中使用 <code>...</code> 表示可变参数，它可以接受任意数量的参数，包括零个参数。</p> <p>例如，下面是一个接受任意数量参数的模板函数的定义：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">my_function</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在这个函数中，<code>Args...</code> 表示可变参数列表，<code>Args</code> 是参数包的名称，<code>args</code> 是参数包的实例。在函数体中，可以使用递归展开参数包，例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">my_function</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理单个参数的情况</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">my_function</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理多个参数的情况</span>
    <span class="token function">my_function</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归展开参数包</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个函数会递归展开参数包，并对每个参数进行处理。例如，如果调用 <code>my_function(1, &quot;hello&quot;, 3.14)</code>，则会依次调用 <code>my_function(1)</code>、<code>my_function(&quot;hello&quot;)</code> 和 <code>my_function(3.14)</code>。</p> <h4 id="左值和右值"><a href="#左值和右值" class="header-anchor">#</a> 左值和右值</h4> <p>在C++中，左值（lvalue）和右值（rvalue）是用于描述表达式的值类别的概念。它们的区别可以通过以下几个方面来理解：</p> <ol><li><p>定义：左值是可寻址的、有标识符的表达式，而右值是临时的、不可寻址的表达式。</p></li> <li><p>内存位置：左值表示一个具体的内存位置，可以通过地址运算符<code>&amp;</code>获取其地址。右值表示一个临时的值，没有明确的内存位置。</p></li> <li><p>生命周期：左值有持久的生命周期，可以在程序中持续存在。右值通常具有临时的生命周期，它们在表达式求值后很快就会被销毁。</p></li> <li><p>可修改性：左值是可修改的，可以通过左值引用修改其值。右值通常是不可修改的，因为它们是临时的或常量。</p></li> <li><p>值类别：左值是一个标识符，可以出现在赋值运算符的左边和右边。右值是一个临时的值，可以出现在赋值运算符的右边。</p></li></ol> <p>下面是一些示例来说明左值和右值的区别：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>         <span class="token comment">// x是左值，具有持久的内存位置</span>
<span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>     <span class="token comment">// &amp;x是左值，获取x的地址</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>         <span class="token comment">// x是左值，可以用于赋值操作</span>
<span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>     <span class="token comment">// x和y是左值，可以用于表达式计算</span>

<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// 10是右值，临时的，没有具体的内存位置</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>value<span class="token punctuation">;</span>  <span class="token comment">// &amp;value是右值，返回一个临时的指针</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment">// a是左值，具有持久的内存位置</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo()的返回值是右值，可以用于赋值</span>
    <span class="token keyword">int</span><span class="token operator">*</span> c <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// bar()的返回值是右值，可以用于赋值</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在上述示例中，变量<code>x</code>和<code>a</code>是左值，它们具有持久的内存位置，可以被引用和修改。函数<code>foo()</code>和<code>bar()</code>返回的是右值，它们是临时的、不可寻址的值。这些右值可以用于赋值操作，但它们的生命周期较短，不能被持久引用。</p> <p>总的来说，左值和右值是C++中描述表达式值类别的概念。左值具有持久的内存位置，可以被引用和修改。</p> <p>而右值是临时的、不可寻址的值。</p> <h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="header-anchor">#</a> 左值引用和右值引用</h4> <p>左值引用和右值引用有以下几个主要区别：</p> <ol><li><p>绑定对象类型：左值引用只能绑定到左值（可寻址的、有标识符的对象），而右值引用只能绑定到右值（临时对象、字面量、表达式结果等）。</p></li> <li><p>生命周期：左值引用可以延长绑定对象的生命周期，因为左值引用可以持续引用一个对象，直到它超出作用域。右值引用通常用于临时对象，其生命周期通常较短，当右值引用超出作用域时，绑定对象会被销毁。</p></li> <li><p>修改对象：左值引用可以修改绑定对象的状态或资源所有权，因为左值引用提供了对对象的直接访问。右值引用通常用于移动语义，通过转移资源的所有权而不进行深拷贝，从而提高性能。</p></li> <li><p>完美转发：右值引用可以与模板结合使用，实现完美转发，将参数以原始类型转发给其他函数，保持参数的值类别。左值引用无法实现完美转发，因为它无法区分传递的是左值还是右值。</p></li> <li><p>语法表示：左值引用使用单个<code>&amp;</code>符号表示，例如<code>int&amp;</code>；右值引用使用双<code>&amp;&amp;</code>符号表示，例如<code>int&amp;&amp;</code>。</p></li></ol> <p>总的来说，左值引用和右值引用在绑定对象类型、生命周期、修改对象和完美转发等方面有着明显的区别。左值引用主要用于提供别名和修改对象的状态，而右值引用主要用于移动语义和完美转发，以及临时对象的优化。它们在C++中提供了更灵活和高效的编程方式。</p> <p>左值引用和右值引用的区别可以通过以下具体例子来说明：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">modifyValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ref <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 修改绑定对象的值</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ref <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 读取绑定对象的值</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

    <span class="token function">modifyValue</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用左值引用修改x的值</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 使用左值引用读取x的值</span>

    <span class="token function">modifyValue</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 错误！无法将右值绑定到左值引用</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确！可以将右值绑定到常量左值引用</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在上述示例中，<code>modifyValue</code>函数使用左值引用来修改绑定对象的值，而<code>printValue</code>函数使用常量左值引用来读取绑定对象的值。可以看到，左值引用可以修改绑定对象的值，并且可以持续引用一个对象。</p> <p>然而，10是临时对象，当我们尝试将右值绑定到左值引用时（<code>modifyValue(10)</code>），会产生编译错误，因为左值引用只能绑定到左值。但是，我们可以将右值绑定到常量左值引用（<code>printValue(10)</code>），因为常量左值引用可以延长右值的生命周期，允许我们读取其值。</p> <p>为了演示右值引用的使用，我们可以考虑以下示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ref <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 读取绑定对象的值</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用右值引用读取临时对象的值</span>

    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用右值引用读取移动后的对象的值</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在上述示例中，<code>printValue</code>函数使用右值引用来读取绑定对象的值。我们可以直接将临时对象（右值）传递给右值引用参数（<code>printValue(10)</code>），或者使用<code>std::move</code>将左值转换为右值引用（<code>printValue(std::move(x))</code>）。右值引用的主要作用是在移动语义中使用，例如在移动构造函数或移动赋值运算符中，通过转移资源的所有权而不进行深拷贝，提高性能。</p> <p>这些例子展示了左值引用和右值引用在绑定对象、修改对象和传递参数等方面的区别。左值引用提供了对对象的直接访问和修改能力，而右值引用用于读取临时对象的值、实现移动语义和完美转发。</p> <h4 id="右值引用"><a href="#右值引用" class="header-anchor">#</a> 右值引用&amp;&amp;</h4> <p>右值引用是C++11引入的特性，它主要用于解决两个问题：避免不必要的数据拷贝和实现移动语义。</p> <p>右值引用通常用于以下情况：</p> <ol><li>移动语义：当我们需要将资源（如动态分配的内存、文件句柄等）从一个对象转移给另一个对象时，可以使用右值引用来实现高效的移动语义，避免不必要的数据拷贝。例如：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 移动构造函数</span>
    <span class="token function">MyString</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
        <span class="token comment">// 转移资源所有权</span>
        data <span class="token operator">=</span> other<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        length <span class="token operator">=</span> other<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 清空原对象</span>
        other<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        other<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 移动赋值运算符</span>
    MyString<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 释放当前对象的资源</span>
            <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>
            <span class="token comment">// 转移资源所有权</span>
            data <span class="token operator">=</span> other<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
            length <span class="token operator">=</span> other<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token comment">// 清空原对象</span>
            other<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
            other<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">char</span><span class="token operator">*</span> data<span class="token punctuation">;</span>
    size_t length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用移动语义创建对象</span>
MyString <span class="token function">str1</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
MyString <span class="token function">str2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用移动构造函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><ol start="2"><li>完美转发：右值引用还可以与模板结合使用，实现完美转发（perfect forwarding），即将参数按照原始类型转发给其他函数，保持参数的值类别不变。这在实现通用函数和函数模板时非常有用。例如：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用完美转发将参数传递给其他函数</span>
    <span class="token function">otherFunction</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用process函数</span>
<span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token function">process</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 传递左值</span>
<span class="token function">process</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 传递右值</span>
<span class="token function">process</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传递临时对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述例子中，process函数接收一个通用引用（Universal Reference）参数，通过std::forward函数将参数arg以原始类型转发给otherFunction函数，保持了传递参数时的值类别。</p> <p>总的来说，右值引用在需要实现高效的移动语义和完美转发时非常有用。它可以避免不必要的数据拷贝，提高性能，并允许更灵活地操作和管理对象的生命周期。</p> <h4 id="static-cast"><a href="#static-cast" class="header-anchor">#</a> static_cast</h4> <p><code>static_cast</code> 是 C++ 中的一种类型转换操作符，用于将一个类型的值转换为另一个类型的值。它可以用于将指针或引用类型转换为另一种指针或引用类型，也可以用于将一个算术类型转换为另一个算术类型。</p> <p><code>static_cast</code> 的语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中，<code>type</code> 是目标类型，<code>expression</code> 是要转换的表达式。</p> <p><code>static_cast</code> 的使用需要注意以下几点：</p> <ol><li><mark>只能用于编译时已知的类型转换</mark>，不能用于运行时的类型转换。</li> <li>只能进行相对安全的类型转换，例如将一个指针类型转换为另一个指针类型，但不能将一个指针类型转换为一个整数类型。</li> <li>在将一个指针类型转换为另一个指针类型时，需要确保目标类型是合法的，否则会导致未定义的行为。</li> <li>在将一个整数类型转换为另一个整数类型时，需要注意可能会发生截断或溢出的问题。</li></ol> <p>总之，<code>static_cast</code> 是 C++ 中一种常用的类型转换操作符，但需要谨慎使用，避免出现未定义的行为。</p> <h4 id="什么时候用const-cast和什么时候用static-cast"><a href="#什么时候用const-cast和什么时候用static-cast" class="header-anchor">#</a> 什么时候用const_cast和什么时候用static_cast</h4> <p>总之，<code>const_cast</code> 用于处理常量性的转换，而 <code>static_cast</code> 用于基本数据类型、类层次结构和指针之间的常见转换。在选择使用哪种转换操作时，要根据具体情况和类型安全性来进行判断，确保转换是合法且安全的。</p> <h4 id="assert"><a href="#assert" class="header-anchor">#</a> assert</h4> <p><code>assert</code> 是 C++ 标准库中的一个宏定义，用于在程序中进行断言检查。当程序运行到 <code>assert</code> 处时，会检查其参数是否为真，如果为假，则会触发一个断言错误，程序会终止并输出错误信息。</p> <p><code>assert</code> 宏的语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span>

<span class="token function">assert</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>其中，<code>expression</code> 是一个返回值为 <code>bool</code> 类型的表达式，通常用于检查程序中的某些假设是否成立。如果 <code>expression</code> 为假，则 <code>assert</code> 会输出错误信息，并终止程序的执行。</p> <p>在开发过程中，使用 <code>assert</code> 可以帮助我们快速发现程序中的错误，提高程序的健壮性和可靠性。但需要注意的是，<code>assert</code> 通常只在程序开发和调试阶段使用，发布版本中应该避免使用 <code>assert</code>。</p> <h4 id="cin"><a href="#cin" class="header-anchor">#</a> cin</h4> <p>在 C++ 中，<code>cin</code> 默认以空白字符（包括空格、制表符和换行符）作为输入的分隔符。这意味着 <code>cin</code> 在读取输入时会忽略空格和制表符，并在遇到换行符时结束输入。</p> <p>默认情况下，<code>cin</code> 在读取数据时会跳过前导空白字符（包括换行符），直到遇到非空白字符为止。然后，它会将非空白字符读入变量，并停止读取，不包括非空白字符后面的字符。</p> <h4 id="cin-get"><a href="#cin-get" class="header-anchor">#</a> cin.get()</h4> <p><code>cin.get()</code> 是 C++ 中用于从标准输入流（stdin）读取单个字符的函数。它可以用于读取输入中的换行符、空格或其他特殊字符。</p> <h4 id="const"><a href="#const" class="header-anchor">#</a> const &amp;</h4> <p>在 C++ 函数中，当传递参数时使用 <code>const &amp;</code> 的主要情况是为了实现常量引用传递（Const Reference），这样可以提高性能并确保不会修改传入的参数。以下是一些常见的使用情况：</p> <ol><li><p>避免不必要的复制：
通过将参数声明为 <code>const &amp;</code>，可以避免进行参数的复制构造函数调用，并且保证不会修改传入的参数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> message<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  string text <span class="token operator">=</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
  <span class="token function">printMessage</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过常量引用传递参数</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>提高性能：
对于大型对象或类类型的参数，使用 <code>const &amp;</code> 可以减少内存开销和函数调用的时间，因为不需要进行参数的拷贝构造。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">processObject</span><span class="token punctuation">(</span><span class="token keyword">const</span> Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 对 obj 进行操作</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object obj<span class="token punctuation">;</span> <span class="token comment">// 假设 Object 是一个大型对象类型</span>
  <span class="token function">processObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过常量引用传递大型对象</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>防止意外修改：
将参数声明为 <code>const &amp;</code> 可以明确表明函数不会修改传入的参数值，提供更好的代码可读性和安全性。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">displayVector</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> num <span class="token operator">:</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">displayVector</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过常量引用传递参数</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ol> <p>总结：
使用 <code>const &amp;</code> 来传递参数时，可以实现常量引用传递，避免不必要的复制、提高性能，并确保不会修改传入的参数。这样可以提高代码效率和安全性。</p> <h4 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h4> <p>在C++中，闭包（closure）通常指的是一个函数对象，它可以捕获并访问其定义范围之外的变量。这些被捕获的变量可以在闭包内部使用，就像局部变量一样。</p> <p>闭包是一个可调用的实体，它不仅包含了代码块（函数体），还记录了一些状态信息，其中最重要的就是它所捕获的变量。通过捕获外部作用域的变量，闭包可以在其定义范围之外继续访问和操作这些变量，即使定义这个闭包的上下文已经消失。</p> <p>使用闭包，我们可以在 C++ 中实现更灵活和功能强大的函数对象。闭包可以作为参数传递给其他函数，或者存储在容器中，以供后续使用。</p> <p>以下是一个简单的示例，展示了 C++ 中闭包的使用：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token comment">// 定义一个闭包，捕获变量x并进行操作</span>
    <span class="token keyword">auto</span> increment <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 增加变量x的值</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用闭包，增加变量x的值</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Updated x: &quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在上述示例中，我们定义了一个闭包 <code>increment</code>，它通过引用捕获了变量 <code>x</code>。在闭包的函数体内部，我们可以访问并操作变量 <code>x</code>。在调用闭包后，变量 <code>x</code> 的值被增加了一次。最后，我们打印出更新后的变量 <code>x</code> 的值。</p> <p>通过使用闭包，我们可以轻松地访问和操作外部作用域的变量，而无需将这些变量作为参数传递给函数或使用全局变量。闭包提供了一种方便的方式来创建具有状态的函数对象，增强了 C++ 中函数式编程的能力。</p> <h2 id="错误"><a href="#错误" class="header-anchor">#</a> 错误</h2> <p><strong>Line 8: Char 42: error: reference to non-static member function must be called</strong> <strong>sort(costs.begin(), costs.end(), compare);</strong></p> <p>这个错误是因为你在调用<code>sort</code>函数时，传递了一个非静态成员函数<code>compare</code>作为比较函数。非静态成员函数需要通过对象来调用，而<code>sort</code>函数期望传递一个可调用的函数对象或函数指针作为比较函数。</p> <p>要解决这个错误，你可以将<code>compare</code>函数改为静态成员函数或者将其定义为全局函数。这样就可以直接传递函数名作为比较函数，而不需要通过对象来调用。</p> <h4 id="编译的时候std-any能找到没出错-但是vscode里编辑时找不到std-any"><a href="#编译的时候std-any能找到没出错-但是vscode里编辑时找不到std-any" class="header-anchor">#</a> 编译的时候std::any能找到没出错，但是vscode里编辑时找不到std::any</h4> <p>std::any是C++17才有的标准库类</p> <p>如果你在编译时可以找到 <code>std::any</code> ，但在 VS Code 编辑器中无法找到它，可能是因为编辑器的标准库路径设置不正确导致的。</p> <p>VS Code 默认使用编辑器的内置 IntelliSense 功能进行代码补全和语法检查，但它使用的标准库路径可能与你的项目配置或编译器配置不一致。为了解决这个问题，你可以尝试以下步骤：</p> <ol><li><p>确认 C++ 标准版本：确保在 VS Code 中设置了正确的 C++ 标准版本。你可以在 <code>.vscode/settings.json</code> 文件中添加以下内容：</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">&quot;C_Cpp.default.cppStandard&quot;</span><span class="token operator">:</span> <span class="token string">&quot;c++17&quot;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这会将默认的 C++ 标准设置为 C++17，以匹配你的项目配置。</p></li> <li><p>更新 IntelliSense 配置：在 VS Code 中，你可以通过按下 <code>Ctrl+Shift+P</code> 并输入 &quot;C/C++: Edit Configurations (JSON)&quot; 来编辑 IntelliSense 配置文件。然后，在 <code>&quot;configurations&quot;</code> 下找到你的配置，并添加 <code>&quot;includePath&quot;</code> 和 <code>&quot;compilerPath&quot;</code> 字段，分别指定标准库的路径和编译器的路径。</p> <p>例如：</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">&quot;configurations&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
            <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Linux&quot;</span><span class="token punctuation">,</span>
            <span class="token property">&quot;includePath&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
                <span class="token string">&quot;${workspaceFolder}/**&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;/usr/include/c++/10&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;/usr/include/x86_64-linux-gnu/c++/10&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;/usr/include/c++/10/backward&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;/usr/lib/gcc/x86_64-linux-gnu/10/include&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;/usr/local/include&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;/usr/lib/gcc/x86_64-linux-gnu/10/include-fixed&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;/usr/include/x86_64-linux-gnu&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;/usr/include&quot;</span>
            <span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token property">&quot;compilerPath&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/usr/bin/g++&quot;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这样可以确保 IntelliSense 在编辑时能够正确找到标准库的位置。</p></li> <li><p>重启 VS Code：在进行以上更改后，重新启动 VS Code，以确保新的配置生效。</p></li></ol> <p>如果问题仍然存在，可能需要进一步检查你的 VS Code 配置、编译器设置和项目结构，以确定是否还有其他因素导致了此问题。</p> <h2 id="常用实例"><a href="#常用实例" class="header-anchor">#</a> 常用实例</h2> <h3 id="_1、函数与库的对应"><a href="#_1、函数与库的对应" class="header-anchor">#</a> 1、函数与库的对应</h3> <p>1、max()、min()、abs()、swap()、reverse()、sort()、find()、count()、search()在&lt;algorithm&gt;</p> <p>2、内建函数对象，greater&lt;&gt;()、less&lt;&gt;()、bind()在&lt;functional&gt;</p> <p>3、accumulate在&lt;numeric&gt;</p> <p>4、unordered_map在&lt;unordered_map&gt;，unordered_set在&lt;unordered_set&gt;</p> <h3 id="_2、常用操作"><a href="#_2、常用操作" class="header-anchor">#</a> 2、常用操作</h3> <p>bool型数据输出true/false，而并不是1/0</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cout <span class="token operator">&lt;&lt;</span> boolalpha <span class="token operator">&lt;&lt;</span> ss<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>字符空格用‘ ’表示</p> <h3 id="_3、数组"><a href="#_3、数组" class="header-anchor">#</a> 3、数组</h3> <h4 id="动态创建数组并输出"><a href="#动态创建数组并输出" class="header-anchor">#</a> 动态创建数组并输出</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> n<span class="token punctuation">;</span>   <span class="token comment">//输入数组长度</span>
cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>  <span class="token comment">//声明一个指针</span>
p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/*创建了一个长度为n的动态数组，并且返回这个数组的首地址给p，p就指向了这个动态数组，可以通过指针p来操作数组，因为创建的动态数组并没有名字，只返回了首地址给p，所以可以把p看作是这个动态数组的名字 */</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cin <span class="token operator">&gt;&gt;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>p<span class="token punctuation">;</span>  <span class="token comment">//释放这个一维的动态数组，而不是释放指针p。用完以后要记得释放掉</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//无注释版</span>
<span class="token keyword">int</span> n<span class="token punctuation">;</span>
cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cin <span class="token operator">&gt;&gt;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>p<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_4、vector"><a href="#_4、vector" class="header-anchor">#</a> 4、vector</h3> <h4 id="vector创建不定长的一组数据"><a href="#vector创建不定长的一组数据" class="header-anchor">#</a> vector创建不定长的一组数据</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">createVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ivec<span class="token punctuation">;</span>
	<span class="token keyword">int</span> num<span class="token punctuation">;</span>
	<span class="token keyword">do</span>
	<span class="token punctuation">{</span>
		cin <span class="token operator">&gt;&gt;</span> num<span class="token punctuation">;</span>
		ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//检测到换行键时，停止输入</span>
	<span class="token keyword">return</span> ivec<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//返回值vector&lt;int&gt;是要返回vector容器，int则是返回整数</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">createVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">;</span>
	<span class="token keyword">int</span> tmp<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
		nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> nums<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><blockquote><p>注：
a. 以空格为间隔输入数组
b. 输入完成，回车必须紧跟最后一个数字，若回车前是空格，则此回车会像空格一样被忽略</p></blockquote> <h4 id="手动创建vector容器嵌套容器"><a href="#手动创建vector容器嵌套容器" class="header-anchor">#</a> 手动创建vector容器嵌套容器</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> intervals <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token function">printVectorInVector</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="vector容器打印"><a href="#vector容器打印" class="header-anchor">#</a> vector容器打印</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">printVector</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">printVector</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="vector容器嵌套容器的打印"><a href="#vector容器嵌套容器的打印" class="header-anchor">#</a> vector容器嵌套容器的打印</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">printVectorInVector</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//通过大容器，把所有数据遍历一遍</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">//(*it) ---- 容器 vector&lt;int&gt;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator vit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> vit <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> vit<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>vit <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//每一个小容器输出，输出完了做一个换行的操作</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="求容器中的最大最小值"><a href="#求容器中的最大最小值" class="header-anchor">#</a> 求容器中的最大最小值</h4> <p><strong>方法：</strong> <code>min_element</code>和<code>max_element</code>
输入参数为<code>vector</code>迭代器，输出为单一元素迭代器，要获得变量需要加*</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> maxPosition <span class="token operator">=</span> <span class="token function">max_element</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> minPosition <span class="token operator">=</span> <span class="token function">min_element</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>maxPosition <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; at the postion of &quot;</span> <span class="token operator">&lt;&lt;</span> maxPosition <span class="token operator">-</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>minPosition <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; at the postion of &quot;</span> <span class="token operator">&lt;&lt;</span> maxPosition <span class="token operator">-</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><img src="/assets/1670400864834-1670400864939.png" alt="1670400864834"></p> <h3 id="_5、字符串"><a href="#_5、字符串" class="header-anchor">#</a> 5、字符串</h3> <h4 id="输入一个不带空格的字符串"><a href="#输入一个不带空格的字符串" class="header-anchor">#</a> 输入一个不带空格的字符串</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string str<span class="token punctuation">;</span>
cin <span class="token operator">&gt;&gt;</span> str<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="输入一个带空格的字符串"><a href="#输入一个带空格的字符串" class="header-anchor">#</a> 输入一个带空格的字符串</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>string str<span class="token punctuation">;</span>
<span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="常用函数"><a href="#常用函数" class="header-anchor">#</a> 常用函数</h4> <p>substr</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// substr有2种用法：</span>
<span class="token comment">// 假设：string s = &quot;0123456789&quot;;</span>

string sub1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只有一个数字5表示从下标为5开始一直到结尾：sub1 = &quot;56789&quot;</span>

string sub2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从下标为5开始截取长度为3位：sub2 = &quot;567&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>stoi
string-&gt;int
作用是将 n 进制的字符串转化为十进制，使用时包含头文件string.
定义如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">stoi</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

参数：
str <span class="token operator">-</span> 待转换的字符
pos <span class="token operator">-</span> 其取值可以是一个空字符，在这种情况下，pos未被使用；另外如果pos不是空指针，函数将pos的值设置为str中数字后面的第一个字符的位置。
base <span class="token operator">-</span> 字符中数字的进制，默认为<span class="token number">10</span>进制，如果base取值为<span class="token number">0</span>，则进制由字符串中的格式决定。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_6、链表"><a href="#_6、链表" class="header-anchor">#</a> 6、链表</h3> <h4 id="尾插法创建不定长的单向链表-带头结点"><a href="#尾插法创建不定长的单向链表-带头结点" class="header-anchor">#</a> 尾插法创建不定长的单向链表（带头结点）</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//尾插法创建不定长的单向链表（带头结点）</span>
<span class="token keyword">void</span> <span class="token function">createListTail</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//r、L指向头结点</span>
	ListNode<span class="token operator">*</span> r <span class="token operator">=</span> L<span class="token punctuation">;</span>
	<span class="token keyword">do</span> <span class="token punctuation">{</span>
		ListNode<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
		cin <span class="token operator">&gt;&gt;</span> p<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>  <span class="token comment">//循环创建p，输入结点数据</span>
		p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
		r <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="尾插法创建不定长的单向链表-不带头结点"><a href="#尾插法创建不定长的单向链表-不带头结点" class="header-anchor">#</a> 尾插法创建不定长的单向链表（不带头结点）</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//不带头结点</span>
<span class="token keyword">void</span> <span class="token function">createListTail</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//r、L直接指向首元结点而不是头结点</span>
	ListNode<span class="token operator">*</span> r <span class="token operator">=</span> L<span class="token punctuation">;</span>
    <span class="token comment">//第一次先输入首元结点的数据</span>
	cin <span class="token operator">&gt;&gt;</span> r<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
	<span class="token keyword">do</span> <span class="token punctuation">{</span>
		ListNode<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
		cin <span class="token operator">&gt;&gt;</span> p<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>  <span class="token comment">//循环创建p，输入结点数据</span>
		p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
		r <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//尾插法创建不定长的单向链表</span>
<span class="token comment">//不带头结点</span>
<span class="token comment">//返回值类型直接为ListNode*</span>
ListNode<span class="token operator">*</span> <span class="token function">createListTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ListNode<span class="token operator">*</span> L<span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> r <span class="token operator">=</span> L<span class="token punctuation">;</span>
	cin <span class="token operator">&gt;&gt;</span> r<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
	<span class="token keyword">do</span> <span class="token punctuation">{</span>
		ListNode<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
		cin <span class="token operator">&gt;&gt;</span> p<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>  <span class="token comment">//循环创建p，输入结点数据</span>
		p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
		r <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> L<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//new出来的L，并且返回了，记得delete掉</span>
<span class="token keyword">delete</span> L<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="输出链表元素-带头结点"><a href="#输出链表元素-带头结点" class="header-anchor">#</a> 输出链表元素（带头结点）</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//输出链表元素</span>
<span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ListNode<span class="token operator">*</span> p <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>val<span class="token operator">&lt;&lt;</span><span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="输出链表元素-不带头结点"><a href="#输出链表元素-不带头结点" class="header-anchor">#</a> 输出链表元素（不带头结点）</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//输出链表元素</span>
<span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ListNode<span class="token operator">*</span> p <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>val<span class="token operator">&lt;&lt;</span><span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_7、树"><a href="#_7、树" class="header-anchor">#</a> 7、树</h3> <h4 id="根据数组-层次法创建二叉树"><a href="#根据数组-层次法创建二叉树" class="header-anchor">#</a> 根据数组，层次法创建二叉树</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token comment">//根据数组，层次法创建二叉树</span>
TreeNode<span class="token operator">*</span> <span class="token function">createTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">//层次法创建二叉树</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//数值为0或超出数组范围</span>
        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//创建所使用的数组</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">levelOrderIter</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h4 id="二叉树的遍历-并输出"><a href="#二叉树的遍历-并输出" class="header-anchor">#</a> 二叉树的遍历，并输出</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>

<span class="token comment">//层次遍历，迭代法</span>
<span class="token keyword">void</span> <span class="token function">levelOrderIter</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> que<span class="token punctuation">;</span>
    que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>val <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//中序遍历，迭代法  左-根-右</span>
<span class="token keyword">void</span> <span class="token function">InOrderIter</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>nodes<span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
    stack<span class="token operator">&lt;</span>TreeNode <span class="token operator">*</span><span class="token operator">&gt;</span> stk<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        root <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nodes<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root <span class="token operator">=</span> root<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">levelOrderIter</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><h3 id="数学"><a href="#数学" class="header-anchor">#</a> 数学</h3> <h4 id="公倍数与公因数"><a href="#公倍数与公因数" class="header-anchor">#</a> 公倍数与公因数</h4></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/smileatl/smileatlRepository_source/edit/master/docs/05.工作/10.编程语言-C++/05.C++初识/10.myC++.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/12/04, 16:45:12</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/8cd9f7/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">C++提高编程</div></a> <a href="/pages/10526c/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">STL</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/8cd9f7/" class="prev">C++提高编程</a></span> <span class="next"><a href="/pages/10526c/">STL</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/93a902/"><div>
            cpp新特性
            <!----></div></a> <span class="date">12-04</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/163c8a/"><div>
            复刷还是没记住的题
            <!----></div></a> <span class="date">12-04</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/2aa569/"><div>
            计算机网络
            <!----></div></a> <span class="date">12-04</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1355484300@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/smileatl" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span>smileatl | <a href="https://github.com/smileatl/smileatlRepository_source/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4813674f.js" defer></script><script src="/assets/js/3.cf27d530.js" defer></script><script src="/assets/js/41.2cd990a4.js" defer></script>
  </body>
</html>
