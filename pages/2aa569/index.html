<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | SAL Repo</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/website_icon.png">
    <meta name="description" content="smileatl个人知识库，用于工作、学习、生活的总结。">
    <meta name="keywords" content="smileatl个人知识库，用于工作、学习、生活的总结。">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.27efc831.css" as="style"><link rel="preload" href="/assets/js/app.4813674f.js" as="script"><link rel="preload" href="/assets/js/3.cf27d530.js" as="script"><link rel="preload" href="/assets/js/183.0f688ed3.js" as="script"><link rel="prefetch" href="/assets/js/10.57c72187.js"><link rel="prefetch" href="/assets/js/100.76551019.js"><link rel="prefetch" href="/assets/js/101.909b1f6a.js"><link rel="prefetch" href="/assets/js/102.b4df429c.js"><link rel="prefetch" href="/assets/js/103.36718b70.js"><link rel="prefetch" href="/assets/js/104.8247d5e5.js"><link rel="prefetch" href="/assets/js/105.ae996141.js"><link rel="prefetch" href="/assets/js/106.664e0ec8.js"><link rel="prefetch" href="/assets/js/107.34387111.js"><link rel="prefetch" href="/assets/js/108.24bd216e.js"><link rel="prefetch" href="/assets/js/109.0ce14ec5.js"><link rel="prefetch" href="/assets/js/11.a6b1ea70.js"><link rel="prefetch" href="/assets/js/110.225cb77d.js"><link rel="prefetch" href="/assets/js/111.987f1649.js"><link rel="prefetch" href="/assets/js/112.804919d1.js"><link rel="prefetch" href="/assets/js/113.61edc8e7.js"><link rel="prefetch" href="/assets/js/114.a2199a4f.js"><link rel="prefetch" href="/assets/js/115.919528ee.js"><link rel="prefetch" href="/assets/js/116.1e165300.js"><link rel="prefetch" href="/assets/js/117.b62cd913.js"><link rel="prefetch" href="/assets/js/118.157a5849.js"><link rel="prefetch" href="/assets/js/119.335bb0f4.js"><link rel="prefetch" href="/assets/js/12.f97190ac.js"><link rel="prefetch" href="/assets/js/120.8ca841a0.js"><link rel="prefetch" href="/assets/js/121.09ef443a.js"><link rel="prefetch" href="/assets/js/122.133de093.js"><link rel="prefetch" href="/assets/js/123.8b5fcdde.js"><link rel="prefetch" href="/assets/js/124.8aef67d0.js"><link rel="prefetch" href="/assets/js/125.07949d7c.js"><link rel="prefetch" href="/assets/js/126.6557ef27.js"><link rel="prefetch" href="/assets/js/127.e2c838f8.js"><link rel="prefetch" href="/assets/js/128.e876bdf8.js"><link rel="prefetch" href="/assets/js/129.0e7d15bb.js"><link rel="prefetch" href="/assets/js/13.ae62b090.js"><link rel="prefetch" href="/assets/js/130.8caf4288.js"><link rel="prefetch" href="/assets/js/131.d091a5f7.js"><link rel="prefetch" href="/assets/js/132.3af86ba2.js"><link rel="prefetch" href="/assets/js/133.9b473677.js"><link rel="prefetch" href="/assets/js/134.d09f520d.js"><link rel="prefetch" href="/assets/js/135.5094d6c6.js"><link rel="prefetch" href="/assets/js/136.f554265c.js"><link rel="prefetch" href="/assets/js/137.db8ad307.js"><link rel="prefetch" href="/assets/js/138.97a9f7dc.js"><link rel="prefetch" href="/assets/js/139.28a187da.js"><link rel="prefetch" href="/assets/js/14.7c89dfed.js"><link rel="prefetch" href="/assets/js/140.58f327a0.js"><link rel="prefetch" href="/assets/js/141.dac9c32e.js"><link rel="prefetch" href="/assets/js/142.15e4cd8a.js"><link rel="prefetch" href="/assets/js/143.29bcf51a.js"><link rel="prefetch" href="/assets/js/144.93e792a5.js"><link rel="prefetch" href="/assets/js/145.1e479d7f.js"><link rel="prefetch" href="/assets/js/146.fef6b20d.js"><link rel="prefetch" href="/assets/js/147.a8939180.js"><link rel="prefetch" href="/assets/js/148.73ab52d1.js"><link rel="prefetch" href="/assets/js/149.de7d77b9.js"><link rel="prefetch" href="/assets/js/15.4266d5a5.js"><link rel="prefetch" href="/assets/js/150.14cd4f5b.js"><link rel="prefetch" href="/assets/js/151.ae320b72.js"><link rel="prefetch" href="/assets/js/152.9f70308b.js"><link rel="prefetch" href="/assets/js/153.8bb08923.js"><link rel="prefetch" href="/assets/js/154.bef6a0fb.js"><link rel="prefetch" href="/assets/js/155.e0e21ff7.js"><link rel="prefetch" href="/assets/js/156.e212e95d.js"><link rel="prefetch" href="/assets/js/157.9af3323d.js"><link rel="prefetch" href="/assets/js/158.a6990b68.js"><link rel="prefetch" href="/assets/js/159.9921842e.js"><link rel="prefetch" href="/assets/js/16.4d11e9b4.js"><link rel="prefetch" href="/assets/js/160.cb690287.js"><link rel="prefetch" href="/assets/js/161.10ec68a7.js"><link rel="prefetch" href="/assets/js/162.5e2e8da5.js"><link rel="prefetch" href="/assets/js/163.7ad3dc89.js"><link rel="prefetch" href="/assets/js/164.0677e91f.js"><link rel="prefetch" href="/assets/js/165.eabba413.js"><link rel="prefetch" href="/assets/js/166.de181132.js"><link rel="prefetch" href="/assets/js/167.eb1f2c20.js"><link rel="prefetch" href="/assets/js/168.33870baa.js"><link rel="prefetch" href="/assets/js/169.0eb4e75c.js"><link rel="prefetch" href="/assets/js/17.2f17b760.js"><link rel="prefetch" href="/assets/js/170.6a8f837b.js"><link rel="prefetch" href="/assets/js/171.33c99890.js"><link rel="prefetch" href="/assets/js/172.e2ac6d6c.js"><link rel="prefetch" href="/assets/js/173.f37baa2e.js"><link rel="prefetch" href="/assets/js/174.3f1765d5.js"><link rel="prefetch" href="/assets/js/175.ee3e624a.js"><link rel="prefetch" href="/assets/js/176.b7c3d2ba.js"><link rel="prefetch" href="/assets/js/177.538dbd98.js"><link rel="prefetch" href="/assets/js/178.688b2ab3.js"><link rel="prefetch" href="/assets/js/179.7605eb3a.js"><link rel="prefetch" href="/assets/js/18.46454e6b.js"><link rel="prefetch" href="/assets/js/180.f734c479.js"><link rel="prefetch" href="/assets/js/181.f009bfc4.js"><link rel="prefetch" href="/assets/js/182.51a8e6fc.js"><link rel="prefetch" href="/assets/js/184.e20ab6d5.js"><link rel="prefetch" href="/assets/js/185.336035f1.js"><link rel="prefetch" href="/assets/js/186.e7f18b72.js"><link rel="prefetch" href="/assets/js/187.20bae185.js"><link rel="prefetch" href="/assets/js/188.4d746641.js"><link rel="prefetch" href="/assets/js/189.45442618.js"><link rel="prefetch" href="/assets/js/19.07e2632b.js"><link rel="prefetch" href="/assets/js/190.6f6c4889.js"><link rel="prefetch" href="/assets/js/191.b73399a8.js"><link rel="prefetch" href="/assets/js/192.657f63ce.js"><link rel="prefetch" href="/assets/js/193.348754cf.js"><link rel="prefetch" href="/assets/js/194.7ea4e875.js"><link rel="prefetch" href="/assets/js/195.011c9aaa.js"><link rel="prefetch" href="/assets/js/196.30ca323d.js"><link rel="prefetch" href="/assets/js/197.b404290d.js"><link rel="prefetch" href="/assets/js/198.19eeb699.js"><link rel="prefetch" href="/assets/js/199.578524cd.js"><link rel="prefetch" href="/assets/js/20.e8632e9e.js"><link rel="prefetch" href="/assets/js/200.2483c16f.js"><link rel="prefetch" href="/assets/js/201.80be911a.js"><link rel="prefetch" href="/assets/js/202.6292d716.js"><link rel="prefetch" href="/assets/js/203.0423f992.js"><link rel="prefetch" href="/assets/js/204.220cf5d5.js"><link rel="prefetch" href="/assets/js/205.cf88ea69.js"><link rel="prefetch" href="/assets/js/206.7837a407.js"><link rel="prefetch" href="/assets/js/207.15eb7f61.js"><link rel="prefetch" href="/assets/js/208.c92b54ae.js"><link rel="prefetch" href="/assets/js/209.d6858997.js"><link rel="prefetch" href="/assets/js/21.9d97eca0.js"><link rel="prefetch" href="/assets/js/210.3a916b1e.js"><link rel="prefetch" href="/assets/js/211.99ca202d.js"><link rel="prefetch" href="/assets/js/212.18a13454.js"><link rel="prefetch" href="/assets/js/213.7eb5f7fd.js"><link rel="prefetch" href="/assets/js/214.178507b3.js"><link rel="prefetch" href="/assets/js/215.e9eac7bd.js"><link rel="prefetch" href="/assets/js/216.bdd656c6.js"><link rel="prefetch" href="/assets/js/217.487e6997.js"><link rel="prefetch" href="/assets/js/218.eb54add1.js"><link rel="prefetch" href="/assets/js/219.43da1c82.js"><link rel="prefetch" href="/assets/js/22.ed6e719f.js"><link rel="prefetch" href="/assets/js/220.757359d6.js"><link rel="prefetch" href="/assets/js/221.d58f156a.js"><link rel="prefetch" href="/assets/js/222.99dc1661.js"><link rel="prefetch" href="/assets/js/223.22a61d2b.js"><link rel="prefetch" href="/assets/js/224.514138b9.js"><link rel="prefetch" href="/assets/js/225.fc56b049.js"><link rel="prefetch" href="/assets/js/226.59d64fed.js"><link rel="prefetch" href="/assets/js/227.8841cf23.js"><link rel="prefetch" href="/assets/js/228.f37358c2.js"><link rel="prefetch" href="/assets/js/229.97cb9c4e.js"><link rel="prefetch" href="/assets/js/23.5eccc486.js"><link rel="prefetch" href="/assets/js/230.a16ada6a.js"><link rel="prefetch" href="/assets/js/231.5f761bf3.js"><link rel="prefetch" href="/assets/js/232.76d78495.js"><link rel="prefetch" href="/assets/js/233.162bba41.js"><link rel="prefetch" href="/assets/js/234.a845dfca.js"><link rel="prefetch" href="/assets/js/235.169ff72d.js"><link rel="prefetch" href="/assets/js/236.c50d9ecf.js"><link rel="prefetch" href="/assets/js/237.594eecee.js"><link rel="prefetch" href="/assets/js/238.b599dae8.js"><link rel="prefetch" href="/assets/js/239.7be81ebe.js"><link rel="prefetch" href="/assets/js/24.c81753d3.js"><link rel="prefetch" href="/assets/js/240.b9f18f9e.js"><link rel="prefetch" href="/assets/js/241.77d17f60.js"><link rel="prefetch" href="/assets/js/242.0894cddd.js"><link rel="prefetch" href="/assets/js/243.4c71e0af.js"><link rel="prefetch" href="/assets/js/244.47579b9c.js"><link rel="prefetch" href="/assets/js/245.29344e11.js"><link rel="prefetch" href="/assets/js/246.410a1027.js"><link rel="prefetch" href="/assets/js/247.b22fa817.js"><link rel="prefetch" href="/assets/js/25.f3141c92.js"><link rel="prefetch" href="/assets/js/26.573fd0de.js"><link rel="prefetch" href="/assets/js/27.9a72220d.js"><link rel="prefetch" href="/assets/js/28.e161668a.js"><link rel="prefetch" href="/assets/js/29.6d2ef014.js"><link rel="prefetch" href="/assets/js/30.0dd2ba52.js"><link rel="prefetch" href="/assets/js/31.e8c4ee1d.js"><link rel="prefetch" href="/assets/js/32.c57cfa4e.js"><link rel="prefetch" href="/assets/js/33.7c1ec4ff.js"><link rel="prefetch" href="/assets/js/34.110d90ae.js"><link rel="prefetch" href="/assets/js/35.c5fbf1bd.js"><link rel="prefetch" href="/assets/js/36.58d307d9.js"><link rel="prefetch" href="/assets/js/37.6e68d82d.js"><link rel="prefetch" href="/assets/js/38.0a2bfb96.js"><link rel="prefetch" href="/assets/js/39.79a25586.js"><link rel="prefetch" href="/assets/js/4.10092391.js"><link rel="prefetch" href="/assets/js/40.1b3fb2c7.js"><link rel="prefetch" href="/assets/js/41.2cd990a4.js"><link rel="prefetch" href="/assets/js/42.3803a3ba.js"><link rel="prefetch" href="/assets/js/43.56cde0b8.js"><link rel="prefetch" href="/assets/js/44.98f12e35.js"><link rel="prefetch" href="/assets/js/45.bbed8377.js"><link rel="prefetch" href="/assets/js/46.80af516b.js"><link rel="prefetch" href="/assets/js/47.bfe18f20.js"><link rel="prefetch" href="/assets/js/48.e4bead99.js"><link rel="prefetch" href="/assets/js/49.da1a7c67.js"><link rel="prefetch" href="/assets/js/5.0b5a1289.js"><link rel="prefetch" href="/assets/js/50.b6011d95.js"><link rel="prefetch" href="/assets/js/51.81adcdd5.js"><link rel="prefetch" href="/assets/js/52.b650e175.js"><link rel="prefetch" href="/assets/js/53.22c44460.js"><link rel="prefetch" href="/assets/js/54.3c9964c8.js"><link rel="prefetch" href="/assets/js/55.80bec639.js"><link rel="prefetch" href="/assets/js/56.2066f85f.js"><link rel="prefetch" href="/assets/js/57.ab6dbc19.js"><link rel="prefetch" href="/assets/js/58.6236e7f0.js"><link rel="prefetch" href="/assets/js/59.618e25d3.js"><link rel="prefetch" href="/assets/js/6.a1e90b5b.js"><link rel="prefetch" href="/assets/js/60.3deac196.js"><link rel="prefetch" href="/assets/js/61.890283e9.js"><link rel="prefetch" href="/assets/js/62.ffe465e9.js"><link rel="prefetch" href="/assets/js/63.cc9a42cc.js"><link rel="prefetch" href="/assets/js/64.c66e6c4f.js"><link rel="prefetch" href="/assets/js/65.95e3ddfd.js"><link rel="prefetch" href="/assets/js/66.256b023f.js"><link rel="prefetch" href="/assets/js/67.436df8a0.js"><link rel="prefetch" href="/assets/js/68.d532ffa8.js"><link rel="prefetch" href="/assets/js/69.963c3596.js"><link rel="prefetch" href="/assets/js/7.74944cf6.js"><link rel="prefetch" href="/assets/js/70.6dfd1704.js"><link rel="prefetch" href="/assets/js/71.53af90e0.js"><link rel="prefetch" href="/assets/js/72.580797e8.js"><link rel="prefetch" href="/assets/js/73.5c14d158.js"><link rel="prefetch" href="/assets/js/74.70cf381f.js"><link rel="prefetch" href="/assets/js/75.01dbab82.js"><link rel="prefetch" href="/assets/js/76.18b48db2.js"><link rel="prefetch" href="/assets/js/77.0fa8965d.js"><link rel="prefetch" href="/assets/js/78.bede6ca6.js"><link rel="prefetch" href="/assets/js/79.1c7c8167.js"><link rel="prefetch" href="/assets/js/8.fbc0181a.js"><link rel="prefetch" href="/assets/js/80.688d4c3b.js"><link rel="prefetch" href="/assets/js/81.4eaaee90.js"><link rel="prefetch" href="/assets/js/82.53bf5bf4.js"><link rel="prefetch" href="/assets/js/83.53cdee38.js"><link rel="prefetch" href="/assets/js/84.848d09d8.js"><link rel="prefetch" href="/assets/js/85.4ef416fa.js"><link rel="prefetch" href="/assets/js/86.559b9784.js"><link rel="prefetch" href="/assets/js/87.1317f521.js"><link rel="prefetch" href="/assets/js/88.61e1f1fa.js"><link rel="prefetch" href="/assets/js/89.c37979bc.js"><link rel="prefetch" href="/assets/js/9.acdf956e.js"><link rel="prefetch" href="/assets/js/90.329e7956.js"><link rel="prefetch" href="/assets/js/91.e9246182.js"><link rel="prefetch" href="/assets/js/92.41e1ecaf.js"><link rel="prefetch" href="/assets/js/93.6cbe0205.js"><link rel="prefetch" href="/assets/js/94.922231b5.js"><link rel="prefetch" href="/assets/js/95.23cfae7c.js"><link rel="prefetch" href="/assets/js/96.790a39b9.js"><link rel="prefetch" href="/assets/js/97.8ce2cb69.js"><link rel="prefetch" href="/assets/js/98.f016d83e.js"><link rel="prefetch" href="/assets/js/99.b1d81562.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.96cada6e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.27efc831.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/website_icon.png" alt="SAL Repo" class="logo"> <span class="site-name can-hide">SAL Repo</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工作" class="dropdown-title"><a href="/work/" class="link-title">工作</a> <span class="title" style="display:none;">工作</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>编程语言</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/C/" class="nav-link">C</a></li><li class="dropdown-subitem"><a href="/work/C++/" class="nav-link">C++</a></li><li class="dropdown-subitem"><a href="/work/Script_Language/" class="nav-link">Script_Language</a></li></ul></li><li class="dropdown-item"><h4>计算机知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Linux/" class="nav-link">Linux</a></li><li class="dropdown-subitem"><a href="/work/dataStruct/" class="nav-link">数据机构与算法</a></li><li class="dropdown-subitem"><a href="/work/OS/" class="nav-link">操作系统</a></li><li class="dropdown-subitem"><a href="/work/network/" class="nav-link">计算机网络</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/MySQL/" class="nav-link">MySQL</a></li><li class="dropdown-subitem"><a href="/work/Redis/" class="nav-link">Redis</a></li></ul></li><li class="dropdown-item"><h4>工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Git/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/work/VM/" class="nav-link">虚拟机</a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/leetcode/" class="nav-link">刷题</a></li><li class="dropdown-subitem"><a href="/work/bg/" class="nav-link">interview</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/project/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/mynetlib/" class="nav-link">mynetlib</a></li><li class="dropdown-item"><!----> <a href="/project/mymprpc/" class="nav-link">mymprpc</a></li><li class="dropdown-item"><!----> <a href="/project/mytinystl/" class="nav-link">mytinystl</a></li><li class="dropdown-item"><!----> <a href="/project/DML/" class="nav-link">DML</a></li><li class="dropdown-item"><!----> <a href="/project/FL/" class="nav-link">FL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学习" class="dropdown-title"><a href="/study/" class="link-title">学习</a> <span class="title" style="display:none;">学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>研究生</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/publications/" class="nav-link">publications</a></li><li class="dropdown-subitem"><a href="/study/ML/" class="nav-link">机器学习</a></li></ul></li><li class="dropdown-item"><h4>阅读</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/read/" class="nav-link">个人摘抄</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="生活" class="dropdown-title"><a href="/life/" class="link-title">生活</a> <span class="title" style="display:none;">生活</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/71024e/" class="nav-link">生活</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/collection/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>总览</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/collection/favorites/" class="nav-link">个人收藏夹</a></li><li class="dropdown-subitem"><a href="/collection/download/" class="nav-link">资源下载</a></li></ul></li><li class="dropdown-item"><h4>快速链接</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://sci-hub.wf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SCI-HUB
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/collection/favorites/#文件转换、解密工具" class="nav-link">文件转换、解密工具</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>索引</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-subitem"><a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-subitem"><a href="/archives/" class="nav-link">归档</a></li></ul></li><li class="dropdown-item"><h4>友链</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/friends/" class="nav-link">友情链接</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <a href="https://github.com/smileatl/smileatlRepository_source" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/avatar.jpg"> <div class="blogger-info"><h3>smileatl</h3> <span>smileatl, Songlei Lin</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工作" class="dropdown-title"><a href="/work/" class="link-title">工作</a> <span class="title" style="display:none;">工作</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>编程语言</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/C/" class="nav-link">C</a></li><li class="dropdown-subitem"><a href="/work/C++/" class="nav-link">C++</a></li><li class="dropdown-subitem"><a href="/work/Script_Language/" class="nav-link">Script_Language</a></li></ul></li><li class="dropdown-item"><h4>计算机知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Linux/" class="nav-link">Linux</a></li><li class="dropdown-subitem"><a href="/work/dataStruct/" class="nav-link">数据机构与算法</a></li><li class="dropdown-subitem"><a href="/work/OS/" class="nav-link">操作系统</a></li><li class="dropdown-subitem"><a href="/work/network/" class="nav-link">计算机网络</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/MySQL/" class="nav-link">MySQL</a></li><li class="dropdown-subitem"><a href="/work/Redis/" class="nav-link">Redis</a></li></ul></li><li class="dropdown-item"><h4>工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/Git/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/work/VM/" class="nav-link">虚拟机</a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/work/leetcode/" class="nav-link">刷题</a></li><li class="dropdown-subitem"><a href="/work/bg/" class="nav-link">interview</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/project/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/mynetlib/" class="nav-link">mynetlib</a></li><li class="dropdown-item"><!----> <a href="/project/mymprpc/" class="nav-link">mymprpc</a></li><li class="dropdown-item"><!----> <a href="/project/mytinystl/" class="nav-link">mytinystl</a></li><li class="dropdown-item"><!----> <a href="/project/DML/" class="nav-link">DML</a></li><li class="dropdown-item"><!----> <a href="/project/FL/" class="nav-link">FL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学习" class="dropdown-title"><a href="/study/" class="link-title">学习</a> <span class="title" style="display:none;">学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>研究生</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/publications/" class="nav-link">publications</a></li><li class="dropdown-subitem"><a href="/study/ML/" class="nav-link">机器学习</a></li></ul></li><li class="dropdown-item"><h4>阅读</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/read/" class="nav-link">个人摘抄</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="生活" class="dropdown-title"><a href="/life/" class="link-title">生活</a> <span class="title" style="display:none;">生活</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/71024e/" class="nav-link">生活</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/collection/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>总览</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/collection/favorites/" class="nav-link">个人收藏夹</a></li><li class="dropdown-subitem"><a href="/collection/download/" class="nav-link">资源下载</a></li></ul></li><li class="dropdown-item"><h4>快速链接</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://sci-hub.wf/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  SCI-HUB
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/collection/favorites/#文件转换、解密工具" class="nav-link">文件转换、解密工具</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>索引</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-subitem"><a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-subitem"><a href="/archives/" class="nav-link">归档</a></li></ul></li><li class="dropdown-item"><h4>友链</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/friends/" class="nav-link">友情链接</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <a href="https://github.com/smileatl/smileatlRepository_source" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言-C</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言-C++</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言-Script_Language</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机知识-Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机知识-数据结构与算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机知识-操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机知识-计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库-MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库-Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具-Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具-虚拟机</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他-刷题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>其他-interview</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/48bd92/" class="sidebar-link">cpp</a></li><li><a href="/pages/913343/" class="sidebar-link">cpp关键字</a></li><li><a href="/pages/15087e/" class="sidebar-link">cpp_stl</a></li><li><a href="/pages/93a902/" class="sidebar-link">cpp新特性</a></li><li><a href="/pages/b5c821/" class="sidebar-link">cpp其他</a></li><li><a href="/pages/330a4c/" class="sidebar-link">gcc_g++_gdb</a></li><li><a href="/pages/b444c6/" class="sidebar-link">Linux</a></li><li><a href="/pages/51f6b1/" class="sidebar-link">操作系统</a></li><li><a href="/pages/d34e71/" class="sidebar-link">操作系统-网络系统</a></li><li><a href="/pages/a55347/" class="sidebar-link">操作系统-内存管理</a></li><li><a href="/pages/2791f7/" class="sidebar-link">85-操作系统-多线程_多进程_线程池</a></li><li><a href="/pages/2aa569/" aria-current="page" class="active sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_1、在浏览器地址栏输入一个url后回车-背后会进行哪些技术步骤" class="sidebar-link">1、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#第一种回答" class="sidebar-link">第一种回答</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#第三种" class="sidebar-link">第三种</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_2、tcp是如何保证可靠传输的" class="sidebar-link">2、TCP是如何保证可靠传输的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#第一种回答-2" class="sidebar-link">第一种回答</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#第三种回答" class="sidebar-link">第三种回答</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_3、https和http的区别" class="sidebar-link">3、HTTPS和HTTP的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#面试宝典版" class="sidebar-link">面试宝典版</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#复杂版" class="sidebar-link">复杂版</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_4、tcp和udp的区别" class="sidebar-link">4、TCP和UDP的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#综上" class="sidebar-link">综上</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_4、tcp和udp的使用场景" class="sidebar-link">4、TCP和UDP的使用场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#区别" class="sidebar-link">区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#tcp-vs-udp" class="sidebar-link">TCP vs UDP</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_5、http1-0-1-1-2-3的区别" class="sidebar-link">5、http1.0 / 1.1 / 2 / 3的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#http-1-0、1-1、2-0和3-0的区别如下" class="sidebar-link">HTTP 1.0、1.1、2.0和3.0的区别如下：</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#回答2" class="sidebar-link">回答2</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_5、http2传输" class="sidebar-link">5、http2传输</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_6、封包和拆包你听说过吗-它是基于tcp还是udp的" class="sidebar-link">6、封包和拆包你听说过吗？它是基于TCP还是UDP的？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_7、常见的http状态码有哪些" class="sidebar-link">7、常见的HTTP状态码有哪些？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#_1xx-信息" class="sidebar-link">1xx 信息</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#_2xx-成功" class="sidebar-link">2xx 成功</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#_3xx-重定向" class="sidebar-link">3xx 重定向</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#_4xx-客户端错误" class="sidebar-link">4xx 客户端错误</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#_5xx-服务器错误" class="sidebar-link">5xx 服务器错误</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#简单回答" class="sidebar-link">简单回答</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_9、http请求和响应报文有哪些主要字段" class="sidebar-link">9、HTTP请求和响应报文有哪些主要字段？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#请求报文" class="sidebar-link">请求报文</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#响应报文" class="sidebar-link">响应报文</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_11、http长连接怎么保活" class="sidebar-link">11、HTTP长连接怎么保活</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_12、为什么需要三次握手-两次不行吗" class="sidebar-link">12、为什么需要三次握手，两次不行吗？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_13、https采用的加密方式有哪些-是对称还是非对称" class="sidebar-link">13、HTTPS采用的加密方式有哪些？是对称还是非对称？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#chatgpt" class="sidebar-link">chatgpt:</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_14、流量控制是使用什么数据结构来实现的" class="sidebar-link">14、流量控制是使用什么数据结构来实现的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#补充" class="sidebar-link">补充</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_15、ip数据报的报头字段-ttl的设置了解过吗" class="sidebar-link">15、IP数据报的报头字段？TTL的设置了解过吗？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_16、为什么有http协议了-还要用rpc" class="sidebar-link">16、为什么有HTTP协议了?还要用RPC?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#补充-2" class="sidebar-link">补充</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_17、http长连接和短连接的区别" class="sidebar-link">17、HTTP长连接和短连接的区别</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_18、三次握手全流程详解-tcp建立链接的经历" class="sidebar-link">18、三次握手全流程详解/TCP建立链接的经历</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#第一种回答-3" class="sidebar-link">第一种回答</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#第二种回答" class="sidebar-link">第二种回答</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#小林" class="sidebar-link">小林</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_19、四次挥手-挥手为什么需要四次-三次不行吗" class="sidebar-link">19、四次挥手，挥手为什么需要四次？三次不行吗？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#【问题1】为什么连接的时候是三次握手-关闭的时候却是四次握手" class="sidebar-link">【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#【问题2】为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态" class="sidebar-link">【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#【问题3】如果已经建立了连接-但是客户端突然出现故障了怎么办" class="sidebar-link">【问题3】如果已经建立了连接，但是客户端突然出现故障了怎么办？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_20、对于fin-wait-2-close-wait状态和time-wait状态-你知道多少" class="sidebar-link">20、对于FINWAIT2，CLOSEWAIT状态和TIMEWAIT状态？你知道多少?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#fin-wait-1" class="sidebar-link">FINWAIT1：</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#fin-wait-2" class="sidebar-link">FINWAIT2：</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#close-wait状态" class="sidebar-link">CLOSE_WAIT状态：</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#time-wait状态" class="sidebar-link">TIME_WAIT状态：</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_21、了解流量控制原理吗-说说" class="sidebar-link">21、了解流量控制原理吗？说说？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_22、tcp-利用滑动窗口实现流量控制的机制" class="sidebar-link">22、TCP 利用滑动窗口实现流量控制的机制？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#小林coding" class="sidebar-link">小林coding</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#滑动窗口是如何实现的" class="sidebar-link">滑动窗口是如何实现的：</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#tcp-滑动窗口" class="sidebar-link">TCP 滑动窗口</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_23、拥塞控制原理听说过吗-讲讲" class="sidebar-link">23、拥塞控制原理听说过吗？讲讲？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#tcp-拥塞控制算法" class="sidebar-link">TCP 拥塞控制算法</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#流量控制-vs-拥塞控制" class="sidebar-link">流量控制 vs 拥塞控制</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_24、get和post-的区别-你知道哪些" class="sidebar-link">24、GET和POST 的区别，你知道哪些？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#第二种" class="sidebar-link">第二种</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_25、session和cookie应该如何去选择-适用场景" class="sidebar-link">25、Session和cookie应该如何去选择（适用场景）？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#cookie和session的关系和区别是什么" class="sidebar-link">Cookie和Session的关系和区别是什么</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_26、介绍一下tcp重传" class="sidebar-link">26、介绍一下TCP重传</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_27、面试题-服务器在传输过程中死机了-客户端有什么反应" class="sidebar-link">27、面试题：服务器在传输过程中死机了，客户端有什么反应？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_28、面试题-如果客户端一直死机-连接什么时候终止" class="sidebar-link">28、面试题：如果客户端一直死机，连接什么时候终止？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_29、tcp的连接指的是什么东西" class="sidebar-link">29、TCP的连接指的是什么东西</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_31、路由器和交换机的区别" class="sidebar-link">31、路由器和交换机的区别</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_32、udp怎么实现可靠传输" class="sidebar-link">32、UDP怎么实现可靠传输</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_33、怎么理解tcp的流的概念" class="sidebar-link">33、怎么理解TCP的流的概念？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_35、tcp粘包问题是什么-你会如何去解决它" class="sidebar-link">35、TCP粘包问题是什么？你会如何去解决它？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#产生原因" class="sidebar-link">产生原因</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#解决方法" class="sidebar-link">解决方法</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#回答2-2" class="sidebar-link">回答2：</a></li><li class="sidebar-sub-header level4"><a href="/pages/2aa569/#固定长度的消息" class="sidebar-link">固定长度的消息</a></li><li class="sidebar-sub-header level4"><a href="/pages/2aa569/#特殊字符作为边界" class="sidebar-link">特殊字符作为边界</a></li><li class="sidebar-sub-header level4"><a href="/pages/2aa569/#定义消息结构" class="sidebar-link">定义消息结构</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_37、简述-traceroute-命令的原理" class="sidebar-link">37、简述 traceroute 命令的原理</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_40、数据包封装和解封过程" class="sidebar-link">40、数据包封装和解封过程</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_43、tcp四个计时器" class="sidebar-link">43、TCP四个计时器</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_45、http的方法有哪些" class="sidebar-link">45、HTTP的方法有哪些</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_46、简述-https-的加密与认证过程" class="sidebar-link">46、简述 HTTPS 的加密与认证过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#小林-2" class="sidebar-link">小林</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_80、dns劫持" class="sidebar-link">80、DNS劫持</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_82、osi和tcp-ip模型" class="sidebar-link">82、OSI和TCP/IP模型</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_84、为什么服务器会缓存这一项功能-如何实现的" class="sidebar-link">84、为什么服务器会缓存这一项功能?如何实现的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#原因" class="sidebar-link">原因</a></li><li class="sidebar-sub-header level3"><a href="/pages/2aa569/#实现方法" class="sidebar-link">实现方法</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_86、为什么区域传送用tcp协议" class="sidebar-link">86、为什么区域传送用TCP协议？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_88、dns负载均衡是什么策略" class="sidebar-link">88、DNS负载均衡是什么策略？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_90、介绍几个tcp对应的应用层协议" class="sidebar-link">90、介绍几个TCP对应的应用层协议？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_92、数据链路层你知道哪些常见协议" class="sidebar-link">92、数据链路层你知道哪些常见协议？</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_94、dhcp" class="sidebar-link">94、DHCP</a></li><li class="sidebar-sub-header level2"><a href="/pages/2aa569/#_96、telnet" class="sidebar-link">96、telnet</a></li></ul></li><li><a href="/pages/236a38/" class="sidebar-link">数据结构与算法</a></li><li><a href="/pages/ad5e7b/" class="sidebar-link">MySQL</a></li><li><a href="/pages/147c65/" class="sidebar-link">Redis</a></li><li><a href="/pages/92907e/" class="sidebar-link">设计模式</a></li><li><a href="/pages/9b30d0/" class="sidebar-link">系统设计</a></li><li><a href="/pages/34398d/" class="sidebar-link">工具</a></li><li><a href="/pages/b064c1/" class="sidebar-link">技术支持</a></li><li><a href="/pages/ad5241/" class="sidebar-link">HR面相关问题</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/work/#工作" data-v-06225672>工作</a></li><li data-v-06225672><a href="/work/#其他-interview" data-v-06225672>其他-interview</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/smileatl" target="_blank" title="作者" class="beLink" data-v-06225672>smileatl</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-12-04</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">计算机网络<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h1> <h2 id="_1、在浏览器地址栏输入一个url后回车-背后会进行哪些技术步骤"><a href="#_1、在浏览器地址栏输入一个url后回车-背后会进行哪些技术步骤" class="header-anchor">#</a> 1、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</h2> <h3 id="第一种回答"><a href="#第一种回答" class="header-anchor">#</a> 第一种回答</h3> <p>1、查<strong>浏览器缓存</strong>，看看有没有已经缓存好的，如果没有</p> <p>2 、检查<strong>本机host文件</strong>，</p> <p>3、调用API，Linux下Socket函数 gethostbyname</p> <p>4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议。（DNS是应用层协议之一，基于传输层的UDP协议，端口号为53。）</p> <p>5、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）</p> <p>6、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，（应用层）</p> <p>7、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，</p> <p>8、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，</p> <p>9、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，</p> <p>10、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。</p> <p>11、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页</p> <h3 id="第三种"><a href="#第三种" class="header-anchor">#</a> 第三种</h3> <p>输入网址的全过程可以分为以下几个步骤：</p> <ol><li><p>用户输入网址：用户在浏览器的地址栏中输入要访问的网址，比如 &quot;www.example.com&quot;。</p></li> <li><p>DNS解析：浏览器首先需要将域名转换为对应的 IP 地址。它会向本地 DNS 服务器发送域名解析请求，并通过递归查询或迭代查询来获取目标网址的 IP 地址。</p></li> <li><p>建立TCP连接：一旦浏览器获得了目标网址的 IP 地址，它会使用 TCP 协议与目标服务器建立连接。这个过程通过三次握手来确保双方都能够正常通信。</p></li> <li><p>发送HTTP请求：一旦建立了 TCP 连接，浏览器会向服务器发送一个 HTTP 请求。该请求包含了<strong>要访问的资源的路径、请求方法（如 GET、POST 等）以及其他相关的头部信息</strong>。</p></li> <li><p>服务器处理请求：服务器收到浏览器发送的 HTTP 请求后，会根据请求的内容和服务器端配置进行相应的处理。服务器可能需要读取、写入或修改数据，并根据请求生成响应。</p></li> <li><p>返回HTTP响应：服务器处理完请求后，会生成一个 HTTP 响应，并将其发送回浏览器。响应包括<strong>状态码、响应头部以及响应体等信息</strong>。</p></li> <li><p>渲染页面：浏览器收到服务器返回的 HTTP 响应后， 会根据响应中的数据来渲染页面。它会<strong>解析 HTML、CSS 和 JavaScript</strong> 等内容，并将其展示给用户。</p></li> <li><p>关闭TCP连接：一旦页面被完全加载并显示给用户，浏览器会关闭与服务器之间的 TCP 连接。这样，整个网页加载过程就完成了。</p></li></ol> <p>需要注意的是，上述过程是一个简化的描述，实际中可能还涉及到更多的细节和步骤。此外，还有一些优化技术，如缓存、CDN、压缩等，可以提高网页加载速度和性能。</p> <p><img src="/assets/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f3230313830393238303930373331363436.png" alt="HTTP请求过程"></p> <h2 id="_2、tcp是如何保证可靠传输的"><a href="#_2、tcp是如何保证可靠传输的" class="header-anchor">#</a> 2、TCP是如何保证可靠传输的？</h2> <p>tcp的序列号可以避免乱序的问题，保证收到的tcp报文都是有序的。
在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。
TCP 针对数据包丢失的情况，会用重传机制解决。
用快重传解决个别报文段的丢失问题。
使用滑动窗口实现流量控制。使用接收方确认报文中的窗口字段来控制发送方发送窗口大小，进而控制发送方的发送速率，使得接收方来得及接收。
使用基于窗口的拥塞控制，来尽量避免避免网络拥塞。</p> <h3 id="第一种回答-2"><a href="#第一种回答-2" class="header-anchor">#</a> 第一种回答</h3> <ul><li><p><strong>序列号和确认号</strong>：TCP通过序号和确认号来保证数据的可靠传输。发送方将每个数据报文都标记一个唯一的序号，接收方收到数据后需要回复一个确认号，表示已经成功接收到了这个数据。。</p></li> <li><p><strong>超时重传</strong>：发送方在发送数据后会设置一个计时器，如果在规定的时间内没有收到确认，则会重新发送数据。这可以保证即使某个数据包在传输过程中丢失，也能够被及时地重传。</p></li> <li><p><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</p></li> <li><p><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，使得每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</p></li> <li><p><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</p></li> <li><p><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</p></li></ul> <h3 id="第三种回答"><a href="#第三种回答" class="header-anchor">#</a> 第三种回答</h3> <p><strong>首部校验</strong></p> <p>这个校验机制能够确保数据传输不会出错吗？ 答案是不能。</p> <p><strong>原因</strong></p> <p>TCP协议中规定，TCP的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。</p> <p>这就是TCP的数据校验机制。 但是这个机制能够保证检查出一切错误吗？<strong>显然不能</strong>。</p> <p>因为这种校验方式是累加和，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是小学生都知道A+B=B+A，假如在传输的过程中有前后两个16比特位的数据前后颠倒了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。</p> <p><strong>解决方案</strong></p> <p>传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题。</p> <h2 id="_3、https和http的区别"><a href="#_3、https和http的区别" class="header-anchor">#</a> 3、HTTPS和HTTP的区别</h2> <p>1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p> <p>2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p> <p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p> <h3 id="面试宝典版"><a href="#面试宝典版" class="header-anchor">#</a> 面试宝典版</h3> <ol><li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准
（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，
使网络传输减少。
HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS
的安全基础是SSL，因此加密的详细内容就需要SSL。
HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；
另一种就是确认网站的真实性。</li> <li>HTTP与HTTPS的区别
https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li></ol> <p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认
证的网络协议，比http协议安全。</p> <h3 id="复杂版"><a href="#复杂版" class="header-anchor">#</a> 复杂版</h3> <ol><li><p><strong>HTTP</strong>：HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p> <p>① 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 <strong>TCP 连接的端口号是80</strong>。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：<strong>统一资源标识符（URI）、协议版本号，后边是 MIME 信息</strong>包括请求修饰符、客户机信息和许可内容。</p> <table><thead><tr><th>统一资源标识符（URI）</th> <th>协议版本号</th> <th>MIME信息</th></tr></thead> <tbody><tr><td></td> <td></td> <td></td></tr></tbody></table> <p>② 服务器接到请求后，给予相应的<strong>响应</strong>信息，其格式为<strong>一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息</strong>包括服务器信息、实体信息和可能的内容。</p> <table><thead><tr><th>状态行（包括协议版本号、code）</th> <th>MIME信息</th></tr></thead> <tbody><tr><td></td> <td></td></tr></tbody></table></li> <li><p><strong>HTTPS</strong>：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。<strong>端口号是443</strong></p> <p>SSL 协议可分为两层：<strong>SSL 记录协议（SSL Record Protocol）</strong> 建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。<strong>SSL 握手协议（SSL Handshake Protocol）</strong> 建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p> <p><img src="/assets/1697182789578.png" alt="1697182789578"></p> <p><strong>双向身份认证</strong></p> <p>客户端和服务器传输数据之前，会有一个基于X.509证书的双向身份认证的过程：</p> <p>① 客户端发起SSL handshake protocol消息给服务器</p> <p>② 服务端将「证书=签名+原信息」发给给客户端验证</p> <p>③ 客户端检查服务端证书，合规就认证了服务端</p> <p>④ 服务端要求客户端发送证书，并检查是否通过验证，成功之后从证书中拿到公钥</p></li></ol> <h2 id="_4、tcp和udp的区别"><a href="#_4、tcp和udp的区别" class="header-anchor">#</a> 4、TCP和UDP的区别</h2> <ol><li><p>TCP是面向连接的协议，建立和释放连接需要进行三次握手和四次挥手。UDP是面向无连接的协议，无需进行三次握手和四次挥手。说明udp比TCP实时性更强。</p></li> <li><p>TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</p></li> <li><p>TCP连接的可靠性强，UDP的可靠性不强。</p></li> <li><p>TCP只能一对一，UDP支持一对多和多对多。</p></li> <li><p>TCP的头部开销比UDP大。TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</p></li></ol> <h3 id="综上"><a href="#综上" class="header-anchor">#</a> 综上</h3> <p>TCP 提供了一系列的可靠传输机制来保证它这个传输是可靠的，相较而言的话，那它的传<strong>输速度就是慢的</strong>.</p> <p>UDP 没有做这个可靠的控制，它只是尽力而为，所以说它的<strong>传输速度是快的，而且占用的资源也会更小一些</strong>。具体使用的话要看不同的那个业务场景来进行相关的使用。</p> <h2 id="_4、tcp和udp的使用场景"><a href="#_4、tcp和udp的使用场景" class="header-anchor">#</a> 4、TCP和UDP的使用场景</h2> <p>TCP和UDP是两种常用的传输协议，它们分别适用于不同的网络通信场景。</p> <p><strong>TCP协议可靠性较高，适用于数据传输的可靠性要求较高的场景，例如传输大文件或需要确保所有数据都能到达接收端的应用，如FTP、HTTP等应用程序</strong>。</p> <p>而<strong>UDP协议则适用于对实时性要求较高的场景，例如音视频流媒体、在线游戏等</strong> 。</p> <p>⼀个是⾯向连接的基于字节流的可靠连接，⼀个是不需要连接的基于数据报的不可靠传输</p> <h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <ul><li><strong>连接</strong>：TCP 是面向连接的传输层协议，传输数据前先要建立连接。UDP 是不需要连接，即刻传输数据。</li> <li><strong>服务对象</strong>：TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信</li> <li><strong>可靠性</strong>：TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。</li> <li><strong>拥塞控制、流量控制</strong>：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li> <li><strong>传输方式</strong>：TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul> <h3 id="tcp-vs-udp"><a href="#tcp-vs-udp" class="header-anchor">#</a> TCP vs UDP</h3> <ul><li>TCP格式</li></ul> <p><img src="/assets/68747470733a2f2f696d672d626c6f672e6373646e2e6e68.png" alt="68747470733a2f2f696d672d626c6f672e6373646e2e6e68"></p> <p>4位头部长度（header length):标识该TCP头部有多少个32bit字(4字节)。因为4位最大能表示15，所以TCP头部最长是60字节。</p> <p>6位标志位包含如下几项:</p> <ul><li><p>URG标志，表示紧急指针（urgent pointer）是否有效。</p></li> <li><p>ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。</p></li> <li><p>PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中)。</p></li> <li><p>RST标志，表示要求对方重新建立连接。我们称携带RST 标志的TCP报文段为复位报文段。</p></li> <li><p>SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。</p></li> <li><p>FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。</p></li> <li><p>UDP格式</p></li></ul> <p><img src="/assets/68747470733a2f2f696d672d626c6f67233.png" alt="68747470733a2f2f696d672d626c6f67233"></p> <h2 id="_5、http1-0-1-1-2-3的区别"><a href="#_5、http1-0-1-1-2-3的区别" class="header-anchor">#</a> 5、http1.0 / 1.1 / 2 / 3的区别</h2> <h3 id="http-1-0、1-1、2-0和3-0的区别如下"><a href="#http-1-0、1-1、2-0和3-0的区别如下" class="header-anchor">#</a> <strong>HTTP 1.0、1.1、2.0和3.0的区别如下：</strong></h3> <ul><li>HTTP 1.0是一种无状态，无连接的应用层协议。浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接(无连接)，服务器不跟踪每个客户端，也不记录过去的请求(无状态) 。</li> <li>HTTP 1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了网络延迟 。可以复用Tcp连接，但是同一时间只能对应一个http请求(http请求在一个Tcp中是串行的)</li> <li>HTTP 2.0是基于二进制流的，可以分解为独立的帧，交错发送，从而提高了网络传输效率。</li> <li>HTTP/3是最新的版本，它使用了QUIC协议来提高网络传输效率。</li></ul> <h3 id="回答2"><a href="#回答2" class="header-anchor">#</a> 回答2</h3> <p>http/1.0 :</p> <ol><li>默认不支持长连接，需要设置keep-alive参数指定</li> <li>强缓存expired、协商缓存last-modiﬁed\if-modiﬁed-since 有一定的缺陷</li></ol> <p>http 1.1 :</p> <ol><li>默认长连接(keep-alive)，http请求可以复用Tcp连接，但是同一时间只能对应一个http请求(http请
求在一个Tcp中是串行的)</li> <li>增加了强缓存cache-control、协商缓存etag\if-none-match 是对http/1 缓存的优化</li></ol> <p>http/2.0 :</p> <ol><li>多路复用，一个Tcp中多个http请求是并行的 (雪碧图、多域名散列等优化手段http/2中将变得多
余)</li> <li>二进制格式编码传输</li> <li>使用HPACK算法做headesr压缩</li> <li>服务端推送</li></ol> <h2 id="_5、http2传输"><a href="#_5、http2传输" class="header-anchor">#</a> 5、http2传输</h2> <p>知道了 HTTP/2 的帧结构后，我们再来看看它是如何实现<strong>并发传输</strong>的。</p> <p>我们都知道 HTTP/1.1 的实现是基于<strong>请求-响应</strong>模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在<strong>发出请求等待响应的过程中，是没办法做其他事情的</strong>，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p> <p>而 HTTP/2 就很牛逼了，通过 Stream 这个设计，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。</p> <p>为了理解 HTTP/2 的并发是怎样实现的，我们先来理解 HTTP/2 中的 Stream、Message、Frame 这 3 个概念</p> <p><img src="/assets/1694654579663.png" alt="1694654579663"></p> <p>你可以从上图中看到：</p> <ul><li>1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；</li> <li>Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</li> <li>Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式<strong>存放 HTTP/1 中的内容（头部和包体）</strong> ；</li></ul> <p>因此，我们可以得出个结论：多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。</p> <p>在 HTTP/2 连接上，<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p> <p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p> <p><img src="/assets/1694654998724.png" alt="1694654998724"></p> <p>客户端和服务器<strong>双方都可以建立 Stream</strong>，因为服务端可以主动推送资源给客户端， 客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p> <p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字 1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID 是偶数（数字 2 和 4）。</p> <p><img src="/assets/1694655040110.png" alt="1694655040110"></p> <p>同一个连接中的 Stream ID 是不能复用的，只能顺序递增，所以当 Stream ID 耗尽时，需要发一个控制帧 <code>GOAWAY</code>，用来关闭 TCP 连接。</p> <p>在 Nginx 中，可以通过 <code>http2_max_concurrent_Streams</code> 配置来设置 Stream 的上限，默认是 128 个。</p> <p>HTTP/2 通过 Stream 实现的并发，比 HTTP/1.1 通过 TCP 连接实现并发要牛逼的多，<strong>因为当 HTTP/2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP/1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过 TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。</strong></p> <p>HTTP/2 还可以对每个 Stream 设置不同<strong>优先级</strong>，帧头中的「标志位」可以设置优先级，比如客户端访问 HTML/CSS 和图片资源时，希望服务器先传递 HTML/CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。</p> <h2 id="_6、封包和拆包你听说过吗-它是基于tcp还是udp的"><a href="#_6、封包和拆包你听说过吗-它是基于tcp还是udp的" class="header-anchor">#</a> 6、封包和拆包你听说过吗？它是基于TCP还是UDP的？</h2> <p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p> <ul><li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li> <li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li></ul> <h2 id="_7、常见的http状态码有哪些"><a href="#_7、常见的http状态码有哪些" class="header-anchor">#</a> 7、常见的HTTP状态码有哪些？</h2> <table><thead><tr><th>状态码</th> <th>类别</th> <th>含义</th></tr></thead> <tbody><tr><td>1XX</td> <td>Informational（信息性状态码）</td> <td>接收的请求正在处理</td></tr> <tr><td>2XX</td> <td>Success（成功状态码）</td> <td>请求正常处理完毕</td></tr> <tr><td>3XX</td> <td>Redirection（重定向状态码）</td> <td>需要进行附加操作以完成请求</td></tr> <tr><td>4XX</td> <td>Client Error（客户端错误状态码）</td> <td>服务器无法处理请求</td></tr> <tr><td>5XX</td> <td>Server Error（服务器错误状态码）</td> <td>服务器处理请求出错</td></tr></tbody></table> <h3 id="_1xx-信息"><a href="#_1xx-信息" class="header-anchor">#</a> 1xx 信息</h3> <p><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p> <h3 id="_2xx-成功"><a href="#_2xx-成功" class="header-anchor">#</a> 2xx 成功</h3> <ul><li><strong>200 OK</strong></li> <li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li> <li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul> <h3 id="_3xx-重定向"><a href="#_3xx-重定向" class="header-anchor">#</a> 3xx 重定向</h3> <ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li> <li><strong>302 Found</strong> ：临时性重定向</li> <li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li> <li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li> <li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul> <h3 id="_4xx-客户端错误"><a href="#_4xx-客户端错误" class="header-anchor">#</a> 4xx 客户端错误</h3> <ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li> <li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li> <li><strong>403 Forbidden</strong> ：请求被拒绝。</li> <li><strong>404 Not Found</strong></li></ul> <h3 id="_5xx-服务器错误"><a href="#_5xx-服务器错误" class="header-anchor">#</a> 5xx 服务器错误</h3> <ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li> <li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul> <h3 id="简单回答"><a href="#简单回答" class="header-anchor">#</a> 简单回答</h3> <ul><li><strong>301-Moved Permanently</strong>：跳转，代表永久性重定向</li> <li><strong>304-Not Modified</strong>：客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回了304</li> <li><strong>401-Unauthorized</strong>：发送的请求需要有通过HTTP认证的认证信息</li> <li><strong>403-Forbidden</strong>：对请求资源的访问被服务器拒绝了</li></ul> <blockquote><p>参考：<a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener noreferrer">https://www.runoob.com/http/http-status-codes.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_9、http请求和响应报文有哪些主要字段"><a href="#_9、http请求和响应报文有哪些主要字段" class="header-anchor">#</a> 9、HTTP请求和响应报文有哪些主要字段？</h2> <h3 id="请求报文"><a href="#请求报文" class="header-anchor">#</a> 请求报文</h3> <p><img src="/assets/202307182302107.png" alt="img"></p> <p>简单来说：</p> <ul><li>请求行：Request Line</li> <li>请求头：Request Headers</li> <li>请求体：Request Body</li></ul> <p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p> <p><img src="/assets/1692083244732.png" alt="1692083244732"></p> <p>or</p> <p>＜request-line＞</p> <p>＜headers＞</p> <p>＜blank line＞</p> <p>[＜request-body＞]</p> <p><strong>1.请求头</strong></p> <p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。</p> <p><strong>2.请求头部</strong></p> <p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p> <p>User-Agent：产生请求的浏览器类型。</p> <p>Accept：客户端可识别的内容类型列表。</p> <p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p> <p><strong>3.空行</strong></p> <p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p> <p><strong>4.请求数据</strong></p> <p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p> <h3 id="响应报文"><a href="#响应报文" class="header-anchor">#</a> 响应报文</h3> <p>简单来说：</p> <ul><li>状态行：Status Line</li> <li>响应头：Response Headers</li> <li>响应体：Response Body</li></ul> <p>HTTP响应也由三个部分组成，分别是：状态行、响应报头、响应正文。</p> <p>如下所示，HTTP响应的格式与请求的格式十分类似：</p> <p>＜status-line＞</p> <p>＜headers＞</p> <p>＜blank line＞</p> <p>[＜response-body＞]</p> <p><img src="/assets/6874748393233392e706e67.png" alt="img"></p> <p>参考：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html" target="_blank" rel="noopener noreferrer">HTTP请求报文和HTTP响应报文<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_11、http长连接怎么保活"><a href="#_11、http长连接怎么保活" class="header-anchor">#</a> 11、HTTP长连接怎么保活</h2> <p>TTP长连接保活的方法有很多，以下是一些常见的方法：</p> <ul><li>在服务器端设置一个<strong>保活定时器</strong>，当定时器开始工作后就定时的向网络通信的另一端发出保活探测的TCP报文，如果接收到了ACK报文，那么就证明对方存活，可以继续保有连接；否则就证明网络存在故障。</li> <li>通过在客户端<strong>发送心跳包</strong>来检测服务器是否存活。如果服务器在一定时间内没有收到客户端的心跳包，则认为客户端已经宕机了，需要重新建立连接。</li> <li>通过在服务器端<strong>设置keep-alive参数来实现长连接保活</strong>。keep-alive参数指定了客户端与服务器之间的长连接超时时间，超过这个时间后，如果没有数据传输，则自动断开连接。如果在这个时间内有数据传输，则重置超时时间。
HTTP头部字段：在HTTP请求和响应的头部中使用特定的字段来指示保持长连接。常见的字段有 <code>Connection: keep-alive</code> 和 <code>Keep-Alive: timeout=xx, max=yy</code>。其中，<code>Connection: keep-alive</code> 表示客户端希望保持长连接，而 <code>Keep-Alive: timeout=xx, max=yy</code> 则指定了连接的超时时间和最大请求数。</li></ul> <h2 id="_12、为什么需要三次握手-两次不行吗"><a href="#_12、为什么需要三次握手-两次不行吗" class="header-anchor">#</a> 12、为什么需要三次握手，两次不行吗？</h2> <p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p> <ul><li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li> <li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li> <li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ul> <p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p> <blockquote><p>问题：为什么需要三次握手？</p> <p>答案：如果只有两次握手，假设前两次就可以建立连接，假设一个场景：客户端发送一个请求建立连接，但是由于网络延迟很久之后才到服务器，服务器这边也就不会立马ack，此时客户端以为丢失所以就是重传，这时很快就完成了前两次的握手过程，然后传输数据释放连接。<strong>但是之后服务器又收到之前那个请求，又给客户端这边ack，又会建立连接（本来不需要了），所以就造成了不必要的资源浪费。但是如果是三次握手，客户端这边收到ack之后才会给服务器那边ACK</strong></p></blockquote> <h2 id="_13、https采用的加密方式有哪些-是对称还是非对称"><a href="#_13、https采用的加密方式有哪些-是对称还是非对称" class="header-anchor">#</a> 13、HTTPS采用的加密方式有哪些？是对称还是非对称？</h2> <p>HTTPS 采用混合的加密机制，使用<strong>非对称密钥加密用于传输（身份验证、密钥交换），对称密钥来保证传输过程的安全性</strong>，之后使用<strong>对称密钥加密进行通信来保证通信过程的效率</strong>。</p> <p><img src="/assets/202205220036403.png" alt="img"></p> <p>确保传输安全过程（其实就是rsa原理）：</p> <ol><li>Client给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li> <li>Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li> <li>Client确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。</li> <li>Server使用自己的私钥，获取Client发来的随机数（Premaster secret）。</li> <li>Client和Server根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li></ol> <h3 id="chatgpt"><a href="#chatgpt" class="header-anchor">#</a> chatgpt:</h3> <p>HTTPS采用的加密方式包括对称加密和非对称加密。</p> <ol><li><p><strong>对称加密：在HTTPS连接中，使用对称加密算法（如AES、DES等）来加密和解密传输的数据</strong>。对称加密使用同一个密钥进行加密和解密，速度较快，适用于大量数据的加密。在HTTPS通信中，对称加密主要用于加密传输过程中的数据，保证数据的机密性。</p></li> <li><p><strong>非对称加密：HTTPS使用非对称加密算法（如RSA、ECC等）来实现身份验证和密钥交换</strong>。非对称加密使用一对密钥，即公钥和私钥。公钥可公开给任何人，而私钥只有服务器持有。公钥用于加密数据，私钥用于解密数据。在HTTPS握手阶段，通过非对称加密算法实现客户端和服务器之间的安全通信，并交换用于后续对称加密的密钥。</p></li></ol> <h2 id="_14、流量控制是使用什么数据结构来实现的"><a href="#_14、流量控制是使用什么数据结构来实现的" class="header-anchor">#</a> 14、流量控制是使用什么数据结构来实现的？</h2> <p>流量控制是使用<strong>滑动窗口</strong>来实现的。接收方确认报文中的窗口字段可以用来控制发送方窗口的大小。</p> <p>如果窗户的值为0，则发送方停止发送数据，但是发<strong>送方会定期的向接收方发送窗口探测报文以得到窗口的大小</strong>。</p> <h3 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h3> <p>在TCP协议中，每个数据包都有一个<strong>序号</strong>，接收方通过序号来确认是否收到了正确的数据包。发送方将数据分成若干个数据段，每个数据段的大小不超过发送窗口的大小，然后将这些数据段发送给接收方。接收方会确认已经收到的数据，同时告诉发送方自己的接收窗口大小。发送方根据接收方的窗口大小，动态调整自己的发送窗口大小，从而控制数据的传输速率。</p> <h2 id="_15、ip数据报的报头字段-ttl的设置了解过吗"><a href="#_15、ip数据报的报头字段-ttl的设置了解过吗" class="header-anchor">#</a> 15、IP数据报的报头字段？TTL的设置了解过吗？</h2> <p>IP数据报的报头字段包括：版本号、服务类型、总长度、标识符、标志位、片偏移、生存时间(TTL)、协议和头部校验和等。</p> <p>其中，TTL字段是由IP数据包的发送者设置，在IP数据包从源到目的的整个转发路径上，每经过一个路由器，路由器都会修改这个TTL字段值，具体的做法是把该TTL的值减1,然后再将IP包转发出去。</p> <p>如果在IP包到达目的IP之前，TTL减少为0,路由器将会丢弃收到的TTL=0的IP包，并向IP包的发送者发送 ICMP time exceeded消息 。</p> <p><img src="/assets/1692845704619.png" alt="1692845704619"></p> <h2 id="_16、为什么有http协议了-还要用rpc"><a href="#_16、为什么有http协议了-还要用rpc" class="header-anchor">#</a> 16、为什么有HTTP协议了?还要用RPC?</h2> <p>1.从项目实践的角度上来讲，使用HTTP协议规定的协议码对于RPC框架提供的<strong>异常信息返回的角度</strong>来说，HTTP所蕴含的信息不够丰富,不够直观,比如说通信双方的执行状态只能够通过状态码来描述,而RPC框架可以<strong>返回完整的异常信息</strong></p> <p>2.从<strong>编码</strong>的角度上来看，HTTP的编码比较<strong>冗余</strong>，也就是说需要通过<strong>定义一大堆的状态码来定义当前的状态</strong>，对于不同的服务，这些编码可能还有不同的含义，不合适。</p> <p>3.HTTP通常来说前端和后端通信使用的，包含了<strong>大量的浏览器跳转状态定义</strong>,这些<strong>状态对于后端服务器之间的联调是没有意义的</strong>，因此在这样的情况下,而RPC自定义的协议，可以免去这些冗余的状态,更加<strong>定制化</strong>地定这个后端服务联调</p> <h3 id="补充-2"><a href="#补充-2" class="header-anchor">#</a> 补充</h3> <p><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。</p> <p>从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</p> <p><strong>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</strong> <strong>HTTP/2.0在 HTTP/1.1的基础上做了优化，性能可能比很多 RPC 协议都要好</strong>，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</p> <h2 id="_17、http长连接和短连接的区别"><a href="#_17、http长连接和短连接的区别" class="header-anchor">#</a> 17、HTTP长连接和短连接的区别</h2> <p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p> <p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。</p> <h2 id="_18、三次握手全流程详解-tcp建立链接的经历"><a href="#_18、三次握手全流程详解-tcp建立链接的经历" class="header-anchor">#</a> 18、三次握手全流程详解/TCP建立链接的经历</h2> <p><img src="/assets/202205072301822.png" alt="img"></p> <p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换<code>TCP窗口大小</code>信息。</p> <h3 id="第一种回答-3"><a href="#第一种回答-3" class="header-anchor">#</a> 第一种回答</h3> <p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p> <ul><li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 <code>SYN_SEND</code> 状态。</p> <p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p></li> <li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p> <p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p></li> <li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p> <p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ul> <p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p> <p>在socket编程中，客户端执行connect()时，将触发三次握手。</p> <h3 id="第二种回答"><a href="#第二种回答" class="header-anchor">#</a> 第二种回答</h3> <ul><li><strong>初始状态</strong>：客户端处于 <code>closed(关闭)</code>状态，服务器处于 <code>listen(监听)</code> 状态。</li> <li><strong>第一次握手</strong>：客户端发送请求报文将 <code>SYN = 1</code>同步序列号和初始化序列号<code>seq = x</code>发送给服务端，发送完之后客户端处于<code>SYN_Send</code>状态。（验证了客户端的发送能力和服务端的接收能力）</li> <li><strong>第二次握手</strong>：服务端受到 <code>SYN</code> 请求报文之后，如果同意连接，会以自己的同步序列号<code>SYN(服务端) = 1</code>、初始化序列号 <code>seq = y</code>和确认序列号（期望下次收到的数据包）<code>ack = x+ 1</code> 以及确认号<code>ACK = 1</code>报文作为应答，服务器为<code>SYN_Receive</code>状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li> <li><strong>第三次握手</strong>： 客户端接收到服务端的 <code>SYN + ACK</code>之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 <code>ack = y + 1</code>和数据包的序列号 <code>seq = x + 1</code>以及确认号<code>ACK = 1</code>确认包作为应答，客户端转为<code>established</code>状态。（分别站在双方的角度上思考，各自ok）</li></ul> <h3 id="小林"><a href="#小林" class="header-anchor">#</a> 小林</h3> <p><strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：</p> <p><img src="/assets/640-1691581817973.png" alt="图片">TCP 三次握手</p> <ul><li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。<strong>先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</strong>。</li> <li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li> <li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li> <li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。
（可以携带数据，但是如果不携带数据就不消耗一个序号，该数据包的序列号应为 <code>client_isn + 1</code>）</li> <li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ul> <h2 id="_19、四次挥手-挥手为什么需要四次-三次不行吗"><a href="#_19、四次挥手-挥手为什么需要四次-三次不行吗" class="header-anchor">#</a> 19、四次挥手，挥手为什么需要四次？三次不行吗？</h2> <p><img src="/assets/68747470733a2f2f6932.png" alt="68747470733a2f2f6932"></p> <ul><li><strong>[→]</strong> 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），<strong>客户端进入FIN-WAIT-1（终止等待1）状态</strong>。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li> <li><strong>[←]</strong> 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，<strong>服务端就进入了CLOSE-WAIT（关闭等待）状态。</strong></li> <li>客户端收到服务器的确认请求后，此时，<strong>客户端就进入FIN-WAIT-2（终止等待2）状态</strong>，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li> <li><strong>[←]</strong> 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，<strong>服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</strong></li> <li><strong>[→]</strong> 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，<strong>客户端就进入了TIME-WAIT（时间等待）状态</strong>。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的传输控制块（TCB）后，才进入CLOSED状态。</li> <li><strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态</strong>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ul> <h3 id="【问题1】为什么连接的时候是三次握手-关闭的时候却是四次握手"><a href="#【问题1】为什么连接的时候是三次握手-关闭的时候却是四次握手" class="header-anchor">#</a> 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3> <p>答：<strong>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文</strong>。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。<strong>只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送</strong>。故需要四步握手。</p> <h3 id="【问题2】为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态"><a href="#【问题2】为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态" class="header-anchor">#</a> 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3> <p>答：<strong>有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的<strong>2MSL是两倍的MSL(Maximum Segment Lifetime)</strong> 。<strong>MSL指一个片段在网络中最大的存活时间</strong>，2MSL就是<strong>一个发送和一个回复所需的最大时间</strong>。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接</p> <h3 id="【问题3】如果已经建立了连接-但是客户端突然出现故障了怎么办"><a href="#【问题3】如果已经建立了连接-但是客户端突然出现故障了怎么办" class="header-anchor">#</a> 【问题3】如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3> <p>答：<strong>TCP还设有一个保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每<strong>收到一次客户端的请求后都会重新复位这个计时器</strong>，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p> <h2 id="_20、对于fin-wait-2-close-wait状态和time-wait状态-你知道多少"><a href="#_20、对于fin-wait-2-close-wait状态和time-wait状态-你知道多少" class="header-anchor">#</a> 20、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?</h2> <h3 id="fin-wait-1"><a href="#fin-wait-1" class="header-anchor">#</a> FIN_WAIT_1：</h3> <ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li></ul> <h3 id="fin-wait-2"><a href="#fin-wait-2" class="header-anchor">#</a> FIN_WAIT_2：</h3> <ul><li>半关闭状态。</li> <li>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li></ul> <h3 id="close-wait状态"><a href="#close-wait状态" class="header-anchor">#</a> CLOSE_WAIT状态：</h3> <ul><li>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li> <li>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。</li></ul> <h3 id="time-wait状态"><a href="#time-wait状态" class="header-anchor">#</a> TIME_WAIT状态：</h3> <ul><li>又叫2MSL等待状态。</li> <li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是<strong>防止最后一次握手数据没有到达对方而触发重传FIN准备的</strong>。</li> <li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li></ul> <h2 id="_21、了解流量控制原理吗-说说"><a href="#_21、了解流量控制原理吗-说说" class="header-anchor">#</a> 21、了解流量控制原理吗？说说？</h2> <ul><li><strong>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</strong></li> <li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
<ul><li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由<strong>接收端返回的TCP报文段中窗口字段来控制</strong>，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li> <li>接收窗：用来标记可以接收的数据大小。</li></ul></li> <li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</li> <li><strong>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口</strong>。</li></ul> <h2 id="_22、tcp-利用滑动窗口实现流量控制的机制"><a href="#_22、tcp-利用滑动窗口实现流量控制的机制" class="header-anchor">#</a> 22、TCP 利用滑动窗口实现流量控制的机制？</h2> <blockquote><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。</p></blockquote> <p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着<strong>接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。</p> <p>当滑动窗口为 0 时，发送方一般不能再发送数据报，</p> <blockquote><p>但有两种情况除外，一种情况是可以发送紧急数据。例如，允许用户终止在远端机上的运行进程。</p> <p>另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p></blockquote> <h3 id="小林coding"><a href="#小林coding" class="header-anchor">#</a> 小林coding</h3> <p>流量控制主要是可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送的数据量。</p> <p>实现的⽅式，接收⽅会有⼀个接收缓冲区，如果内核接收到了数据，没有被应⽤读取的话，接收窗⼝就
会收缩，然后会在tcp报⽂携带接收窗⼝的⼤⼩，发送发收到后，就会控制的发送流量。</p> <p>下⾯举个栗⼦，为了简单起⻅，假设以下场景：</p> <ul><li>客户端是接收⽅，服务端是发送⽅</li> <li>假设接收窗⼝和发送窗⼝相同，都为 200</li> <li>假设两个设备在整个传输过程中都保持相同的窗⼝⼤⼩，不受外界影响</li></ul> <p><img src="/assets/1693997445870.png" alt="1693997445870"></p> <p>流量控制
根据上图的流量控制，说明下每个过程：</p> <ol><li>客户端向服务端发送请求数据报⽂。这⾥要说明下，本次例⼦是把服务端作为发送⽅，所以没有画
出服务端的接收窗⼝。</li> <li>服务端收到请求报⽂后，发送确认报⽂和 80 字节的数据，于是可⽤窗⼝ <strong>Usable</strong> 减少为 120 字
节，同时 <strong>SND.NXT</strong> 指针也向右偏移 80 字节后，指向 321，<strong>这意味着下次发送数据的时候，序列</strong> <strong>号是 321</strong>。</li> <li>客户端收到 80 字节数据后，于是接收窗⼝往右移动 80 字节， RCV.NXT 也就指向 321，这意味着
客户端期望的下⼀个报⽂的序列号是 321，接着发送确认报⽂给服务端。</li> <li>服务端再次发送了 120 字节数据，于是可⽤窗⼝耗尽为 0，服务端⽆法再继续发送数据。</li> <li>客户端收到 120 字节的数据后，于是接收窗⼝往右移动 120 字节， RCV.NXT 也就指向 441，接着
发送确认报⽂给服务端。</li> <li>服务端收到对 80 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 321，于是可⽤窗⼝
Usable 增⼤到 80。</li> <li>服务端收到对 120 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 441，于是可⽤窗⼝
Usable 增⼤到 200。</li> <li>服务端可以继续发送了，于是发送了 160 字节的数据后， SND.NXT 指向 601，于是可⽤窗⼝
Usable 减少到 40。</li></ol> <h3 id="滑动窗口是如何实现的"><a href="#滑动窗口是如何实现的" class="header-anchor">#</a> 滑动窗口是如何实现的：</h3> <p>发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：</p> <p><img src="/assets/640-1691587280570.png" alt="图片">img</p> <ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li> <li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li> <li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li> <li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li></ul> <p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。</p> <p><img src="/assets/640-1691587280742.png" alt="图片">可用窗口耗尽</p> <p>在下图，当收到之前发送的数据 <code>32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 <code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code>52~56</code> 这 5 个字节的数据了。</p> <p><img src="/assets/640-1691587280742.png" alt="图片">32 ~ 36 字节已确认</p> <p>接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：</p> <ul><li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li> <li>#3 是未收到数据但可以接收的数据；</li> <li>#4 未收到数据并不可以接收的数据；</li></ul> <p><img src="/assets/640.jpg" alt="图片">接收窗口</p> <p>其中三个接收部分，使用两个指针进行划分:</p> <ul><li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li> <li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li> <li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul> <h3 id="tcp-滑动窗口"><a href="#tcp-滑动窗口" class="header-anchor">#</a> TCP 滑动窗口</h3> <ul><li>Stop-Wait：停等协议，swnd = rwnd = 1</li> <li>Go-Back-N：GBN 协议，swnd = n，rwnd = 1，发送方可以连续发送多个数据包，但只有在接收方确认接收到前一个数据包之后，才会继续发送下一个数据包。如果接收方在某个数据包中出现错误，它会发送一个 NACK（Negative Acknowledgement）信号给发送方，要求发送方重新发送从出错数据包开始之后的所有数据</li> <li>Selective-Repeat：SR 协议，swnd = rwnd = n，发送方可以连续发送多个数据包，但接收方只需要确认已经接收到的数据包，没有出错的数据包可以直接被缓存起来，而无需重新传输。当出现丢包时，接收方会发送一个 SACK（Selective Acknowledgement）信号给发送方，告诉它需要重新发送哪些数据包。</li></ul> <blockquote><p>参考：<a href="https://blog.csdn.net/weixin_46935110/article/details/126686631" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_46935110/article/details/126686631<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_23、拥塞控制原理听说过吗-讲讲"><a href="#_23、拥塞控制原理听说过吗-讲讲" class="header-anchor">#</a> 23、拥塞控制原理听说过吗？讲讲？</h2> <p>拥塞控制目的是<strong>防止数据过多注入</strong>到网络中<strong>导致网络资源（路由器、交换机等）过载</strong>。因为拥塞控制涉及网络链路全局，所以属于全局控制。<strong>控制拥塞使用拥塞窗口</strong>。</p> <h3 id="tcp-拥塞控制算法"><a href="#tcp-拥塞控制算法" class="header-anchor">#</a> TCP 拥塞控制算法</h3> <ul><li>慢启动：假定 swnd(发送窗口)= cwnd(拥塞窗口)，发送方每接收到一个 ACK，cwnd 就会增加1，这个阶段 cwnd 呈<strong>指数式</strong>增长</li> <li>拥塞避免：当 cwnd 增长到慢启动门限 slow start threshold 时，使用拥塞避免算法，cwnd 每次加1</li> <li>拥塞发生：如果出现（超时）重传，就说明发生了拥塞，ssthread = cwnd/2，swnd = cwnd = 1</li> <li>快重传和快恢复：如果连续收到 3个重复的 ACK，可以使用快速重传机制，ssthread = cwnd/2，cwnd = ssthread + 3，<strong>直接进入到拥塞避免阶段</strong></li> <li>最终拥塞窗口会收敛于稳定值。</li></ul> <blockquote><p>参考：<a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html" target="_blank" rel="noopener noreferrer">https://xiaolincoding.com/network/3_tcp/tcp_feature.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="流量控制-vs-拥塞控制"><a href="#流量控制-vs-拥塞控制" class="header-anchor">#</a> 流量控制 vs 拥塞控制</h3> <ul><li><strong>流量控制是点到点/端到端的控制</strong>，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。</li> <li><strong>拥塞控制全局性的过程</strong>，是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</li></ul> <h2 id="_24、get和post-的区别-你知道哪些"><a href="#_24、get和post-的区别-你知道哪些" class="header-anchor">#</a> 24、GET和POST 的区别，你知道哪些？</h2> <ol><li><p><strong>get是获取数据，post是修改数据</strong></p></li> <li><p><strong>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）</strong></p></li> <li><p><strong>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制</strong>。</p></li> <li><p><strong>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)</strong>。</p></li> <li><p>G<strong>ET请求会被浏览器主动缓存，而POST不会，除非手动设置。</strong></p></li> <li><p>本质区别：GET是幂等的，而POST不是幂等的</p> <blockquote><p>这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p></blockquote></li></ol> <p>正因为它们有这样的区别，所以不应该且<strong>不能用get请求做数据的增删改这些有副作用的操作</strong>。因为get请求是幂等的，<strong>在网络不好的隧道中会尝试重试</strong>。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</p> <h3 id="第二种"><a href="#第二种" class="header-anchor">#</a> 第二种</h3> <ul><li><p><strong>GET</strong>：GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据（不修改）。</p> <blockquote><p>因GET请求的不安全性，在处理敏感数据时，绝不可以使用GET请求。</p></blockquote></li> <li><p><strong>POST</strong>：用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。</p> <blockquote><p>POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求。</p></blockquote></li></ul> <blockquote><p>两者区别参考：<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/logsharing/p/8448446.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li><p>最直观的区别就是：GET将参数包含在URL中，POST 通过request body传递参数</p></li> <li><p>GET请求在URL中传递的参数有长度限制，而且参数直接暴露在URL中有危险，POST没有，</p></li> <li><p>最大的区别就是：GET产生一个TCP数据包，POST产生两个TCP数据包。具体来说即是对于GET方式的请求，<strong>浏览器会把http header和data一并发送出去，服务器响应200 ok（返回数据）</strong>；而对于POST，<strong>浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</strong>。</p></li></ol></blockquote> <h2 id="_25、session和cookie应该如何去选择-适用场景"><a href="#_25、session和cookie应该如何去选择-适用场景" class="header-anchor">#</a> 25、Session和cookie应该如何去选择（适用场景）？</h2> <ul><li><p>cookie 和 session 都是用来跟踪<strong>浏览器用户身份的会话方式</strong>。</p></li> <li><p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</p></li> <li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上。</p></li> <li><p>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p></li> <li><p>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p></li></ul> <h3 id="cookie和session的关系和区别是什么"><a href="#cookie和session的关系和区别是什么" class="header-anchor">#</a> Cookie和Session的关系和区别是什么</h3> <ul><li>cookie 和 session 都是用来跟踪<strong>浏览器用户身份的会话方式</strong>。<a href="https://blog.csdn.net/chen13333336677/article/details/100939030" target="_blank" rel="noopener noreferrer">了解一下两者的过程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>cookie 数据保存在客户端，session 数据保存在服务端
<ul><li>浏览器第一次访问服务器时，服务器端创建 Cookie，该 Cookie 中包含用户的信息，然后将该 Cookie 发送到浏览器端，服务器端通过 Cookie 中携带的数据区分不同的用户</li> <li>session 基于 cookies 实现，浏览器第一次访问服务器时候创建一个 session，同时会创建一个特殊的 Cookie（<code>name</code>为<code>JSESSIONID</code>的固定值，<code>value</code>为<code>session对象的ID</code>），然后将该 Cookie 发送至浏览器端，服务器端根据 name 为 JSESSIONID 的 Cookie 的 value(sessionId)，去查询Session对象，从而区分不同用户。</li></ul></li> <li>cookies 不是很安全，存储数据大小限制 3K，有 cookies 欺骗，session 一般存放登录等重要信息</li> <li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用 Cookies</li></ul> <h2 id="_26、介绍一下tcp重传"><a href="#_26、介绍一下tcp重传" class="header-anchor">#</a> 26、介绍一下TCP重传</h2> <p>TCP（Transmission Control Protocol）重传是指在网络通信中，当<strong>发送方发送数据包到接收方后，如果发送方没有收到接收方的确认（ACK）消息</strong>，或者<strong>接收方收到的数据包出现错误，发送方会重新发送相同的数据包</strong>。下面是对TCP重传的介绍：</p> <ol><li><p>原因：TCP重传的主要原因是网络中可能存在的丢包、延迟、拥塞等问题。<strong>当发送方发送数据包后，如果接收方没有及时回复确认消息，或者确认消息在网络中丢失，发送方无法确定数据是否已经成功传输。为了确保数据的可靠传输，发送方会选择重传数据包</strong>。</p></li> <li><p>超时检测：发送方在发送数据包后会<strong>启动一个计时器</strong>，<strong>等待接收方的确认消息</strong>。如果在超时时间内没有收到确认消息，发送方会认为数据包丢失，触发重传机制。超时时间的选择通常<strong>基于网络的往返时间（RTT）和一些拥塞控制算法</strong>。</p></li> <li><p>快速重传：TCP还引入了<strong>快速重传机制，以减少重传的延迟</strong>。当发送方连续收到3次相同的确认消息时，即接<strong>收方对同一个数据包进行多次确认，发送方会立即重传对应的数据包，而不需要等待超时</strong>。</p></li> <li><p>选择性重传：TCP还支持选择性重传，即只重传吧丢失或损坏的数据包，而不是重传所有的数据包。通过使用序号（sequence number）和确认号（acknowledgment number），发送方和接收方可以确定丢失的数据包，并进行重传。<strong>（SACK，选择性确认）</strong></p></li></ol> <h2 id="_27、面试题-服务器在传输过程中死机了-客户端有什么反应"><a href="#_27、面试题-服务器在传输过程中死机了-客户端有什么反应" class="header-anchor">#</a> 27、面试题：服务器在传输过程中死机了，客户端有什么反应？</h2> <p>当服务器在传输过程中死机时，客户端可能会有以下几种反应：</p> <ol><li><p><strong>连接中断</strong>：由于服务器死机，与服务器建立的网络连接会被中断。客户端无法再通过该连接发送或接收数据。通常，<strong>客户端的网络库或操作系统会检测到连接的异常中断，并通知应用程序连接已经断开</strong>。</p></li> <li><p><strong>超时</strong>：如果客户端<strong>在服务器死机前发送了请求并等待响应</strong>，但由于服务器无法响应，客户端可能会在一段时间后超时。超时时间的长短取决于客户端的设置和应用程序的实现。一旦超时发生，客户端可以选择重新尝试请求、显示错误信息或执行其他逻辑。</p></li> <li><p><strong>错误处理</strong>：一些客户端应用程序可能会捕获连接中断或超时的异常，并进行相应的错误处理。例如，应用程序可以显示错误提示、记录日志、尝试与其他服务器建立连接等。具体的错误处理方式取决于应用程序的需求和设计。</p></li> <li><p><strong>重连</strong>：在某些情况下，客户端可能会尝试重新连接到服务器，以恢复与服务器的通信。这可能是通过重新建立网络连接或<strong>与备用服务器建立连接来实现的</strong>。客户端应用程序可以根据具体的需求和策略来决定是否进行重连操作。</p></li></ol> <h2 id="_28、面试题-如果客户端一直死机-连接什么时候终止"><a href="#_28、面试题-如果客户端一直死机-连接什么时候终止" class="header-anchor">#</a> 28、面试题：如果客户端一直死机，连接什么时候终止？</h2> <ol><li><p>服务器端超时：在服务器端设置一个保活定时器，当定时器开始工作后就定时的向网络通信的另一端发出<strong>保活探测</strong>的TCP报文，如果接收到了ACK报文，那么就证明对方存活，可以继续保有连接；否则就证明网络存在故障。</p></li> <li><p><strong>心跳机制</strong>：通过在客户端发送心跳包来检测服务器是否存活。如果服务器在一定时间内没有收到客户端的心跳包，则认为客户端已经宕机了，需要重新建立连接。</p></li> <li><p>客户端的重连机制：有些客户端应用程序实现了重连机制，当客户端重新启动或恢复正常运行时，会尝试重新建立与服务器的连接。在这种情况下，旧的连接可能会被关闭，并建立一个新的连接。</p></li></ol> <h2 id="_29、tcp的连接指的是什么东西"><a href="#_29、tcp的连接指的是什么东西" class="header-anchor">#</a> 29、TCP的连接指的是什么东西</h2> <p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p> <p><img src="/assets/640-1691581681804.png" alt="图片"></p> <h2 id="_31、路由器和交换机的区别"><a href="#_31、路由器和交换机的区别" class="header-anchor">#</a> 31、路由器和交换机的区别</h2> <p><strong>从功能上来说</strong>：</p> <p>路由器和交换机都是计算机网络中的设备，但是它们的功能不同。</p> <p>路由器是连接因特网中各局域网和广域网的设备，用来做网间连接，也就是用来连接不同网络的。</p> <p>而交换机是一个扩大网络的器材，能为子网络中提供更多的连接端口，以便连接更多的计算机。</p> <p><strong>从层级上来说</strong>：</p> <p><strong>普通的交换机一般工作在OSI七层模型的第二层·数据链路层，而路由器则工作在第三层·网络层</strong>。</p> <h2 id="_32、udp怎么实现可靠传输"><a href="#_32、udp怎么实现可靠传输" class="header-anchor">#</a> 32、UDP怎么实现可靠传输</h2> <p><strong>最简单的方式是在应用层模仿传输层TCP的可靠性传输</strong>。下面不考虑拥塞处理，可靠UDP的简单设计。</p> <ul><li>1、添加seq/ack机制，确保数据发送到对端</li> <li>2、添加发送和接收缓冲区，主要是用户超时重传。</li> <li>3、添加超时重传机制。</li></ul> <p>详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p> <h2 id="_33、怎么理解tcp的流的概念"><a href="#_33、怎么理解tcp的流的概念" class="header-anchor">#</a> 33、怎么理解TCP的流的概念？</h2> <p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，<strong>也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输</strong>。</p> <p>这时，<strong>接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的</strong>，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。</p> <p>举个实际的例子来说明。</p> <p>发送方准备发送 「Hi.」和「I am Xiaolin」这两个消息。</p> <p>在发送端，当我们<strong>调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中</strong>。</p> <p>至于什么时候真正被发送，<strong>取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。也就是说，我们<strong>不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去</strong>。</p> <p>如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用 send 函数先后发送 「Hi.」和「I am Xiaolin」 报文，那么实际的发送很有可能是这几种情况。</p> <p>第一种情况，这两个消息被分到同一个 TCP 报文，像这样：</p> <p><img src="/assets/640-1691587588158.png" alt="图片"></p> <p>第二种情况，「I am Xiaolin」的部分随 「Hi」 在一个 TCP 报文中发送出去，像这样：</p> <p><img src="/assets/640-1691587588157.png" alt="图片"></p> <p>第三种情况，「Hi.」 的一部分随 TCP 报文被发送出去，另一部分和 「I am Xiaolin」 一起随另一个 TCP 报文发送出去，像这样。</p> <p><img src="/assets/640-1692859576534.png" alt="图片"></p> <p>类似的情况还能举例很多种，这里主要是想说明，我们不知道 「Hi.」和 「I am Xiaolin」 这两个用户消息是如何进行 TCP 分组传输的。</p> <p>因此，<strong>我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议</strong>。</p> <p><strong>当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息</strong>。</p> <p>要解决这个问题，要交给<strong>应用程序</strong>。</p> <h2 id="_35、tcp粘包问题是什么-你会如何去解决它"><a href="#_35、tcp粘包问题是什么-你会如何去解决它" class="header-anchor">#</a> 35、TCP粘包问题是什么？你会如何去解决它？</h2> <p>当<strong>两个消息的某个部分内容被分到同一个 TCP 报文时</strong>，就是我们常说的 TCP 粘包问题，这时<strong>接收方不知道消息的边界的话，是无法读出有效的消息</strong>。</p> <h3 id="产生原因"><a href="#产生原因" class="header-anchor">#</a> 产生原因</h3> <p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p> <ul><li><p>由TCP<strong>连接复用</strong>造成的粘包问题。</p></li> <li><p>因为TCP默认会使用</p> <p>Nagle算法，此算法会导致粘包问题。</p> <ul><li>只有上一个分组得到确认，才会发送下一个分组；</li> <li>收集多个小分组，在一个确认到来时一起发送。</li></ul></li> <li><p><strong>数据包过大</strong>造成的粘包问题。</p></li> <li><p>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</p></li> <li><p><strong>接收方不及时接收缓冲区的包，造成多个包接收</strong></p></li></ul> <h3 id="解决方法"><a href="#解决方法" class="header-anchor">#</a> <strong>解决方法</strong></h3> <ol><li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法</li> <li>尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。</li> <li>头部标记分步接收。在TCP报文的头部加上表示数据长度。</li> <li>应用层发送数据时<strong>定长</strong>发送。</li></ol> <h3 id="回答2-2"><a href="#回答2-2" class="header-anchor">#</a> 回答2：</h3> <p>一般有三种方式分包的方式：</p> <ul><li>固定长度的消息；</li> <li>特殊字符作为边界；</li> <li>自定义消息结构。</li></ul> <h4 id="固定长度的消息"><a href="#固定长度的消息" class="header-anchor">#</a> 固定长度的消息</h4> <p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p> <p>但是这种方式灵活性不高，实际中很少用。</p> <h4 id="特殊字符作为边界"><a href="#特殊字符作为边界" class="header-anchor">#</a> 特殊字符作为边界</h4> <p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p> <p>HTTP 是一个非常好的例子。</p> <p><img src="/assets/640-1691587954849.png" alt="图片"></p> <p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p> <p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p> <h4 id="定义消息结构"><a href="#定义消息结构" class="header-anchor">#</a> 定义消息结构</h4> <p>我们可以自定义一个消息结构，由包头和数据组成，其中<strong>包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大</strong>。</p> <p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token punctuation">{</span> 
    u_int32_t message_length<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> message_data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> message<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当接收方接收到包头的大小（比如 4 个字节）后，就<strong>解析包头的内容</strong>，于是就可以<strong>知道数据的长度</strong>，然后接下来<strong>就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了</strong>。</p> <h2 id="_37、简述-traceroute-命令的原理"><a href="#_37、简述-traceroute-命令的原理" class="header-anchor">#</a> 37、简述 traceroute 命令的原理</h2> <ol><li><p>构造一个 UDP 报文，TTL 分别为1，当这个报文到达第一个路由器后，TTL 减去1后为零，报文被丢弃，然后路由器发送 ICMP 报文（时间超过）给源主机。</p></li> <li><p>构造 UDP 报文，TTL 为2，同样的，第二个路由器会返回 ICMP 报文（时间超过）给源主机</p> <blockquote><p>以此类推，注意发送过程中的 UDP 报文使用的端口都是<strong>非法端口</strong>，以使最后达到的时候无法交付，不然你就不知道什么时候应该停</p></blockquote></li> <li><p>直到 TTL 到达某个值，而这个值可以使这个UDP报文刚好到达目的主机，由于报文的端口号不合法，目的主机返回 ICMP（端口不可达）报文给源主机。</p> <blockquote><p>上述过程中，<strong>路由器和目的主机返回的ICMP报文中均含有它们的地址，所以得到了路径</strong>。</p> <p>实际实现中，源主机每次发送三个相同TTL的UDP报文，因为现实中网络环境比较复杂，可能会有丢包情况发生。</p></blockquote></li></ol> <h2 id="_40、数据包封装和解封过程"><a href="#_40、数据包封装和解封过程" class="header-anchor">#</a> 40、数据包封装和解封过程</h2> <p><img src="/assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139313031333131333735373333392e706e67.png" alt="img"></p> <p>段(segment) - 包(packet) - 帧(frame) - 位(bit)</p> <h2 id="_43、tcp四个计时器"><a href="#_43、tcp四个计时器" class="header-anchor">#</a> 43、TCP四个计时器</h2> <ul><li>重传计时器：重传丢失的报文段 <strong>RTT</strong>（Round-Trip Time）</li> <li>保活计时器：解决客户端出现问题的情况，每当服务器端收到客户端的数据时，都将保活计时器重新设置（通常设置为2小时）。过了2小时后，服务器端如果没有收到客户端的数据，会发送探测报文段给客户端，并且每隔75秒发送一个，当连续发送10次以后，仍没有收到对端的来信，则服务器端认为客户端出现故障，并会终止连接</li> <li>时间等待计时器：用于解决服务端发送FIN报文段之后，客户端这边发送ACK丢失的情况 <strong>2MSL</strong></li> <li><strong>坚持计时器：应付接收端零窗口问题，当发送端TCP收到接收端发来的零窗口通知时，就会启动坚持计时器。当计时器的期限到达时，发送端就会主动发送一个特殊的报文段告诉对方确认已经丢失，必须重新发送</strong></li></ul> <h2 id="_45、http的方法有哪些"><a href="#_45、http的方法有哪些" class="header-anchor">#</a> 45、HTTP的方法有哪些</h2> <ul><li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li> <li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li> <li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li> <li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li> <li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li> <li>OPTIONS：查询相应URI支持的HTTP方法。</li></ul> <h2 id="_46、简述-https-的加密与认证过程"><a href="#_46、简述-https-的加密与认证过程" class="header-anchor">#</a> 46、简述 HTTPS 的加密与认证过程</h2> <p>首先认证服务器 ⟶ 协商会话密钥 ⟶ 加密传输</p> <p>加密有对称密钥和非对称密钥（公钥和私钥）甚至还有混合密钥，认证过程有CA，包含数字签名</p> <blockquote><p>参考1：<a href="https://www.cnblogs.com/kubidemanong/p/9390021.html" target="_blank" rel="noopener noreferrer">一文看懂https如何保证数据传输的安全性的 - 帅地 - 博客园 (cnblogs.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>参考2：<a href="https://www.cnblogs.com/xuanyuan/p/15122294.html" target="_blank" rel="noopener noreferrer">一个故事看懂HTTPS - 轩辕之风 - 博客园 (cnblogs.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="小林-2"><a href="#小林-2" class="header-anchor">#</a> 小林</h3> <p>SSL/TLS 协议基本流程：</p> <ul><li>客户端向服务器索要并验证服务器的公钥。</li> <li>双方协商生产「会话秘钥」。</li> <li>双方采用「会话秘钥」进行加密通信。</li></ul> <p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p> <p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，基于 RSA 算法的 TLS 握手过程比较容易理解，所以这里先用这个给大家展示 TLS 握手过程，如下图：</p> <p><img src="/assets/640-1692859817292.jpg" alt="图片">HTTPS 连接建立过程</p> <p>TLS 协议建立的详细流程：</p> <p><em>1. ClientHello</em></p> <p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p> <p>在这一步，客户端主要向服务器发送以下信息：</p> <p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p> <p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p> <p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p> <p><em>2. SeverHello</em></p> <p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p> <p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p> <p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p> <p>（3）确认的密码套件列表，如 RSA 加密算法。</p> <p>（4）服务器的数字证书。</p> <p><em>3.客户端回应</em></p> <p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p> <p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p> <p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p> <p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p> <p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p> <p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p> <p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p> <p><em>4. 服务器的最后回应</em></p> <p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p> <p>然后，向客户端发送最后的信息：</p> <p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p> <p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p> <p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p> <h2 id="_80、dns劫持"><a href="#_80、dns劫持" class="header-anchor">#</a> 80、DNS劫持</h2> <blockquote><p>那DNS服务器会告诉你A网站的IP是A，B网站的IP是B，那假如你输入的A网站域名，但是他给你B的IP，你是不是就访问到别的网站去了？</p> <p>既然DNS服务器可以这么玩，我是不是可以将用户引导到我的网站上？比如你要看个电影，然后你输入了爱奇艺的官网，然后我作为DNS服务器，我把优酷的IP返回给你，最后就是你虽然输入的爱奇艺官网，但是却得到了优酷的IP并访问了优酷的IP，进入了优酷的网站上。</p> <p>当然这里我只是举个例子，我举这个例子就是想告诉大家，DNS服务器想给你返回什么IP就给你返回什么，所以他可以在幕后操作一些东西。最简单的就是广告。比如A网站没有广告，你直接访问就是没有的，但是你的DNS服务器把A网站下载下来了，给这个网站加了个广告，然后重新上传到了一个IP上，并把这个IP告诉了你，那就是你虽然输入的A网站的域名，但是你访问的是一个包含了广告的复制版A网站，虽然两者功能一样，但是却完全不是一个服务器上的。</p> <p>这些就被我们成为DNS劫持，DNS劫持对于网络访问的影响和体验是非常严重的，除了DNS服务器，你的路由器同样可以这么干，所以在买路由器的时候也有人会关注这个路由器是否会进行DNS劫持。</p></blockquote> <h2 id="_82、osi和tcp-ip模型"><a href="#_82、osi和tcp-ip模型" class="header-anchor">#</a> 82、OSI和TCP/IP模型</h2> <p><img src="/assets/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f3230313330393039313635303237353436.png" alt="img"></p> <p><img src="/assets/1693107379430.png" alt="1693107379430"></p> <p>7）应用层</p> <p><strong>作用</strong>：为应用软件提供接口，使应用程序能够使用网络服务</p> <p>常见的应用层协议：**http(80)、ftp(20/21)、smtp(25)、pop3(110)、telnet(23)、dns(53)**等</p> <p>6）表示层</p> <p><strong>作用</strong>：数据的解码和编码、数据的加密和解密、数据的压缩和解压缩</p> <p>常见的标准如：ASCI、IJPEG、……</p> <p>5）会话层</p> <p><strong>作用</strong>：<strong>负责建立、管理和终止表示层实体之间的会话连接</strong></p> <p>在各节点之间提供会话控制</p> <p>它在系统之间协调通信过程,并提供3种不同的方式 来组织它们之间的通信:单工、半双工和全双工</p> <p>4）传输层：</p> <p><strong>作用</strong>：负责建立端到端的连接，保证报文在端到端之间的传输。</p> <p>服务点编址、分段与重组、连接控制、流量控制、 差错控制。</p> <p>3）网络层</p> <p><strong>作用</strong>：为网络设备提供逻辑地址（三层地址）</p> <p>进行路由选择、维护路由表</p> <p>负责将分组数据从源端传输到目的端，  <strong>IP, ICMP, ARP</strong></p> <p><strong>设备：路由器（Router）</strong></p> <p>广播、组播隔绝</p> <p>寻址及转发，选择到达目的网络的最佳路径</p> <p>流量管理</p> <p>连接广域网(WAN)</p> <p><strong>逻辑地址：IP地址（三层、不同网络间通信时关注）</strong></p> <p><img src="/assets/1701680567609.png" alt="1701680567609"></p> <p>2）数据链路层的作用：</p> <p><strong>作用</strong>：在不可靠的物理链路上，提供可靠的数据传输服务，把帧从一跳（结点）移动到另一跳（结点）。</p> <p>组帧、物理编址、流量控制、差错控制、接入控制</p> <p><strong>设备：交换机</strong></p> <p>每个端口是一个冲突域</p> <p>整台交换机属于一个广播域</p> <p><strong>物理地址（硬件地址）：MAC地址（二层，烧录在网卡上不变，本地有效，同一网段内关注，到了LAN局域网里才考虑MAC）</strong></p> <p><img src="/assets/1701680577342.png" alt="1701680577342"></p> <p>1）物理层的作用：</p> <ul><li>负责把逐个的比特从一跳（结点）移动到另一跳（结点）。</li></ul> <p>物理层功能：</p> <ul><li>定义接口和媒体的物理特性</li> <li>定义比特的表示、数据传输速率、信号的传输模式（单工、半双工、全双工）</li> <li>定义网络物理拓扑（网状、星型、环型、总线型等拓扑）</li></ul> <p><strong>设备：集线器</strong></p> <ul><li>整台设备在同一个冲突域 (collision domain)</li> <li>整台设备都在同一个广播域( broadcast domain)</li> <li>设备共享带宽</li></ul> <p><strong>各层常见设备：</strong></p> <p>应用层——计算机：<strong>应用程序</strong>，如FTP，SMTP，HTTP</p> <p>表示层——计算机：<strong>编码方式</strong>，图像编解码、URL字段传输编码</p> <p>会话层——计算机：<strong>建立会话</strong>，SESSION认证、断点续传</p> <p>传输层——计算机：<strong>进程和端口</strong></p> <p>网络层——网络：<strong>路由器，防火墙、多层交换机</strong></p> <p>数据链路层——网络：<strong>网卡，网桥，交换 机</strong></p> <p>物理层——网络：<strong>中继器，集线器、网线、HUB</strong></p> <h2 id="_84、为什么服务器会缓存这一项功能-如何实现的"><a href="#_84、为什么服务器会缓存这一项功能-如何实现的" class="header-anchor">#</a> 84、为什么服务器会缓存这一项功能?如何实现的？</h2> <h3 id="原因"><a href="#原因" class="header-anchor">#</a> <strong>原因</strong></h3> <ul><li>缓解服务器压力；</li> <li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。</li> <li>并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul> <h3 id="实现方法"><a href="#实现方法" class="header-anchor">#</a> <strong>实现方法</strong></h3> <ul><li>让代理服务器进行缓存；</li> <li>让客户端浏览器进行缓存。</li></ul> <h2 id="_86、为什么区域传送用tcp协议"><a href="#_86、为什么区域传送用tcp协议" class="header-anchor">#</a> 86、为什么区域传送用TCP协议？</h2> <p>因为TCP协议可靠性好！</p> <p>你要<strong>从主DNS上复制内容</strong>啊，你用不可靠的UDP？ 因为<strong>TCP协议传输的内容大</strong>啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？
<strong>所以用TCP协议比较好！</strong></p> <h2 id="_88、dns负载均衡是什么策略"><a href="#_88、dns负载均衡是什么策略" class="header-anchor">#</a> 88、DNS负载均衡是什么策略？</h2> <p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。</p> <p>处理办法就是用DNS负载均衡技术，它的原理是在<strong>DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器</strong>，从而达到负载均衡的目的｡</p> <p>例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p> <h2 id="_90、介绍几个tcp对应的应用层协议"><a href="#_90、介绍几个tcp对应的应用层协议" class="header-anchor">#</a> 90、介绍几个TCP对应的应用层协议？</h2> <p><strong>FTP</strong>：定义了文件传输协议，使用21端口.
<strong>Telnet</strong>：它是一种用于远程登陆的端口,23端口
<strong>SMTP</strong>：定义了简单邮件传送协议，服务器开放的是25号端口。
<strong>POP3</strong>：它是和SMTP对应，POP3用于接收邮件。</p> <h2 id="_92、数据链路层你知道哪些常见协议"><a href="#_92、数据链路层你知道哪些常见协议" class="header-anchor">#</a> 92、数据链路层你知道哪些常见协议？</h2> <table><thead><tr><th>协议</th> <th>名称</th> <th>作用</th></tr></thead> <tbody><tr><td>ARP</td> <td>地址解析协议</td> <td>根据IP地址获取物理地址</td></tr> <tr><td>RARP</td> <td>反向地址转换协议</td> <td>根据物理地址获取IP地址</td></tr> <tr><td>PPP</td> <td>点对点协议</td> <td>主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案</td></tr></tbody></table> <h2 id="_94、dhcp"><a href="#_94、dhcp" class="header-anchor">#</a> 94、DHCP</h2> <p><strong>什么叫做 DHCP？作用是什么？</strong></p> <p>1、DHCP 是动态主机配置协议</p> <p>2、DHCP <a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&amp;from=20065" target="_blank" rel="noopener noreferrer">服务器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的作用是给主机动态的分配地址，DHCP 分配地址是有状态的。DHCP服务器会记录<strong>地址和MAC的对应，已经冲突的地址，分配出去的地址和空闲的地址</strong>。</p> <ul><li><strong>IP地址分配</strong>：DHCP的主要功能之一是分配IP地址给网络上的设备。这些IP地址可以是临时的（动态分配）或永久的（静态分配）。动态分配使得网络管理员能够更有效地管理IP地址资源，避免了手动分配的复杂性。</li> <li><strong>子网掩码和默认网关</strong>：除了IP地址之外，DHCP还可以分配子网掩码和默认网关等网络配置信息，这些信息对于设备正确地与网络相连至关重要。子网掩码用于确定设备所在的子网，而默认网关是设备与其他子网或互联网通信的入口点。</li> <li><strong>DNS服务器</strong>：DHCP还可以提供DNS（域名系统）服务器的信息，这对于将主机名解析为IP地址以实现互联网访问非常重要。DNS服务器能够将人类可读的域名转换为IP地址，使设备能够正确地找到所需的网络资源。</li> <li><strong>租约管理</strong>：DHCP分配的IP地址通常具有<strong>租约期限</strong>，即一段时间后它们<strong>将过期并需要续租</strong>。这<strong>有助于网络管理员回收未使用的IP地址并确保网络资源的有效分配</strong>。</li></ul> <p>总之，DHCP是一种简化了网络管理的协议，它自动分配和管理网络配置信息，使设备能够轻松地连接到网络并实现通信。这对于大型网络和复杂的IT环境尤为重要。</p> <h2 id="_96、telnet"><a href="#_96、telnet" class="header-anchor">#</a> 96、telnet</h2> <p>FTP（File Transfer Protocol）是一种用于在计算机网络上传输文件的标准网络协议。以下是对FTP的简要介绍：</p> <ul><li><strong>文件传输</strong>：FTP是一种用于在网络上传输文件的协议。它允许<strong>用户将文件从一个计算机（FTP客户端）传输到另一个计算机（FTP服务器）或从服务器下载文件</strong>。</li> <li><strong>双向传输</strong>：FTP协议采用客户端-服务器模型，其中客<strong>户端发起连接并向服务器发出请求，而服务器响应并处理这些请求</strong>。这使得文件的双向传输成为可能，即客户端可以上传和下载文件。</li> <li><strong>认证和授权</strong>：在FTP传输中，通常需要进行身份验证，以确保只有授权用户可以访问特定的文件或目录。这可以通过用户名和密码进行认证来实现。</li> <li><strong>端口</strong>：<strong>FTP协议使用两个TCP端口进行通信：一个用于控制连接（默认端口21），负责建立、维护和结束FTP会话，另一个用于数据传输（默认端口20），用于实际传输文件</strong>。</li> <li><strong>工作模式</strong>：FTP有两种工作模式，即主动模式和被动模式。在主动模式中，客户端使用一个端口建立控制连接，并通过另一个端口接收数据。而在被动模式中，客户端使用一个端口建立控制连接，并通过另一个端口发送请求和接收数据。</li></ul> <p>总体而言，FTP是一种用于在计算机网络上传输文件的常用协议，具有可靠性、广泛支持和广泛的应用范围。它为用户提供了简单而有效的文件传输机制。</p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/smileatl/smileatlRepository_source/edit/master/docs/05.工作/60.其他-interview/90.计算机网络.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/12/04, 16:45:12</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/2791f7/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">85-操作系统-多线程_多进程_线程池</div></a> <a href="/pages/236a38/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">数据结构与算法</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/2791f7/" class="prev">85-操作系统-多线程_多进程_线程池</a></span> <span class="next"><a href="/pages/236a38/">数据结构与算法</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/93a902/"><div>
            cpp新特性
            <!----></div></a> <span class="date">12-04</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/163c8a/"><div>
            复刷还是没记住的题
            <!----></div></a> <span class="date">12-04</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/a7672c/"><div>
            mynetlib题目
            <!----></div></a> <span class="date">12-04</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1355484300@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/smileatl" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span>smileatl | <a href="https://github.com/smileatl/smileatlRepository_source/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4813674f.js" defer></script><script src="/assets/js/3.cf27d530.js" defer></script><script src="/assets/js/183.0f688ed3.js" defer></script>
  </body>
</html>
